[{"title":"注解","date":"2021-04-26T13:51:20.000Z","path":"2021/04/26/注解/","text":"注解的概述 从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是Annotation(注解) Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。 Annotation 可以像修饰符一样被使用, 可用于修饰包,类, 构造器, 方法, 成员变量, 参数, 局部变量的声明, 这些信息被保存在 Annotation 的 “name=value” 对中。 在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。 未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，现在的Struts2有一部分也是基于注解的了，注解是一种趋势，一定程度上可以说：框架 = 注解 + 反射 + 设计模式。 常见的Annotation示例 示例一：生成文档相关的注解 示例二：在编译时进行格式检查(JDK内置的三个基本注解) @Override: 限定重写父类方法, 该注解只能用于方法 @Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择 @SuppressWarnings: 抑制编译器警告 示例三：跟踪代码依赖性，实现替代配置文件功能 自定义 Annotation自定义方法：参照@SuppressWarnings定义 注解声明为：@interface 内部定义成员，通常使用value表示 可以指定成员的默认值，使用default定义 如果自定义注解没有成员，表明是一个标识作用。 123public @interface MyAnnotation &#123; String value() default &quot;hello&quot;;&#125; 注意 如果注解有成员，在使用注解时，需要指明成员的值。 自定义注解必须配上注解的信息处理流程(使用反射)才有意义。 自定义注解通过都会指明两个元注解：Retention、Target。 jdk 提供的4种元注解什么是元注解 元注解：对现有的注解进行解释说明的注解。 4种元注解 @Retention：只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 的生命周期, @Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用@Rentention 时必须为该 value 成员变量指定值: SOURCE:在源文件中有效（即源文件保留），编译器直接丢弃这种策略的注释。 CLASS:在class文件中有效（即class保留） ， 当运行 Java 程序时, JVM 不会保留注解。 这是默认值。 RUNTIME:在运行时有效（即运行时保留），当运行 Java 程序时, JVM 会保留注释。程序可以通过反射获取该注释。 @Target: 用于修饰 Annotation 定义, 用于指定被修饰的 Annotation 能用于修饰哪些程序元素。 @Documented: 用于指定被该元 Annotation 修饰的 Annotation 类将被javadoc 工具提取成文档。默认情况下，javadoc是不包括注解的。 @Inherited: 被它修饰的 Annotation 将具有继承性。如果某个类使用了被@Inherited 修饰的 Annotation, 则其子类将自动具有该注解。 通过反射获取注解信息 到反射内容时系统讲解!!! jdk 8 中注解的新特性可重复注解 在MyAnnotation(自定义的注解)上声明@Repeatable，成员值为MyAnnotations.class MyAnnotation的Target和Retention等元注解与MyAnnotations相同。 类型注解 ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明）。 ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"枚举类","date":"2021-04-26T12:20:46.000Z","path":"2021/04/26/枚举类/","text":"枚举类的使用 枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类。 当需要定义一组常量时，强烈建议使用枚举类。 如果枚举类中只有一个对象，则可以作为单例模式的实现方式。 枚举类的定义方式一：jdk5.0之前，自定义枚举类1234567891011121314151617181920212223242526272829303132333435363738394041424344public class SeasonTest &#123; public static void main(String[] args) &#123; Season spring = Season.SPRING; System.out.println(spring); &#125;&#125;//自定义枚举类class Season&#123; //1.声明Season对象的属性:private final修饰 private final String seasonName; private final String seasonDesc; //2.私有化类的构造器,并给对象属性赋值 private Season(String seasonName,String seasonDesc)&#123; this.seasonName = seasonName; this.seasonDesc = seasonDesc; &#125; //3.提供当前枚举类的多个对象：public static final的 public static final Season SPRING = new Season(&quot;春天&quot;,&quot;春暖花开&quot;); public static final Season SUMMER = new Season(&quot;夏天&quot;,&quot;夏日炎炎&quot;); public static final Season AUTUMN = new Season(&quot;秋天&quot;,&quot;秋高气爽&quot;); public static final Season WINTER = new Season(&quot;冬天&quot;,&quot;冰天雪地&quot;); //4.其他诉求1：获取枚举类对象的属性 public String getSeasonName() &#123; return seasonName; &#125; public String getSeasonDesc() &#123; return seasonDesc; &#125; //4.其他诉求2：提供toString() @Override public String toString() &#123; return &quot;Season&#123;&quot; + &quot;seasonName=&#x27;&quot; + seasonName + &#x27;\\&#x27;&#x27; + &quot;, seasonDesc=&#x27;&quot; + seasonDesc + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 方式二：jdk5.0，可以使用enum关键字定义枚举类说明 定义的枚举类默认继承于java.lang.Enum类。 123456789101112131415161718enum SeasonEnum &#123; SPRING(&quot;春天&quot;,&quot;春风又绿江南岸&quot;), SUMMER(&quot;夏天&quot;,&quot;映日荷花别样红&quot;), AUTUMN(&quot;秋天&quot;,&quot;秋水共长天一色&quot;), WINTER(&quot;冬天&quot;,&quot;窗含西岭千秋雪&quot;); private final String seasonName; private final String seasonDesc; private SeasonEnum(String seasonName, String seasonDesc) &#123; this.seasonName = seasonName; this.seasonDesc = seasonDesc; &#125; public String getSeasonName() &#123; return seasonName; &#125; public String getSeasonDesc() &#123; return seasonDesc; &#125;&#125; Enum类的主要方法 values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。 valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。 toString()：返回当前枚举类对象常量的名称。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class Demo &#123; public static void main(String[] args) &#123; Season summer = Season.SUMMER; //toString():返回枚举类对象的名称 System.out.println(summer.toString()); System.out.println(&quot;****************&quot;); //values():返回所有的枚举类对象构成的数组 Season[] values = Season.values(); for(int i = 0;i &lt; values.length;i++)&#123; System.out.println(values[i]); &#125; System.out.println(&quot;****************&quot;); //valueOf(String objName):返回枚举类中对象名是objName的对象。 Season winter = Season1.valueOf(&quot;WINTER&quot;); //如果没有objName的枚举类对象，则抛异常：IllegalArgumentException// Season winter = Season1.valueOf(&quot;WINTER1&quot;); System.out.println(winter); &#125;&#125;//使用enum关键字枚举类enum Season &#123; //1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束 SPRING(&quot;春天&quot;,&quot;春暖花开&quot;), SUMMER(&quot;夏天&quot;,&quot;夏日炎炎&quot;), AUTUMN(&quot;秋天&quot;,&quot;秋高气爽&quot;), WINTER(&quot;冬天&quot;,&quot;冰天雪地&quot;); //2.声明Season对象的属性:private final修饰 private final String seasonName; private final String seasonDesc; //2.私有化类的构造器,并给对象属性赋值 private Season(String seasonName,String seasonDesc)&#123; this.seasonName = seasonName; this.seasonDesc = seasonDesc; &#125; //4.其他诉求1：获取枚举类对象的属性 public String getSeasonName() &#123; return seasonName; &#125; public String getSeasonDesc() &#123; return seasonDesc; &#125; //4.其他诉求1：提供toString() @Override public String toString() &#123; return &quot;Season&#123;&quot; + &quot;seasonName=&#x27;&quot; + seasonName + &#x27;\\&#x27;&#x27; + &quot;, seasonDesc=&#x27;&quot; + seasonDesc + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125;/*Season&#123;seasonName=&#x27;夏天&#x27;, seasonDesc=&#x27;夏日炎炎&#x27;&#125;****************Season&#123;seasonName=&#x27;春天&#x27;, seasonDesc=&#x27;春暖花开&#x27;&#125;Season&#123;seasonName=&#x27;夏天&#x27;, seasonDesc=&#x27;夏日炎炎&#x27;&#125;Season&#123;seasonName=&#x27;秋天&#x27;, seasonDesc=&#x27;秋高气爽&#x27;&#125;Season&#123;seasonName=&#x27;冬天&#x27;, seasonDesc=&#x27;冰天雪地&#x27;&#125;****************Season&#123;seasonName=&#x27;冬天&#x27;, seasonDesc=&#x27;冰天雪地&#x27;&#125;*/ 实现接口的枚举类 情况一：实现接口，在enum类中实现抽象方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Demo &#123; public static void main(String[] args) &#123; Season1 winter = Season1.valueOf(&quot;WINTER&quot;); System.out.println(winter); winter.show(); &#125;&#125;interface Info&#123; void show();&#125;//使用enum关键字枚举类enum Season1 implements Info&#123; //1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束 SPRING(&quot;春天&quot;,&quot;春暖花开&quot;), SUMMER(&quot;夏天&quot;,&quot;夏日炎炎&quot;), AUTUMN(&quot;秋天&quot;,&quot;秋高气爽&quot;), WINTER(&quot;冬天&quot;,&quot;冰天雪地&quot;); //2.声明Season对象的属性:private final修饰 private final String seasonName; private final String seasonDesc; //2.私有化类的构造器,并给对象属性赋值 private Season1(String seasonName,String seasonDesc)&#123; this.seasonName = seasonName; this.seasonDesc = seasonDesc; &#125; //4.其他诉求1：获取枚举类对象的属性 public String getSeasonName() &#123; return seasonName; &#125; public String getSeasonDesc() &#123; return seasonDesc; &#125; //重写接口中的方法 @Override public void show() &#123; System.out.println(&quot;这是一个季节&quot;); &#125;&#125; 情况二：让枚举类的对象分别实现接口中的抽象方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class Demo &#123; public static void main(String[] args) &#123; Season1[] values = Season1.values(); for(int i = 0;i &lt; values.length;i++)&#123; System.out.println(values[i]); values[i].show(); &#125; &#125;&#125;interface Info&#123; void show();&#125;//使用enum关键字枚举类enum Season1 implements Info&#123; //1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束 SPRING(&quot;春天&quot;,&quot;春暖花开&quot;)&#123; @Override public void show() &#123; System.out.println(&quot;春天在哪里？&quot;); &#125; &#125;, SUMMER(&quot;夏天&quot;,&quot;夏日炎炎&quot;)&#123; @Override public void show() &#123; System.out.println(&quot;宁夏&quot;); &#125; &#125;, AUTUMN(&quot;秋天&quot;,&quot;秋高气爽&quot;)&#123; @Override public void show() &#123; System.out.println(&quot;秋天不回来&quot;); &#125; &#125;, WINTER(&quot;冬天&quot;,&quot;冰天雪地&quot;)&#123; @Override public void show() &#123; System.out.println(&quot;大约在冬季&quot;); &#125; &#125;; //2.声明Season对象的属性:private final修饰 private final String seasonName; private final String seasonDesc; //2.私有化类的构造器,并给对象属性赋值 private Season1(String seasonName,String seasonDesc)&#123; this.seasonName = seasonName; this.seasonDesc = seasonDesc; &#125; //4.其他诉求1：获取枚举类对象的属性 public String getSeasonName() &#123; return seasonName; &#125; public String getSeasonDesc() &#123; return seasonDesc; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java常用类","date":"2021-04-21T07:47:54.000Z","path":"2021/04/21/Java常用类/","text":"字符串相关的类 String类及常用方法String的使用String：字符串，使用一对“ ”引起来表示。 String声明为final的，不可被继承。 String实现了Serializable接口：表示字符串是支持序列化的。 ​ 实现了Comparable接口：表示String可以比较大小。 String内部定义了final char[] value用于存储字符串数据。 String：代表不可变的字符序列。简称：不可变性。 体现： 当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。 字符串常量池中不会存储相同内容的字符串的。 String的实例化方式 方式一：通过字面量定义的方式 此时的数据声明在方法区的字符串常量池中。 方式二：通过new + 构造器的方式 此时的数据保存的地址值，是数据在堆空间中开辟空间以后对应的地址值。 123456789101112131415161718192021222324252627public void test()&#123; //通过字面量定义的方式：此时的s1和s2的数据javaEE声明在方法区中的字符串常量池中。 String s1 = &quot;javaEE&quot;; String s2 = &quot;javaEE&quot;; //通过new + 构造器的方式:此时的s3和s4保存的地址值，是数据在堆空间中开辟空间以后对应的地址值。 String s3 = new String(&quot;javaEE&quot;); String s4 = new String(&quot;javaEE&quot;); System.out.println(s1 == s2);//true System.out.println(s1 == s3);//false System.out.println(s1 == s4);//false System.out.println(s3 == s4);//false System.out.println(&quot;**********下面的要特别注意！！！*************&quot;); // Person类下面有定义 Person p1 = new Person(&quot;Tom&quot;,12); Person p2 = new Person(&quot;Tom&quot;,12); System.out.println(p1.name.equals(p2.name));//true // 此时p1和p2的name存储的地址值都是一样的，都是指向方法区里面的Tom System.out.println(p1.name == p2.name);//true // 如果p1.name发生修改，那么方法区会新生成一个，存储Jerry。之后p1.name存储Jerry方法区的地址，p2.name不变。 p1.name = &quot;Jerry&quot;; System.out.println(p2.name);//Tom&#125; 1234567891011121314// Person类如下：public class Person &#123; String name; int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public Person() &#123; &#125;&#125; 结论 常量与常量的拼接结果在常量池，且常量池中不会存在相同内容的常量。 只要其中一个是变量，结果就在堆中。 如果拼接的结果调用intern()方法，返回值就在常量池中。 123456789101112131415161718192021222324public void test3()&#123; String s1 = &quot;javaEE&quot;; String s2 = &quot;hadoop&quot;; String s3 = &quot;javaEEhadoop&quot;; String s4 = &quot;javaEE&quot; + &quot;hadoop&quot;; String s5 = s1 + &quot;hadoop&quot;; String s6 = &quot;javaEE&quot; + s2; String s7 = s1 + s2; // 结论1 System.out.println(s3 == s4);//true // 结论2 System.out.println(s3 == s5);//false System.out.println(s3 == s6);//false System.out.println(s3 == s7);//false System.out.println(s5 == s6);//false System.out.println(s5 == s7);//false System.out.println(s6 == s7);//false // 结论3 // 调用intern()的时候，返回值一定是在常量池当中 String s8 = s6.intern();//返回值得到的s8使用的常量值中已经存在的“javaEEhadoop” System.out.println(s3 == s8);//true&#125; 常用方法1234567891011121314151617181920212223242526272829303132int length()：返回字符串的长度： return value.lengthchar charAt(int index)： 返回某索引处的字符return value[index]boolean isEmpty()：判断是否是空字符串：return value.length == 0String toLowerCase()：使用默认语言环境，将 String 中的所有字符转换为小写String toUpperCase()：使用默认语言环境，将 String 中的所有字符转换为大写String trim()：返回字符串的副本，忽略前导空白和尾部空白boolean equals(Object obj)：比较字符串的内容是否相同boolean equalsIgnoreCase(String anotherString)：与equals方法类似，忽略大小写String concat(String str)：将指定字符串连接到此字符串的结尾。 等价于用“+”int compareTo(String anotherString)：比较两个字符串的大小String substring(int beginIndex)：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。String substring(int beginIndex, int endIndex) ：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。 boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始boolean contains(CharSequence s)：当且仅当此字符串包含指定的 char 值序列时，返回 trueint indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始int lastIndexOf(String str)：返回指定子字符串在此字符串中最右边出现处的索引int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索 替换：String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。String replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。String replaceAll(String regex, String replacement)：使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。String replaceFirst(String regex, String replacement)：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。匹配:boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式。切片：String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。 String与基本数据类型、包装类之间的转换 String –&gt; 基本数据类型、包装类：调用包装类的静态方法：Xxx.parseXxx(str)。 基本数据类型、包装类 –&gt; String：调用String重载的valueOf(xxx) 1234567891011121314public class Demo&#123; public static void main(String[] args)&#123; String s = &quot;1234&quot;; float num = Flaot.parseInt(s);//将字符串转换为float型 System.out.println(num); String s2 = String.valueOf(num);//将float型转换为字符串 &#125;&#125;//======================//1234.0////1234.0//====================== String与字符数组char[]转换 String –&gt; char[]:调用String的toCharArray() char[] –&gt; String:调用String的构造器 1234567891011121314public class Demo&#123; public static void main(String[] args)&#123; String s1 = &quot;Hello World&quot;; char[] char1 = s1.toCharArray(); for (int i = 0; i &lt; char1.length; i++) &#123; System.out.print(char1[i]); &#125; System.out.println(&quot;===================&quot;); String s2 = new String(char1); System.out.println(s2); &#125;&#125; String与字节数组byte[]转换 编码（字符串 –&gt;字节 (看得懂 —&gt;看不懂的二进制数据)）：String –&gt; byte[]:调用String的getBytes() 解码（编码的逆过程，字节 –&gt; 字符串 （看不懂的二进制数据 —&gt; 看得懂））：byte[] –&gt; String:调用String的构造器 注意：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。 123456789101112131415161718192021222324252627282930313233343536import java.io.UnsupportedEncodingException;import java.util.Arrays;public class Demo &#123; public static void main(String[] args) &#123; String str1 = &quot;abc123中国&quot;; byte[] bytes = str1.getBytes();//使用默认的字符集，进行编码。 System.out.println(Arrays.toString(bytes)); byte[] gbks = new byte[0];//使用gbk字符集进行编码。 try &#123; gbks = str1.getBytes(&quot;gbk&quot;); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; System.out.println(Arrays.toString(gbks)); System.out.println(&quot;******************&quot;); String str2 = new String(bytes);//使用默认的字符集，进行解码。 System.out.println(str2); String str3 = new String(gbks); System.out.println(str3);//出现乱码。原因：编码集和解码集不一致！ String str4 = null; try &#123; str4 = new String(gbks, &quot;gbk&quot;); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; System.out.println(str4);//没有出现乱码。原因：编码集和解码集一致！ &#125;&#125; 面试题String s = new String(“abc”);方式创建对象，在内存中创建了几个对象？ 答：两个：一个是堆空间中new结构，另一个是char[] 对应的常量池中的数据：”abc”。 StringBuffer、StringBuilderString、StringBuffer、StringBuilder三者的异同？ String: 不可变的字符序列； 底层使用char[]存储 StringBuffer: 可变的字符序列； 线程安全的，效率低； 底层使用char[]存储 StringBuilder: 可变的字符序列； jdk5.0新增的，线程不安全的，效率高； 底层使用char[]存储 源码分析12345678910111213141516171819 //空参的时候，顶层长度为0String str = new String();//char[] value = new char[0]; //此时顶层长度为3String str1 = new String(&quot;abc&quot;);//char[] value = new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;; //底层创建了一个长度是16的数组。StringBuffer sb1 = new StringBuffer();//char[] value = new char[16];System.out.println(sb1.length());//0; 底层虽然创建了一个长度为16的数组，但是事实上此时长度依然为0sb1.append(&#x27;a&#x27;);//value[0] = &#x27;a&#x27;;sb1.append(&#x27;b&#x27;);//value[1] = &#x27;b&#x27;;//此时除了abc长度为3外，额外又添加了16长度StringBuffer sb2 = new StringBuffer(&quot;abc&quot;);//char[] value = new char[&quot;abc&quot;.length() + 16];System.out.println(sb2.length());//3; 此时实际长度为3//扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。//默认情况下，扩容为原来容量的2倍 + 2，同时将原有数组中的元素复制到新的数组中。//指导意义：开发中建议大家使用：StringBuffer(int capacity) 或 StringBuilder(int capacity) StringBuffer、StringBuilder的常用方法1234567891011121314151617181920212223//这里用StringBuffer为例，StringBuilder一样。StringBuffer append(xxx)：提供了很多的append()方法，用于进行字符串拼接StringBuffer delete(int start,int end)：删除指定位置的内容，左闭右开[start,end)。StringBuffer replace(int start, int end, String str)：把[start,end)位置替换为str。StringBuffer insert(int offset, xxx)：在指定位置插入xxxStringBuffer reverse() ：把当前字符序列逆转public int indexOf(String str)：和String一样public String substring(int start,int end):返回一个从start开始到end索引结束的左闭右开区间的子字符串public int length()public char charAt(int n )：和String一样public void setCharAt(int n ,char ch)：将n处的字符改成ch。 /* 总结：增：append(xxx)删：delete(int start,int end)改：setCharAt(int n ,char ch) / replace(int start, int end, String str)查：charAt(int n )插：insert(int offset, xxx)长度：length();遍历：for() + charAt() / toString()*/ String、StringBuffer、StringBuilder三者的效率 从高到低排列：StringBuilder &gt; StringBuffer &gt; String 1234567891011121314151617181920212223242526272829303132//测试代码@Testpublic void test3()&#123; //初始设置 long startTime = 0L; long endTime = 0L; String text = &quot;&quot;; StringBuffer buffer = new StringBuffer(&quot;&quot;); StringBuilder builder = new StringBuilder(&quot;&quot;); //开始对比 startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 20000; i++) &#123; buffer.append(String.valueOf(i)); &#125; endTime = System.currentTimeMillis(); System.out.println(&quot;StringBuffer的执行时间：&quot; + (endTime - startTime)); startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 20000; i++) &#123; builder.append(String.valueOf(i)); &#125; endTime = System.currentTimeMillis(); System.out.println(&quot;StringBuilder的执行时间：&quot; + (endTime - startTime)); startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 20000; i++) &#123; text = text + i; &#125; endTime = System.currentTimeMillis(); System.out.println(&quot;String的执行时间：&quot; + (endTime - startTime));&#125; JDk8之前的日期时间APISystem静态方法12345678910System类中的currentTimeMillis()public class Demo01 &#123; public static void main(String[] args) &#123; long time = System.currentTimeMillis(); //返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。 //称为时间戳 System.out.println(time); &#125;&#125; Date类java.util.Date两个构造器的使用 构造器一：Date()：创建一个对应当前时间的Date对象 构造器二：创建指定毫秒数的Date对象 12345678910111213141516import java.util.Date;public class Demo&#123; public static void main(String[] args)&#123; //构造器一：Date()：创建一个对应当前时间的Date对象 Date date1 = new Date(); System.out.println(date1.toString());//Sat Apr 24 11:00:02 CST 2021 System.out.println(date1.getTime());//1619233202553（时间戳） //构造器二：创建指定毫秒数的Date对象 Date date2 = new Date(1619233202553L); System.out.println(date2.toString());//Sat Apr 24 11:00:02 CST 2021 &#125;&#125; 两个方法的使用 toString():显示当前的年、月、日、时、分、秒 getTime():获取当前Date对象对应的毫秒数。（时间戳） java.sql.Date123456789import java.sql.Date;public class Demo01 &#123; public static void main(String[] args) &#123; Date date = new Date(1619233202553L); System.out.println(date);//2021-04-24 &#125;&#125; java.util.Date对象转换为java.sql.Date对象 情况一 123Date date1 = new java.sql.Date(1619233202553L);//强制转换java.sql.Date date2 = (java.sql.Date) date1; 情况二 12Date date1 = new Date();java.sql.Date date2 = new java.sql.Date(date1.getTime());//将date1中的数拿过来用作参数 Calender类实例化以及常用方法 方式一：创建其子类（GregorianCalendar）的对象 方式二：调用其静态方法getInstance() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.text.ParseException;import java.util.Calendar;import java.util.Date;public class Demo &#123; public static void main(String[] args) throws ParseException &#123; //1. 实例化 //方式一：创建其子类（GregorianCalendar）的对象 //方式二：调用其静态方法getInstance() Calendar calendar = Calendar.getInstance(); //2. 常用方法 //get() int day = calendar.get(Calendar.DAY_OF_MONTH);//当前是这个月的第几天 System.out.println(&quot;今天是这个月的第&quot;+day+&quot;天&quot;); int year_day = calendar.get(Calendar.DAY_OF_YEAR);//当前是这一年的第几天 System.out.println(&quot;今天是这一年的第&quot;+calendar.get(Calendar.DAY_OF_YEAR)+&quot;天&quot;); //set() calendar.set(Calendar.DAY_OF_MONTH,15);//没有返回值，将calender这个对象本身改了 day = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(&quot;修改完后为这个月的第&quot;+day+&quot;天&quot;); //add() calendar.add(Calendar.DAY_OF_MONTH,3);//在现有的天数上面加amount天，之前为15，加3后为18 day = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(&quot;加3天后此时为这个月的第&quot;+day+&quot;天&quot;); //getTime():日历类---&gt; Date Date date = calendar.getTime(); System.out.println(date);//修改后的数据，此时为18号 //setTime():Date---&gt; 日历类 Date date1 = new Date(); calendar.setTime(date1);//将当前日期传递给calender day = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(day);//此时输出当前为这个月的第几天 &#125;&#125;/*今天是这个月的第25天今天是这一年的第115天修改完后为这个月的第15天加3天后此时为这个月的第18天Sun Apr 18 19:31:12 CST 202125*/ 注意事项 获取月份时：一月是0，二月是1，三月是2，…以此类推，十二月是11。 获取星期时：周日是1，周一是2，…，周六是7。 SimpleDateFormat类SimpleDateForma的使用 SimpleDateFormat对日期Date类的格式化和解析 两个操作 格式化：日期 —&gt;字符串 格式化的逆过程，字符串 —&gt; 日期 实例化123456789101112131415161718192021222324252627282930313233343536import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class Demo &#123; public static void main(String[] args) throws ParseException &#123; //实例化SimpleDateFormat:使用默认的构造器 SimpleDateFormat s1 = new SimpleDateFormat(); //格式化：日期 ---&gt;字符串 Date date = new Date(); String format = s1.format(date); System.out.println(format); //System.out.println(date); //解析：格式化的逆过程，字符串 ---&gt; 日期 String str = &quot;2021/4/25 下午6:31&quot;;//格式必须正确 Date parse = s1.parse(str);//解析会抛异常 System.out.println(parse); //*************按照指定的方式格式化和解析：调用带参的构造器***************** System.out.println(&quot;***************按照指定的方式格式化和解析：调用带参的构造器**************&quot;); SimpleDateFormat s2 = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);//年-月-日 时-分-秒 //格式化 String format1 = s2.format(date); System.out.println(format1); //解析 Date parse1 = s2.parse(format1);//将format1进行解析 System.out.println(parse1); System.out.println(&quot;************************&quot;); //解析:要求字符串必须是符合SimpleDateFormat识别的格式(通过构造器参数体现), //否则，抛异常 Date parse2 = s2.parse(&quot;2008-02-13 14:20:25&quot;);//自定义时间进行解析 System.out.println(parse2); &#125;&#125; 练习 字符串”2020-09-08”转换为java.sql.Date 12345678910111213141516import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class Demo &#123; public static void main(String[] args) throws ParseException &#123; String birth = &quot;2020-09-08&quot;; SimpleDateFormat s1 = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date date = s1.parse(birth); java.sql.Date birthDate = new java.sql.Date(date.getTime());//之前学过 System.out.println(birthDate); &#125;&#125; “三天打渔两天晒网” 1990-01-01 xxxx-xx-xx 打渔？晒网？ 1234567/*总天数 % 5 == 1,2,3 : 打渔 总天数 % 5 == 4,0 : 晒网 总天数的计算？ 方式一：( date2.getTime() - date1.getTime()) / (1000 * 60 * 60 * 24) + 1//这里好像不用考虑整除，因为此时好像一定除得尽。+1是为啥？ 方式二：1990-01-01 --&gt; 2019-12-31 + 2020-01-01 --&gt;2020-09-08//年+日*/ JDK8中新日期时间API背景 JDK1.0中包含了一个java.util.Date类，但是它的大多数方法已经在JDK1.1引入Calender类之后被舍弃了。而Calender并不比Date好多少。它们面临的问题是： 可变性：像日期和时间这样的类应该是不可变的。 偏移性：Date中的年份是从1900开始的，而月份都从0开始。 格式化：格式化只对Date有效，Calender则不行。 此外，它们也不是线程安全的；不能处理闰秒等。 123//偏移量Date date = new Date(2020 - 1900,9 - 1,8);//需要将偏移量减去System.out.println(date);//Tue Sep 08 00:00:00 GMT+08:00 2020 LocalDate、LocalTime、LocalDateTime LocaDate代表IOS格式（yyyy-MM-dd）的日期，可以存储生日、纪念日等日期。 LocalTime表示一个时间，而不是日期 LocalDateTime是用来表示日期和时间的，这是一个最常用的类之一。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;public class Demo &#123; public static void main(String[] args) &#123; /* LocalDate、LocalTime、LocalDateTime 的使用 说明： 1.LocalDateTime相较于LocalDate、LocalTime，使用频率要高 2.类似于Calendar */ //now():获取当前的日期、时间、日期+时间 LocalDate localDate = LocalDate.now();//获取当前的一个日期 LocalTime localTime = LocalTime.now();//获取当前的一个时间 LocalDateTime localDateTime = LocalDateTime.now();//获取当前的日期和时间 System.out.println(localDate);//2021-04-25 System.out.println(localTime);//20:01:39.028804800 System.out.println(localDateTime);//2021-04-25T20:01:39.028804800 //of():设置指定的年、月、日、时、分、秒。没有偏移量 LocalDateTime localDateTime1 = LocalDateTime.of(2021, 12, 13, 5, 12, 51); System.out.println(localDateTime1);//2021-12-13T05:12:51 //getXxx()：获取相关的属性 System.out.println(localDateTime.getDayOfMonth());//这个月的第几天，25 System.out.println(localDateTime.getDayOfWeek());//这一周的第几天，SUNDAY System.out.println(localDateTime.getMonth());//这个月，APRIL System.out.println(localDateTime.getMonthValue());//显示月数，4 System.out.println(localDateTime.getMinute());//分钟,9 //体现不可变性 //withXxx():设置相关的属性 LocalDate localDate1 = localDate.withDayOfMonth(22);//有返回值 System.out.println(localDate);//2021-04-25 System.out.println(localDate1);//2021-04-22 LocalDateTime localDateTime2 = localDateTime.withHour(4); System.out.println(localDateTime);//2021-04-25T20:14:08.642735500 System.out.println(localDateTime2);//2021-04-25T04:14:08.642735500，改成4点了 System.out.println(&quot;**********************&quot;); //不可变性 LocalDateTime localDateTime3 = localDateTime.plusMonths(3); System.out.println(localDateTime);//2021-04-25T20:15:43.408037800 System.out.println(localDateTime3);//2021-07-25T20:15:43.408037800 System.out.println(&quot;**********************&quot;); LocalDateTime localDateTime4 = localDateTime.minusDays(6); System.out.println(localDateTime);//2021-04-25T20:15:43.408037800 System.out.println(localDateTime4);//2021-04-19T20:15:43.408037800 &#125;&#125; Instant 类似于java.util.Date类 1234567891011121314151617181920212223242526import java.time.Instant;import java.time.OffsetDateTime;import java.time.ZoneOffset;public class Demo &#123; public static void main(String[] args) &#123; //now():获取本初子午线对应的标准时间 Instant instant = Instant.now(); System.out.println(instant);//2021-04-25T12:26:02.622597100Z,和北京时间来看，慢了8个小时，是本初子午线的时间。 // //添加时间的偏移量 OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(8)); System.out.println(offsetDateTime);//2021-04-25T20:26:02.622597100+08:00 //toEpochMilli():获取自1970年1月1日0时0分0秒（UTC）开始的毫秒数 ---&gt; Date类的getTime() long toEpochMilli = instant.toEpochMilli(); System.out.println(toEpochMilli);//1619353731188 //ofEpochMilli():通过给定的毫秒数，获取Instant实例 --&gt;Date(long millis) Instant instant1 = Instant.ofEpochMilli(1619353731188L); System.out.println(instant1);//2021-04-25T12:28:51.188Z &#125;&#125; DateTimeFormatter DateTimeFormatter:格式化或解析日期、时间类似于SimpleDateFormat 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.time.LocalDate;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;import java.time.format.FormatStyle;import java.time.temporal.TemporalAccessor;public class Demo &#123; public static void main(String[] args) &#123; //方式一：预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME; //格式化:日期--&gt;字符串 LocalDateTime localDateTime = LocalDateTime.now(); String str1 = formatter.format(localDateTime); System.out.println(localDateTime);//2021-04-25T20:37:38.048992200 System.out.println(str1);//2021-04-25T20:37:38.0489922 //解析：字符串 --&gt;日期 TemporalAccessor parse = formatter.parse(&quot;2021-04-25T20:37:38.0489922&quot;); System.out.println(parse);//&#123;&#125;,ISO resolved to 2021-04-25T20:37:38.048992200 //方式二： //本地化相关的格式。如：ofLocalizedDateTime() //这三个只是格式上面不太一样：FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT :适用于LocalDateTime DateTimeFormatter formatter1 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT); //格式化 String str2 = formatter1.format(localDateTime); System.out.println(str2);//2021/4/25 下午8:43 //本地化相关的格式。如：ofLocalizedDate() //FormatStyle.FULL / FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT : 适用于LocalDate DateTimeFormatter formatter2 = DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM); //格式化 String str3 = formatter2.format(LocalDate.now()); System.out.println(str3);//2021年4月25日 //重点： 方式三：自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”) DateTimeFormatter formatter3 = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd hh:mm:ss&quot;); //格式化 String str4 = formatter3.format(LocalDateTime.now()); System.out.println(str4);//2021-04-25 08:50:49 //解析 TemporalAccessor accessor = formatter3.parse(&quot;2021-04-25 08:50:49&quot;); System.out.println(accessor);//&#123;HourOfAmPm=8, MicroOfSecond=0, SecondOfMinute=49, MilliOfSecond=0, NanoOfSecond=0, MinuteOfHour=50&#125;,ISO resolved to 2021-04-25 &#125;&#125; 其他类 Zoneld：该类中包含了所有的时区信息，一个时区的ID，如Europe/Paris。 ZonedDate Time：一个在ISO-8601日历系统时区的日期时间 Clock：使用时区提供对当前即时、日期和时间的访问的时钟。 Duration：用于计算两个“时间”间隔。 Period：用于计算两个“日期”间隔。 TemporalAdjuster：时间矫正器。 TemporalAdjusters：该类通过静态方法（firstDayOfXxx()/lastDayOfXxx()/nextXxx()）提供了大量常用TemporalAdjuster的实现。 等等 Java比较器说明 Java中的对象，正常情况下，只能进行比较：== 或 != 。不能使用 &gt; 或 &lt; 的但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。如何实现？使用两个接口中的任何一个：Comparable 或 Comparator Comparable接口使用举例：自然排序 像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式。 像String、包装类重写compareTo()方法以后，进行了从小到大的排列 重写compareTo(obj)的规则： 如果当前对象this大于形参对象obj，则返回正整数 如果当前对象this小于形参对象obj，则返回负整数 如果当前对象this等于形参对象obj，则返回零 12345String[] arr = new String[]&#123;&quot;AA&quot;,&quot;CC&quot;,&quot;KK&quot;,&quot;MM&quot;,&quot;GG&quot;,&quot;JJ&quot;,&quot;DD&quot;&#125;;Arrays.sort(arr);System.out.println(Arrays.toString(arr)); 对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * 商品类 * @author shkstart * @create 2019 下午 4:52 */public class Goods implements Comparable&#123; private String name; private double price; public Goods() &#123; &#125; public Goods(String name, double price) &#123; this.name = name; this.price = price; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; @Override public String toString() &#123; return &quot;Goods&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, price=&quot; + price + &#x27;&#125;&#x27;; &#125; //指明商品比较大小的方式:按照价格从低到高排序,再按照产品名称从高到低排序 @Override public int compareTo(Object o) &#123;// System.out.println(&quot;**************&quot;); if(o instanceof Goods)&#123; Goods goods = (Goods)o; //方式一： if(this.price &gt; goods.price)&#123; return 1; &#125;else if(this.price &lt; goods.price)&#123; return -1; &#125;else&#123;// return 0; return -this.name.compareTo(goods.name);//-指按照产品名称从高到低排序 &#125; //方式二：// return Double.compare(this.price,goods.price); &#125;// return 0; throw new RuntimeException(&quot;传入的数据类型不一致！&quot;); &#125;&#125;//这里没写全，只是一个@Test@Testpublic void test2()&#123; Goods[] arr = new Goods[5]; arr[0] = new Goods(&quot;lenovoMouse&quot;,34); arr[1] = new Goods(&quot;dellMouse&quot;,43); arr[2] = new Goods(&quot;xiaomiMouse&quot;,12); arr[3] = new Goods(&quot;huaweiMouse&quot;,65); arr[4] = new Goods(&quot;microsoftMouse&quot;,43); Arrays.sort(arr); System.out.println(Arrays.toString(arr));&#125; Comparator接口使用举例：定制排序 背景：当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序。 重写compare(Object o1,Object o2)方法，比较o1和o2的大小： 如果方法返回正整数，则表示o1大于o2； 如果返回0，表示相等； 返回负整数，表示o1小于o2。 12345678910111213141516171819@Test public void test()&#123; String[] arr = new String[]&#123;&quot;AA&quot;,&quot;CC&quot;,&quot;KK&quot;,&quot;MM&quot;,&quot;GG&quot;,&quot;JJ&quot;,&quot;DD&quot;&#125;; Arrays.sort(arr,new Comparator()&#123; //按照字符串从大到小的顺序排列 @Override public int compare(Object o1, Object o2) &#123; if(o1 instanceof String &amp;&amp; o2 instanceof String)&#123; String s1 = (String) o1; String s2 = (String) o2; return -s1.compareTo(s2);//从大到小排 &#125;// return 0; throw new RuntimeException(&quot;输入的数据类型不一致&quot;); &#125; &#125;); System.out.println(Arrays.toString(arr)); &#125; 定制 1234567891011121314151617181920212223242526272829@Testpublic void test()&#123; Goods[] arr = new Goods[6]; arr[0] = new Goods(&quot;lenovoMouse&quot;,34); arr[1] = new Goods(&quot;dellMouse&quot;,43); arr[2] = new Goods(&quot;xiaomiMouse&quot;,12); arr[3] = new Goods(&quot;huaweiMouse&quot;,65); arr[4] = new Goods(&quot;huaweiMouse&quot;,224); arr[5] = new Goods(&quot;microsoftMouse&quot;,43); Arrays.sort(arr, new Comparator() &#123; //指明商品比较大小的方式:按照产品名称从低到高排序,再按照价格从高到低排序 @Override public int compare(Object o1, Object o2) &#123; if(o1 instanceof Goods &amp;&amp; o2 instanceof Goods)&#123; Goods g1 = (Goods)o1; Goods g2 = (Goods)o2; if(g1.getName().equals(g2.getName()))&#123; return -Double.compare(g1.getPrice(),g2.getPrice());//名字一样时候，按照价格排 &#125;else&#123; return g1.getName().compareTo(g2.getName()); &#125; &#125; throw new RuntimeException(&quot;输入的数据类型不一致&quot;); &#125; &#125;); System.out.println(Arrays.toString(arr));&#125; Comparable接口与Comparator的使用的对比 Comparable接口的方式一旦指定，保证Comparable接口实现类的对象在任何位置都可以比较大小。Comparator接口属于临时性的比较。 System类说明 System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。 由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。 成员变量 System类内部包含in、out和err三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。 成员方法 native long currentTimeMillis()：该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。 void exit(int status)：该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。 void gc()：该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。 String getProperty(String key)：该方法的作用是获得系统中属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示： 属性名 属性说明 java.version Java运行时环境版本 java.home Java安装目录 os.name 操作系统的名称 os.version 操作系统的版本 user.name 用户的账户名称 user.home 用户的主目录 user.dir 用户的当前工作目录 123456789101112131415161718192021222324@Testpublic void test() &#123; String javaVersion = System.getProperty(&quot;java.version&quot;); System.out.println(&quot;java的version:&quot; + javaVersion); String javaHome = System.getProperty(&quot;java.home&quot;); System.out.println(&quot;java的home:&quot; + javaHome); String osName = System.getProperty(&quot;os.name&quot;); System.out.println(&quot;os的name:&quot; + osName); String osVersion = System.getProperty(&quot;os.version&quot;); System.out.println(&quot;os的version:&quot; + osVersion); String userName = System.getProperty(&quot;user.name&quot;); System.out.println(&quot;user的name:&quot; + userName); String userHome = System.getProperty(&quot;user.home&quot;); System.out.println(&quot;user的home:&quot; + userHome); String userDir = System.getProperty(&quot;user.dir&quot;); System.out.println(&quot;user的dir:&quot; + userDir);&#125; Math类说明 java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型。 方法123456789101112abs 绝对值acos,asin,atan,cos,sin,tan 三角函数sqrt 平方根pow(double a,doble b) a的b次幂log 自然对数exp e为底指数max(double a,double b)min(double a,double b)random() 返回0.0到1.0的随机数long round(double a) double型数据a转换为long型（四舍五入）toDegrees(double angrad) 弧度—&gt;角度toRadians(double angdeg) 角度—&gt;弧度 BigInteger与BigDecimalBigInteger类说明 java.math包的BigInteger可以表示不可变的任意精度的整数。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。 构造器 BigInteger(String val)：根据字符串构建BigInteger对象 常用方法12345678public BigInteger abs()：返回此 BigInteger 的绝对值的 BigInteger。BigInteger add(BigInteger val) ：返回其值为 (this + val) 的 BigIntegerBigInteger subtract(BigInteger val) ：返回其值为 (this - val) 的 BigIntegerBigInteger multiply(BigInteger val) ：返回其值为 (this * val) 的 BigIntegerBigInteger divide(BigInteger val) ：返回其值为 (this / val) 的 BigInteger。整数相除只保留整数部分。BigInteger remainder(BigInteger val) ：返回其值为 (this % val) 的 BigInteger。BigInteger[] divideAndRemainder(BigInteger val)：返回包含 (this / val) 后跟(this % val) 的两个 BigInteger 的数组。BigInteger pow(int exponent) ：返回其值为 (thisexponent) 的 BigInteger。 BigDecimal类说明 一般的Float类和Double类可以用来做科学计算或工程计算，但在商业计算中，要求数字精度比较高，故用到java.math.BigDecimal类。BigDecimal类支持不可变的、任意精度的有符号十进制定点数。 构造器 public BigDecimal(double val)public BigDecimal(String val) 常用方法1234public BigDecimal add(BigDecimal augend)public BigDecimal subtract(BigDecimal subtrahend)public BigDecimal multiply(BigDecimal multiplicand)public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"多线程知识总结","date":"2021-04-19T12:01:32.000Z","path":"2021/04/19/死锁/","text":"死锁问题 死锁的理解 不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。 出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续。我们使用同步时，要避免出现死锁。 演示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//演示线程的死锁问题：public class ThreadTest &#123; public static void main(String[] args) &#123; StringBuffer s1 = new StringBuffer(); StringBuffer s2 = new StringBuffer(); new Thread()&#123; @Override public void run() &#123; synchronized (s1)&#123; s1.append(&quot;a&quot;); s2.append(&quot;1&quot;); //加了sleep后出现死锁的概率会大大增加。 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (s2)&#123; s1.append(&quot;b&quot;); s2.append(&quot;2&quot;); System.out.println(s1); System.out.println(s2); &#125;s &#125; &#125; &#125;.start(); new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (s2)&#123; s1.append(&quot;c&quot;); s2.append(&quot;3&quot;); //加了sleep后出现死锁的概率会大大增加。 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (s1)&#123; s1.append(&quot;d&quot;); s2.append(&quot;4&quot;); System.out.println(s1); System.out.println(s2); &#125; &#125; &#125; &#125;).start(); &#125;&#125;此时很大概率会出现程序会出现死锁，无法继续执行的问题。 解决方法 专门的算法、原则。 尽量减少同步资源的定义。 尽量避免嵌套同步。 Lock（锁）定义 解决线程安全问题的方式三（JDK5.0新增） 演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.concurrent.locks.ReentrantLock;class Window implements Runnable&#123; private int ticket = 100; //1.实例化ReentrantLock private ReentrantLock lock = new ReentrantLock(); @Override public void run() &#123; while (true)&#123; try &#123; //2.调用锁定方法：lock() lock.lock(); if(ticket &gt; 0)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;:售票，票号为：&quot;+ticket); ticket--; &#125;else&#123; break; &#125; &#125;finally &#123; //3.调用解锁的方法：unlock(); lock.unlock(); &#125; &#125; &#125;&#125;public class LockTest &#123; public static void main(String[] args) &#123; Window w = new Window(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; synchronize 与 Lock 的对比 Lock是显式锁（手动开启和关闭锁），synchronize是隐式锁，出了作用域自动释放。 Lock只有代码块锁，synchronize有代码块锁和方法锁。 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）。 优先使用顺序 Lock –&gt; 同步代码块（已经进入了方法体，分配了相应资源） –&gt; 同步方法（在方法体之外） 如何解决线程安全问题？有几种方式 synchronize(两种)：同步代码块和同步方法。Lock锁(一种) 线程的通信（主要涉及三种方法）三种方法 wait():一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。 notify():一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。 notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。 三种方法说明 wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中。 wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器。否则，会出现IllegalMonitorStateException异常。 wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。 sleep() 和 wait()的异同？相同点： 一旦执行方法，都可以使得当前的线程进入阻塞状态。不同点： 不同点：两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait()。 调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中。 关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。 题目使用两个线程打印 1-100。线程1, 线程2 交替打印。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Number implements Runnable&#123; private int number = 1; private Object obj = new Object(); @Override public void run() &#123; while(true)&#123; synchronized (obj) &#123; obj.notify(); if(number &lt;= 100)&#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + number); number++; try &#123; //使得调用如下wait()方法的线程进入阻塞状态 obj.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;else&#123; break; &#125; &#125; &#125; &#125;&#125;public class CommunicationTest &#123; public static void main(String[] args) &#123; Number number = new Number(); Thread t1 = new Thread(number); Thread t2 = new Thread(number); t1.setName(&quot;线程1&quot;); t2.setName(&quot;线程2&quot;); t1.start(); t2.start(); &#125;&#125; JDK5.0新增线程创建方式新增方式一：实现Callable接口创建过程 创建一个实现Callable的实现类 实现call方法，将此线程需要执行的操作声明在call()中 创建Callable接口实现类的对象 将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象 将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start() 获取Callable中call方法的返回值 Runnable 与 Callable 相比与使用Runnable相比，Callable功能更强大些 相比run()方法，可以有返回值 call()方法可以抛出异常，被外面的操作捕获，获取异常的信息 Callable是支持泛型的 需要借助Future Task类，比如获取返回结果Future接口 可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。 FutrueTask是Future接口的唯一的实现类 FutureTask同时实现了Runnable、Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。 新增方式二：使用线程池背景 经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。 思路 提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。 好处 提高响应速度（减少了创建新线程的时间） 降低资源消耗（重复利用线程池中线程，不需要每次都创建） 便于线程管理 使用线程池案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.ThreadPoolExecutor;class NumberThread implements Runnable&#123; @Override public void run() &#123; for(int i = 0;i &lt;= 100;i++)&#123; if(i % 2 == 0)&#123; System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i); &#125; &#125; &#125;&#125;class NumberThread1 implements Runnable&#123; @Override public void run() &#123; for(int i = 0;i &lt;= 100;i++)&#123; if(i % 2 != 0)&#123; System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i); &#125; &#125; &#125;&#125;public class ThreadPool &#123; public static void main(String[] args) &#123; //1. 提供指定线程数量的线程池 ExecutorService service = Executors.newFixedThreadPool(10); ThreadPoolExecutor service1 = (ThreadPoolExecutor) service; //设置线程池的属性// System.out.println(service.getClass());// service1.setCorePoolSize(15);// service1.setKeepAliveTime(); //2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象 service.execute(new NumberThread());//适合适用于Runnable service.execute(new NumberThread1());//适合适用于Runnable// service.submit(Callable callable);//适合使用于Callable //3.关闭连接池 service.shutdown(); &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"MySQL知识总结","date":"2021-04-03T07:32:22.000Z","path":"2021/04/03/MySQL知识总结/","text":"什么是数据库？SQL、DB、DBMS分别是什么？123SQL：结构化查询语句，是一门标准通用的语言。 DB：DataBase，数据库，实际上在硬盘上以文件的形式存在。DBMS：DataBase Management System，数据库管理系统。 标准的SQL适用于所有的数据库产品。SQL属于高级语言。 SQL执行的过程12345SQL语句在执行的时候，先编译（编译由DBMS完成）后执行。DBMS负责执行sql语句，通过执行sql语句来操作DB当中的数据。DBMS -&gt; (执行) -&gt; SQL -&gt; (操作) -&gt;DB 表(table)什么是表？1表：table是数据库的基本组成单元，所有的数据都以表格的形式组织，目的是可续性强。 表的组成123表由行和列组成：行：称为数据/记录(data)列：称为字段(column) SQL语句分类 DQL(数据查询语言)：查询语句，凡是select语句都是SQL。DML(数据操作语言)：insert、delete、update，对表中的数据进行增删改DDL(数据定义语言)：create、drop、alter，对表结构的增删改TCL(事务(Transaction)控制语言)：commit提交事务，rollback回滚事务。DCL(数据控制语言)：grant授权，revoke撤销权限等。 MySQL的登录及简答查询登录MySQl dos命令：mysql -uroot -p密码 查看有哪些数据 show databases;注意：这不是SQL语句，而是MySQL命令 。 创建属于我们自己的数据库 create database 名字;我们这里创建firstsql,即 create database firstsql; 使用创建的数据库 use 数据库名字；注意：这也是MySQL命令。 查看当前使用的数据库中有哪些表 show tables;注意：这也是MySQL命令。 初始化数据 输入source，然后将数据表拖进来。注意：数据初始化完成之后，有三张表：dept、emp、salgrade。 1234567+--------------------+| Tables_in_firstsql |+--------------------+| dept || emp || salgrade |+--------------------+ 1234注意事项：1、SQL语言的文件被称为“SQL脚本”。2、当一个文件的扩展名是.sql，并且该文件中编写了大量的SQL语句，我们称这样的文件为SQL脚本。3、source可以执行SQL脚本，当SQL脚本中的数据太大的时候，无法直接打开，我们就可以使用source命令完成初始化。 删除数据库 drop database firstsql; 查看表结构 desc dept;desc emp;desc salgrade; 123456789101112131415161718192021222324252627282930313233343536373839404142434445mysql&gt; desc dept;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| DEPTNO | int | NO | PRI | NULL | || DNAME | varchar(14) | YES | | NULL | || LOC | varchar(13) | YES | | NULL | |+--------+-------------+------+-----+---------+-------+DEPTNO:部门编号DNAME:部门名称LOC:部门位置mysql&gt; desc emp;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| EMPNO | int | NO | PRI | NULL | || ENAME | varchar(10) | YES | | NULL | || JOB | varchar(9) | YES | | NULL | || MGR | int | YES | | NULL | || HIREDATE | date | YES | | NULL | || SAL | double(7,2) | YES | | NULL | || COMM | double(7,2) | YES | | NULL | || DEPTNO | int | YES | | NULL | |+----------+-------------+------+-----+---------+-------+EMPNO: 员工编号ENAME:员工姓名JOB:工作岗位 MGR:上级领导编号HIREDATE:入职日期SAL:月薪 COMM:补助/津贴 DEPTNO:部门编号 mysql&gt; desc salgrade;+-------+------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+------+------+-----+---------+-------+| GRADE | int | YES | | NULL | || LOSAL | int | YES | | NULL | || HISAL | int | YES | | NULL | |+-------+------+------+-----+---------+-------+GRADE:等级LOSAL:最低薪资HISAL:最高薪资 查看表中所有的数据 select * form 表名;注意在实际开发(写入Java程序时)当中不建议使用 *，因为效率比较低。 12345678910mysql&gt; select * from dept;+--------+------------+----------+| DEPTNO | DNAME | LOC |+--------+------------+----------+| 10 | ACCOUNTING | NEW YORK || 20 | RESEARCH | DALLAS || 30 | SALES | CHICAGO || 40 | OPERATIONS | BOSTON |+--------+------------+----------+这里我们只举一个dept表的例子，可以查看dept表当中的全部数据。 常用的MySQL命令查看当前使用的是哪一个数据库 select database(); 123456mysql&gt; select database();+------------+| database() |+------------+| firstsql |+------------+ 查看MySQL的版本 select version(); 123456mysql&gt; select version();+-----------+| version() |+-----------+| 8.0.23 |+-----------+ 结束一条语句 \\c 12345mysql&gt; select -&gt; * -&gt; \\cmysql&gt;输入\\c后直接结束这一条语句 退出MySQL exit 12mysql&gt; exitBye 查看建表的语句 show create table emp; 简单的查询语句(DQL)语法格式1234select 字段名1，字段名2，...from 表名; 123注意事项：1、任何一条SQL语句都以“ ; ”结尾。2、SQL语句不区分大小写。 字段可以参与数学运算题目:请输出员工的年薪 select ename, sal * 12 from emp; 123456789101112131415161718+--------+----------+| ename | sal*12 |+--------+----------+| SMITH | 9600.00 || ALLEN | 19200.00 || WARD | 15000.00 || JONES | 35700.00 || MARTIN | 15000.00 || BLAKE | 34200.00 || CLARK | 29400.00 || SCOTT | 36000.00 || KING | 60000.00 || TURNER | 18000.00 || ADAMS | 13200.00 || JAMES | 11400.00 || FORD | 36000.00 || MILLER | 15600.00 |+--------+----------+ 给查询结果的列(sal*12)重命名 select ename, sal * 12 as yearsal from, emp;将sal*12重命名为yearsalas关键字也可以省略不写select ename, sal * 12 yearsal from, emp; 1234567891011121314151617181920212223242526272829303132333435363738394041写as:mysql&gt; select ename,sal*12 as yearsal from emp;+--------+----------+| ename | yearsal |+--------+----------+| SMITH | 9600.00 || ALLEN | 19200.00 || WARD | 15000.00 || JONES | 35700.00 || MARTIN | 15000.00 || BLAKE | 34200.00 || CLARK | 29400.00 || SCOTT | 36000.00 || KING | 60000.00 || TURNER | 18000.00 || ADAMS | 13200.00 || JAMES | 11400.00 || FORD | 36000.00 || MILLER | 15600.00 |+--------+----------+不写as:mysql&gt; select ename,sal*12 yearsal from emp;+--------+----------+| ename | yearsal |+--------+----------+| SMITH | 9600.00 || ALLEN | 19200.00 || WARD | 15000.00 || JONES | 35700.00 || MARTIN | 15000.00 || BLAKE | 34200.00 || CLARK | 29400.00 || SCOTT | 36000.00 || KING | 60000.00 || TURNER | 18000.00 || ADAMS | 13200.00 || JAMES | 11400.00 || FORD | 36000.00 || MILLER | 15600.00 |+--------+----------+ 当别名当中有中文的时候，要注意： 正确写法：select ename, sal * 12 as ‘年薪’ from emp;错误写法：select ename, sal * 12 as 年薪 from emp; 123456789101112131415161718+--------+----------+| ename | 年薪 |+--------+----------+| SMITH | 9600.00 || ALLEN | 19200.00 || WARD | 15000.00 || JONES | 35700.00 || MARTIN | 15000.00 || BLAKE | 34200.00 || CLARK | 29400.00 || SCOTT | 36000.00 || KING | 60000.00 || TURNER | 18000.00 || ADAMS | 13200.00 || JAMES | 11400.00 || FORD | 36000.00 || MILLER | 15600.00 |+--------+----------+ 条件查询语法格式12345678 select 字段1，字段2，... from 表名 where 条件;执行顺序：from --&gt; where --&gt; select 题目：查询工资等于5000的员工姓名 select ename, sal from emp where sal = 5000; 12345+-------+---------+| ename | sal |+-------+---------+| KING | 5000.00 |+-------+---------+ 题目：查询SMITH的工资 select ename, sal from emp where ename = ‘SMITH’;注意：字符串要用’ ‘括起来 12345+-------+--------+| ename | sal |+-------+--------+| SMITH | 800.00 |+-------+--------+ 题目：查询工资不为3000的员工 select ename, sal from emp where sal &lt;&gt; 3000;select ename, sal from emp where sal != 3000;注意：不等于有两种表达形式：&lt;&gt; 和 != 12345678910111213141516171819202122232425262728293031323334353637全部员工的工资：+--------+---------+| ename | sal |+--------+---------+| SMITH | 800.00 || ALLEN | 1600.00 || WARD | 1250.00 || JONES | 2975.00 || MARTIN | 1250.00 || BLAKE | 2850.00 || CLARK | 2450.00 || SCOTT | 3000.00 || KING | 5000.00 || TURNER | 1500.00 || ADAMS | 1100.00 || JAMES | 950.00 || FORD | 3000.00 || MILLER | 1300.00 |+--------+---------+工资不等于3000的员工：+--------+---------+| ename | sal |+--------+---------+| SMITH | 800.00 || ALLEN | 1600.00 || WARD | 1250.00 || JONES | 2975.00 || MARTIN | 1250.00 || BLAKE | 2850.00 || CLARK | 2450.00 || KING | 5000.00 || TURNER | 1500.00 || ADAMS | 1100.00 || JAMES | 950.00 || MILLER | 1300.00 |+--------+---------+ between…and…题目：求工资在1500到3000之间的员工 select ename,sal from emp where sal between 1500 and 3000;注意：between…and…是从左到右执行的，因此不能写between 3000 and 1500,此时无数据。 123456789101112+--------+---------+| ename | sal |+--------+---------+| ALLEN | 1600.00 || JONES | 2975.00 || BLAKE | 2850.00 || CLARK | 2450.00 || SCOTT | 3000.00 || TURNER | 1500.00 || FORD | 3000.00 |+--------+---------+可以看出，当between...and...中是数字的时候，范围是左闭右闭的。 题目：求出姓名在A和C之间的员工 select ename from emp where ename between ‘A’ and ‘C’; 1234567891011121314151617181920212223242526272829姓名在A和C之间的员工:+-------+| ename |+-------+| ALLEN || BLAKE || ADAMS |+-------+所有员工：+--------+| ename |+--------+| ADAMS || ALLEN || BLAKE || CLARK || FORD || JAMES || JONES || KING || MARTIN || MILLER || SCOTT || SMITH || TURNER || WARD |+--------+不难看出，between...and...用于字符串的排序的时候，是左臂闭右开的。 is NULL题目：找出哪些人有津贴，哪些人没有津贴。 select ename,comm from emp where comm is NULL;select ename,comm from emp where comm is not NULL;错误写法：select ename,comm from emp where comm = NULL;select ename,comm from emp where comm != NULL;注意事项：在数据库中NULL不是一个值，而是代表什么也没有，为空。空不是一个值，所以不能用等号衡量 12345678910111213141516171819202122232425262728293031323334353637383940414243无津贴的：+--------+------+| ename | comm |+--------+------+| SMITH | NULL || JONES | NULL || BLAKE | NULL || CLARK | NULL || SCOTT | NULL || KING | NULL || ADAMS | NULL || JAMES | NULL || FORD | NULL || MILLER | NULL |+--------+------+有津贴的：+--------+---------+| ename | comm |+--------+---------+| ALLEN | 300.00 || WARD | 500.00 || MARTIN | 1400.00 || TURNER | 0.00 |+--------+---------+全部的：+--------+---------+| ename | comm |+--------+---------+| SMITH | NULL || ALLEN | 300.00 || WARD | 500.00 || JONES | NULL || MARTIN | 1400.00 || BLAKE | NULL || CLARK | NULL || SCOTT | NULL || KING | NULL || TURNER | 0.00 || ADAMS | NULL || JAMES | NULL || FORD | NULL || MILLER | NULL |+--------+---------+ and 与 or题目：找出工作岗位是MANAGER和SALESMAN的员工 select ename,job from emp where job = ‘MANAGER’ or job = ‘SALESMAN’; 1234567891011+--------+----------+| ename | job |+--------+----------+| ALLEN | SALESMAN || WARD | SALESMAN || JONES | MANAGER || MARTIN | SALESMAN || BLAKE | MANAGER || CLARK | MANAGER || TURNER | SALESMAN |+--------+----------+ 题目：找出薪资大于1000并且部门编号是20或者30的员工 select ename,sal,deptno from emp where sal &gt; 1000 and (deptno = 20 or deptno = 30);注意事项：and 的优先级要比 or 高，所以本题当中的()不可以省略，如果省略则错误。 12345678910111213+--------+---------+--------+| ename | sal | deptno |+--------+---------+--------+| ALLEN | 1600.00 | 30 || WARD | 1250.00 | 30 || JONES | 2975.00 | 20 || MARTIN | 1250.00 | 30 || BLAKE | 2850.00 | 30 || SCOTT | 3000.00 | 20 || TURNER | 1500.00 | 30 || ADAMS | 1100.00 | 20 || FORD | 3000.00 | 20 |+--------+---------+--------+ in 与 not in题目：找出工作岗位是找出工作岗位是MANAGER和SALESMAN的员工 select ename,job from emp where job = ‘MANAGER’ or job = ‘SALESMAN’;这是用 or 来写select ename,job from emp where job in(‘MANAGER’,’SALESMAN’);这里用 in 来写不难看出，in 和 or 的功能是一样的，只是写法上面有所不同。 1234567891011121314151617181920212223242526mysql&gt; mysql&gt; select ename,job from emp where job = &#x27;MANAGER&#x27; or job = &#x27;SALESMAN&#x27;;+--------+----------+| ename | job |+--------+----------+| ALLEN | SALESMAN || WARD | SALESMAN || JONES | MANAGER || MARTIN | SALESMAN || BLAKE | MANAGER || CLARK | MANAGER || TURNER | SALESMAN |+--------+----------+mysql&gt; select ename,job from emp where job in(&#x27;MANAGER&#x27;,&#x27;SALESMAN&#x27;);+--------+----------+| ename | job |+--------+----------+| ALLEN | SALESMAN || WARD | SALESMAN || JONES | MANAGER || MARTIN | SALESMAN || BLAKE | MANAGER || CLARK | MANAGER || TURNER | SALESMAN |+--------+----------+ 题目：找出工作岗位不是MANAGER和SALESMAN的员工 select ename,job from emp where job not in(‘MANAGER’,’SALESMAN’); 1234567891011+--------+-----------+| ename | job |+--------+-----------+| SMITH | CLERK || SCOTT | ANALYST || KING | PRESIDENT || ADAMS | CLERK || JAMES | CLERK || FORD | ANALYST || MILLER | CLERK |+--------+-----------+ 模糊查询like题目：找出名字中含有O的员工 select ename from emp where ename like ‘%O%’; 1234567+-------+| ename |+-------+| JONES || SCOTT || FORD |+-------+ 题目：找出名字第二字母是A的员工 select ename from emp where ename like ‘_A%’; 1234567+--------+| ename |+--------+| WARD || MARTIN || JAMES |+--------+ 题目：找出名字中有下划线_的 select ename from emp where ename like ‘%_%’; 1本数据库当中无带有下划线的名字，本题不是只是一个例子，所以这里不展示结果。 总结掌握两个特殊的符号：% 和 _% 代表任意多个字符，_ 代表任意一个字符当我们刚好需要寻找 % 和 _ 的时候，可以用转义字符 \\% \\_来表示。 数据排序格式1234567891011121314151617181920升序(默认升序，不写asc也是升序)：select 字段1，字段2，...from 表名where 条件order by 字段1，字段2，...asc;降序：select 字段1，字段2，...from 表名where 条件order by 字段1，字段2，...desc; 题目：按照工资升序找出员工名和薪资 select ename,sal from emp order by sal;select ename,sal from emp order by sal asc;默认排序就是升序，因此 asc 不写也可以。 123456789101112131415161718+--------+---------+| ename | sal |+--------+---------+| SMITH | 800.00 || JAMES | 950.00 || ADAMS | 1100.00 || WARD | 1250.00 || MARTIN | 1250.00 || MILLER | 1300.00 || TURNER | 1500.00 || ALLEN | 1600.00 || CLARK | 2450.00 || BLAKE | 2850.00 || JONES | 2975.00 || SCOTT | 3000.00 || FORD | 3000.00 || KING | 5000.00 |+--------+---------+ 题目：按照工资降序找出员工名和薪资 select ename,sal from emp order by sal desc; 123456789101112131415161718+--------+---------+| ename | sal |+--------+---------+| KING | 5000.00 || SCOTT | 3000.00 || FORD | 3000.00 || JONES | 2975.00 || BLAKE | 2850.00 || CLARK | 2450.00 || ALLEN | 1600.00 || TURNER | 1500.00 || MILLER | 1300.00 || WARD | 1250.00 || MARTIN | 1250.00 || ADAMS | 1100.00 || JAMES | 950.00 || SMITH | 800.00 |+--------+---------+ 题目：按照工资的降序排列，工资相同是按名字的升序排序 select ename,sal from emp order by sal desc,ename asc; 123456789101112131415161718+--------+---------+| ename | sal |+--------+---------+| KING | 5000.00 || FORD | 3000.00 || SCOTT | 3000.00 || JONES | 2975.00 || BLAKE | 2850.00 || CLARK | 2450.00 || ALLEN | 1600.00 || TURNER | 1500.00 || MILLER | 1300.00 || MARTIN | 1250.00 || WARD | 1250.00 || ADAMS | 1100.00 || JAMES | 950.00 || SMITH | 800.00 |+--------+---------+ 注意事项：有多个字段同时排序的时候，按前后顺序执行，前面出现一样的情况时，才会执行后面的。越靠前的字段越能起到主导作用，只有当前面的字段无法完成排序的时候，才会用后面的字段。 补充：排序也可以这么写 >select ename,sal from emp order by 2; 此时的含义是ename是第一个，sal是第二个，此时按第二个sal进行排序。 这种方法的健壮性很差，一般不推荐使用。 题目：找出工作岗位是SALESMAN的员工，并且按照薪资降序排列。 select ename,job,sal from emp where job = ‘SALESMAN’ order by sal desc; 12345678+--------+----------+---------+| ename | job | sal |+--------+----------+---------+| ALLEN | SALESMAN | 1600.00 || TURNER | SALESMAN | 1500.00 || WARD | SALESMAN | 1250.00 || MARTIN | SALESMAN | 1250.00 |+--------+----------+---------+ 分组函数 分组函数一共有五个：count：计数sum：求和avg：平均值max：最大值min：最小值 多行处理函数与单行处理函数 分组函数又叫多行处理函数，特点是：输入多行，但最终输出的结果为一行。所有的分组函数都是对“某一组”数据进行操作的。单行处理函数：输入一行，输出一行。 题目：找出员工工资总和 >select sum(sal) from emp; 12345+----------+| sum(sal) |+----------+| 29025.00 |+----------+ 题目：找出最高工资 select max(sal) from emp; 12345+----------+| max(sal) |+----------+| 5000.00 |+----------+ 题目：找出总人数 select count(*) from emp;select count(ename) from emp; 12345678910111213select count(*) from emp; +----------+| count(*) |+----------+| 14 |+----------+select count(ename) from emp;+--------------+| count(ename) |+--------------+| 14 |+--------------+ 题目：同时求出总人数，工资总数、平均数、最大值、最小值 select count(*),sum(sal),avg(sal),max(sal),min(sal) from emp; 12345+----------+----------+-------------+----------+----------+| count(*) | sum(sal) | avg(sal) | max(sal) | min(sal) |+----------+----------+-------------+----------+----------+| 14 | 29025.00 | 2073.214286 | 5000.00 | 800.00 |+----------+----------+-------------+----------+----------+ ifnull()空处理函数 所有数据库只要表达式运算有NULL，那么最后的运算结果都为NULL。我们为了解决这个问题，提出了ifnull方法。 1234 格式 ifnull（可能为NULL的数据，被当做什么来处理）例如：ifnull（comm，0）意思就是如果comm中有NULL的话，我们把它当做0来处理 题目：计算每个员工的年薪(加上津贴) select ename,(sal+ifnull(comm,0))*12 as yearsal from emp;这个时候如果comm当做有NULL的话，就当做0来运算。 123456789101112131415161718192021222324252627282930313233343536373839所有员工的津贴如下：+--------+---------+| ename | comm |+--------+---------+| SMITH | NULL || ALLEN | 300.00 || WARD | 500.00 || JONES | NULL || MARTIN | 1400.00 || BLAKE | NULL || CLARK | NULL || SCOTT | NULL || KING | NULL || TURNER | 0.00 || ADAMS | NULL || JAMES | NULL || FORD | NULL || MILLER | NULL |+--------+---------+每个员工的年薪(加上津贴)+--------+----------+| ename | yearsal |+--------+----------+| SMITH | 9600.00 || ALLEN | 22800.00 || WARD | 21000.00 || JONES | 35700.00 || MARTIN | 31800.00 || BLAKE | 34200.00 || CLARK | 29400.00 || SCOTT | 36000.00 || KING | 60000.00 || TURNER | 18000.00 || ADAMS | 13200.00 || JAMES | 11400.00 || FORD | 36000.00 || MILLER | 15600.00 |+--------+----------+ 分组函数会自动忽略到NULL 题目：计算所有员工津贴的总和 select sum(comm) from emp;这里分组函数自动将comm中的NULL忽略掉了。 12345+-----------+| sum(comm) |+-----------+| 2200.00 |+-----------+ 分组函数的执行顺序(这一块需要结合后面的group by理解) 分组函数必须在分完组后才能执行。如果SQL语句中没有group by 语句的话，整个表的数据自成为一组。而group by 语句必须在 where 后面执行，所以分组函数不可以使用在where 子句当中。 题目：找出工资高于平均工资的员工 错误写法：select ename,sal from emp where sal &gt; avg(sal);此时分组函数出现在了where中，因此改语句错误，原因是无效的使用了分组函数。正确写法：select ename,sal from emp where sal &gt; (select avg(sal) from emp); 嵌套一个SQL语句。 12345678910+-------+---------+| ename | sal |+-------+---------+| JONES | 2975.00 || BLAKE | 2850.00 || CLARK | 2450.00 || SCOTT | 3000.00 || KING | 5000.00 || FORD | 3000.00 |+-------+---------+ count(*) 与 count(具体的某个字段) 的区别 count(*)不是统计某个字段中的数据的个数，而是统计总记录条数。（和某个字段无关）count(某个具体的字段)：表示统计该字段中不为NULL的数据总数量。 group by 与 having group by：按照某个字段或者某些字段进行分组。having：是对分组之后的数据进行再次过滤分组函数一般会和group by 联合使用，这也是分组函数为什么叫这个名字的原因。 题目：找出每个工作岗位的最高薪资 select max(sal),job from emp group by job;将emp当中的数据根据job分组后在求出每组当中的最大薪资。 123456789+----------+-----------+| max(sal) | job |+----------+-----------+| 1300.00 | CLERK || 1600.00 | SALESMAN || 2975.00 | MANAGER || 3000.00 | ANALYST || 5000.00 | PRESIDENT |+----------+-----------+ 多个字段联合起来一起分组题目：找出每个部门不用岗位的最高薪资 select deptno,job,max(sal) from emp group by deptno,job order by deptno asc,job asc;这里我们还将结果根据deptno 和 job 进行了升序排序。 1234567891011121314+--------+-----------+----------+| deptno | job | max(sal) |+--------+-----------+----------+| 10 | CLERK | 1300.00 || 10 | MANAGER | 2450.00 || 10 | PRESIDENT | 5000.00 || 20 | ANALYST | 3000.00 || 20 | CLERK | 1100.00 || 20 | MANAGER | 2975.00 || 30 | CLERK | 950.00 || 30 | MANAGER | 2850.00 || 30 | SALESMAN | 1600.00 |+--------+-----------+----------+可以看出，group by 还可以同时多个进行分组的。 having题目：找出每个部门的最高薪资，要求显示最大薪资大于2900的数据。 select deptno,max(sal) from emp group by deptno having max(sal) &gt;2900;select deptno,max(sal) from emo where sal &gt; 2900 group by deptno;这两条语句都可以求出，但是我们用having的效率要比where的效率低，一般我们都推荐尽量使用where。 123456+--------+----------+| deptno | max(sal) |+--------+----------+| 20 | 3000.00 || 10 | 5000.00 |+--------+----------+ 题目：找出每个部门的平均薪资，要求显示平均薪资大于2000的。 select deptno,avg(sal) from emp group by deptno having avg(sal) &gt; 2000;注意：此时的平均薪资是通过分组函数进行求得的，我们无法直接获得这个值，所以此时不能用where来写，因为分组函数不能出现在where中。 123456+--------+-------------+| deptno | avg(sal) |+--------+-------------+| 20 | 2175.000000 || 10 | 2916.666667 |+--------+-------------+ 完整的SQL语句的顺序12345678910111213 执行顺序select 5 ...from 1 ...where 2 ..,group by 3 ...having 4 ...order by 6 ... 关于查询结果集的去重 distinct 关键字，去除重复记录。注意：distinct 关键字只能出现在所有字段的最前面。 题目：查询所有的员工岗位 select distinct job from emp; 1234567891011121314151617181920212223242526272829303132select distinct job from emp;+-----------+| job |+-----------+| CLERK || SALESMAN || MANAGER || ANALYST || PRESIDENT |+-----------+select job from emp;+-----------+| job |+-----------+| CLERK || SALESMAN || SALESMAN || MANAGER || SALESMAN || MANAGER || MANAGER || ANALYST || PRESIDENT || SALESMAN || CLERK || CLERK || ANALYST || CLERK |+-----------+可以看出，通过distinct关键字实现了去重。 错误写法：select ename, distinct job from emp;distinct 关键字只能出现在所有字段的最前面。表示给后面所有的字段进行去重。 题目：查询每个部门的岗位。 select distinct deptno, job from emp order by deptno; 12345678910111213+--------+-----------+| deptno | job |+--------+-----------+| 10 | CLERK || 10 | MANAGER || 10 | PRESIDENT || 20 | ANALYST || 20 | CLERK || 20 | MANAGER || 30 | CLERK || 30 | MANAGER || 30 | SALESMAN |+--------+-----------+ 题目：统计岗位的数量。 select count(distinct job) from emp; 12345+---------------------+| count(distinct job) |+---------------------+| 5 |+---------------------+ 连接查询什么是连接查询？ 在实际开发中，大部分的情况下都不是从单表中查询数据，一般都是从多张表联合查询取出最终的结果。在实际开发中，一般一个业务都会对应多张表，比如学生和班级，起码有两张表。如果存储到一张表中，数据会存在大量的重复，导致数据的冗余。 连接查询的分类 根据语句出现的年代划分：SQL92(一些老的DBA(DataBase Administrator数据库管理员)可能还在使用)。SQL99(比较新的语法)根据表的连接方式划分：内连接：等值连接、非等值连接、自连接外连接：左外连接(左连接)、右外连接(右连接)全连接(很少用) 笛卡尔积现象 在表的连接查询方面有一种现象被称为：笛卡尔积现象。笛卡尔积现象：当两张表进行连接查询的时候，没有任何条件进行限制。最终的查询条数是两张表记录条数的乘积。 题目:找出每一个员工的部门名称，要求显示员工名和部门名。 select ename, dname from emp, dept; 1234567891011121314151617181920212223242526272829303132333435EMP表：+--------+--------+| ename | deptno |+--------+--------+| SMITH | 20 || ALLEN | 30 || WARD | 30 || JONES | 20 || MARTIN | 30 || BLAKE | 30 || CLARK | 10 || SCOTT | 20 || KING | 10 || TURNER | 30 || ADAMS | 20 || JAMES | 30 || FORD | 20 || MILLER | 10 |+--------+--------+DEPT表：+--------+------------+----------+| deptno | dname | loc |+--------+------------+----------+| 10 | ACCOUNTING | NEW YORK || 20 | RESEARCH | DALLAS || 30 | SALES | CHICAGO || 40 | OPERATIONS | BOSTON |+--------+------------+----------+select ename, dname from emp, dept; 56 rows in set (0.31 sec)执行上述语句的时候，会发现一共有14x4=56条结果，这个现象就叫做笛卡尔积现象。 关于表的别名：select e.ename, d.dname from emp e, dept d;好处：执行效率高、可读性好。 如何避免笛卡尔积现象：加条件进行过滤。注意：避免笛卡尔积现象不会减少记录的匹配次数，次数还是56次，只不过显示的是有效记录。 12345678910111213141516171819202122232425262728 select e.ename, d.dname from emp e, dept d where e.deptno = d.deptno;+--------+------------+| ename | dname |+--------+------------+| SMITH | RESEARCH || ALLEN | SALES || WARD | SALES || JONES | RESEARCH || MARTIN | SALES || BLAKE | SALES || CLARK | ACCOUNTING || SCOTT | RESEARCH || KING | ACCOUNTING || TURNER | SALES || ADAMS | RESEARCH || JAMES | SALES || FORD | RESEARCH || MILLER | ACCOUNTING |+--------+------------+14 rows in set (0.00 sec)这是SQL92，以后不用。 内连接等值连接 最大特点：条件是等量关系。 123456789格式： ... A join B on 连接条件 where ... 题目：查询每个员工的部门名称，要求显示员工名和部门名。 1234567SQL92: select e.ename, d.dname from emp e, dept d where e.deptno = d.deptno; 12345678910111213SQL99: SQL99语法结果更清晰一点，表的连接条件和后面的where条件分离了。 select e.ename, d.dname from emp e (inner) join dept d on e.deptno = d.deptno;inner可以省略，带着inner的目的是好读一点。 非等值连接 最大的特点：连接条件中的关系是非等量关系。 题目：找出每个员工的工资等级，要求显示员工名、工资、工资等级。 12345678select e.ename, e.sal, s.gradefrom emp e(inner) join salgrade son e.sal between s.losal and s.hisal; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051EMP表：+--------+---------+| ename | sal |+--------+---------+| SMITH | 800.00 || ALLEN | 1600.00 || WARD | 1250.00 || JONES | 2975.00 || MARTIN | 1250.00 || BLAKE | 2850.00 || CLARK | 2450.00 || SCOTT | 3000.00 || KING | 5000.00 || TURNER | 1500.00 || ADAMS | 1100.00 || JAMES | 950.00 || FORD | 3000.00 || MILLER | 1300.00 |+--------+---------+SALGRADE表：+-------+-------+-------+| grade | losal | hisal |+-------+-------+-------+| 1 | 700 | 1200 || 2 | 1201 | 1400 || 3 | 1401 | 2000 || 4 | 2001 | 3000 || 5 | 3001 | 9999 |+-------+-------+-------+题解：+--------+---------+-------+| ename | sal | grade |+--------+---------+-------+| SMITH | 800.00 | 1 || ALLEN | 1600.00 | 3 || WARD | 1250.00 | 2 || JONES | 2975.00 | 4 || MARTIN | 1250.00 | 2 || BLAKE | 2850.00 | 4 || CLARK | 2450.00 | 4 || SCOTT | 3000.00 | 4 || KING | 5000.00 | 5 || TURNER | 1500.00 | 3 || ADAMS | 1100.00 | 1 || JAMES | 950.00 | 1 || FORD | 3000.00 | 4 || MILLER | 1300.00 | 2 |+--------+---------+-------+ 自连接 最大的特点：一张表看做两张表，自己连接自己。 题目：找出每个员工的上级领导，要求显示员工名称和对应的领导名。 12345678select a.ename, b.enamefrom emp ajoin emp bon a.mgr = b.empno; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758EMP a表：+--------+------+| ename | mgr |+--------+------+| SMITH | 7902 || ALLEN | 7698 || WARD | 7698 || JONES | 7839 || MARTIN | 7698 || BLAKE | 7839 || CLARK | 7839 || SCOTT | 7566 || KING | NULL || TURNER | 7698 || ADAMS | 7788 || JAMES | 7698 || FORD | 7566 || MILLER | 7782 |+--------+------+EMP b表：+--------+-------+| ename | empno |+--------+-------+| SMITH | 7369 || ALLEN | 7499 || WARD | 7521 || JONES | 7566 || MARTIN | 7654 || BLAKE | 7698 || CLARK | 7782 || SCOTT | 7788 || KING | 7839 || TURNER | 7844 || ADAMS | 7876 || JAMES | 7900 || FORD | 7902 || MILLER | 7934 |+--------+-------+题解:+--------+-------+| ename | ename |+--------+-------+| SMITH | FORD || ALLEN | BLAKE || WARD | BLAKE || JONES | KING || MARTIN | BLAKE || BLAKE | KING || CLARK | KING || SCOTT | JONES || TURNER | BLAKE || ADAMS | SCOTT || JAMES | BLAKE || FORD | JONES || MILLER | CLARK |+--------+-------+ 外连接什么是外连接？与内连接有什么区别？ 内连接：假设A和B表进行连接，使用内连接的话，凡是A表和B表能够匹配上的记录查询出来，这就是内连接。A、B两张表没有主副之分，是平等的。外连接：假设A和B表进行连接，使用外连接的话，A、B两张表中有一张表是主表，一张表是副表，主要查询主表中的数据，捎带这查询副表，当副表中的数据没有和主表中的数据匹配上，副表会自动模拟出NULL与之匹配。外连接的分类：左外连接(左连接)：表示左边的这张表是主表。右外连接(右连接)：表示有边的这张表是主表。左连接有右连接的写法，右连接也有对应的左连接的写法。 题目：找出每个员工的上级领导(所以员工必须全部找出(包括KING))。 123456789101112131415161718192021左(外)连接： select a.ename &#x27;员工&#x27;, b.ename &#x27;领导&#x27; from emp a left (outer) join emp b on a.mgr = b.empno;右(外)连接： select a.ename &#x27;员工&#x27;, b.ename &#x27;领导&#x27; from emp b right (outer) join emp a on a.mgr = b.empno;outer可省略！ 12345678910111213141516171819题解：+--------+-------+| 员工 | 领导 |+--------+-------+| SMITH | FORD || ALLEN | BLAKE || WARD | BLAKE || JONES | KING || MARTIN | BLAKE || BLAKE | KING || CLARK | KING || SCOTT | JONES || KING | NULL || TURNER | BLAKE || ADAMS | SCOTT || JAMES | BLAKE || FORD | JONES || MILLER | CLARK |+--------+-------+ 外连接的主要特点是：主表的数据无条件的全部查询出来。 题目：找出哪个部门没有员工。 123456789101112131415161718192021222324左连接： select d.* from dept d left join emp e on e.deptno = d.deptno where e.empno is NULL;右连接： select d.* from emp e right join dept d on e.deptno = d.deptno where e.empno is NULL; 1234567891011121314151617181920212223242526272829303132333435d表(主表)：+--------+------------+----------+| DEPTNO | DNAME | LOC |+--------+------------+----------+| 10 | ACCOUNTING | NEW YORK || 20 | RESEARCH | DALLAS || 30 | SALES | CHICAGO || 40 | OPERATIONS | BOSTON |+--------+------------+----------+e表(副表)：+--------+--------+| ename | deptno |+--------+--------+| SMITH | 20 || ALLEN | 30 || WARD | 30 || JONES | 20 || MARTIN | 30 || BLAKE | 30 || CLARK | 10 || SCOTT | 20 || KING | 10 || TURNER | 30 || ADAMS | 20 || JAMES | 30 || FORD | 20 || MILLER | 10 |+--------+--------+题解：+--------+------------+--------+| DEPTNO | DNAME | LOC |+--------+------------+--------+| 40 | OPERATIONS | BOSTON |+--------+------------+--------+ 三张表怎么连接查询12345678910... Ajoin Bon ...join Con ... 表示A先和B进行表连接，连接之后，A继续和C进行表连接。 题目：找出每一个员工的部门名称以及工资等级。 12345678910111213select e.ename, d.dname, s.gradefrom emp ejoin dept don e.deptno = d.deptnojoin salgrade son e.sal between s.losal and s.hisal; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758EMP e表：+-------+--------+---------+--------+| empno | ename | sal | deptno |+-------+--------+---------+--------+| 7369 | SMITH | 800.00 | 20 || 7499 | ALLEN | 1600.00 | 30 || 7521 | WARD | 1250.00 | 30 || 7566 | JONES | 2975.00 | 20 || 7654 | MARTIN | 1250.00 | 30 || 7698 | BLAKE | 2850.00 | 30 || 7782 | CLARK | 2450.00 | 10 || 7788 | SCOTT | 3000.00 | 20 || 7839 | KING | 5000.00 | 10 || 7844 | TURNER | 1500.00 | 30 || 7876 | ADAMS | 1100.00 | 20 || 7900 | JAMES | 950.00 | 30 || 7902 | FORD | 3000.00 | 20 || 7934 | MILLER | 1300.00 | 10 |+-------+--------+---------+--------+DEPT d表：+--------+------------+----------+| DEPTNO | DNAME | LOC |+--------+------------+----------+| 10 | ACCOUNTING | NEW YORK || 20 | RESEARCH | DALLAS || 30 | SALES | CHICAGO || 40 | OPERATIONS | BOSTON |+--------+------------+----------+SALGRADE s表：+-------+-------+-------+| GRADE | LOSAL | HISAL |+-------+-------+-------+| 1 | 700 | 1200 || 2 | 1201 | 1400 || 3 | 1401 | 2000 || 4 | 2001 | 3000 || 5 | 3001 | 9999 |+-------+-------+-------+题解：+--------+------------+-------+| ename | dname | grade |+--------+------------+-------+| SMITH | RESEARCH | 1 || ALLEN | SALES | 3 || WARD | SALES | 2 || JONES | RESEARCH | 4 || MARTIN | SALES | 2 || BLAKE | SALES | 4 || CLARK | ACCOUNTING | 4 || SCOTT | RESEARCH | 4 || KING | ACCOUNTING | 5 || TURNER | SALES | 3 || ADAMS | RESEARCH | 1 || JAMES | SALES | 1 || FORD | RESEARCH | 4 || MILLER | ACCOUNTING | 2 |+--------+------------+-------+ 题目：找出每一个员工的部门名称，工资等级以及上级领导。 12345678910111213141516select e.ename, d.dname, s.gradefrom emp ejoin dept don e.deptno = d.deptnojoin salgrade son e.sal between s.losal and s.hisalleft join emp eeon e.mgr = ee.empno; 12345678910111213141516171819题解：+--------+------------+-------+| ename | dname | grade |+--------+------------+-------+| SMITH | RESEARCH | 1 || ALLEN | SALES | 3 || WARD | SALES | 2 || JONES | RESEARCH | 4 || MARTIN | SALES | 2 || BLAKE | SALES | 4 || CLARK | ACCOUNTING | 4 || SCOTT | RESEARCH | 4 || KING | ACCOUNTING | 5 || TURNER | SALES | 3 || ADAMS | RESEARCH | 1 || JAMES | SALES | 1 || FORD | RESEARCH | 4 || MILLER | ACCOUNTING | 2 |+--------+------------+-------+ 子查询什么是子查询？ select语句中嵌套select语句，被嵌套的select语句是子查询。 子查询出现的位置？123456select ...(select语句)...from ...(select语句)...where ...(select语句)... where语句中使用子查询题目：找出高于平均薪资的员工信息。 123456select ename, salfrom empwhere sal &gt; (select avg(sal) from emp); 123456789101112+-------+---------+| ename | sal |+-------+---------+| JONES | 2975.00 || BLAKE | 2850.00 || CLARK | 2450.00 || SCOTT | 3000.00 || KING | 5000.00 || FORD | 3000.00 |+-------+---------+这里只查了名字和薪资，其他的没有查询。 from后面嵌套子查询题目：找出每个部门平均薪水的薪资等级。 1234567891011121314151617181920212223242526272829303132333435第一步：找出每个部门平均薪水 select deptno, avg(sal) as avgsal from emp group by deptno;+--------+-------------+| deptno | avgsal |+--------+-------------+| 20 | 2175.000000 || 30 | 1566.666667 || 10 | 2916.666667 |+--------+-------------+第二步：将第一步查询结果当做临时表t,让t表和SALGRADE s表连接，条件是t.avgsal between s.losal and s.hisal select t.*, s.grade from (select deptno, avg(sal) as avgsal from emp group by deptno) t join salgrade s on t.avgsal between s.losal and s.hisal;+--------+-------------+-------+| deptno | avgsal | grade |+--------+-------------+-------+| 20 | 2175.000000 | 4 || 30 | 1566.666667 | 3 || 10 | 2916.666667 | 4 |+--------+-------------+-------+ 题目：找出每个部门平均的薪水等级 123456789101112131415161718192021222324252627282930313233343536373839404142434445第一步：找出每个员工的薪水等级 select e.ename, e.sal, e.deptno, s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal;+--------+---------+--------+-------+| ename | sal | deptno | grade |+--------+---------+--------+-------+| SMITH | 800.00 | 20 | 1 || ALLEN | 1600.00 | 30 | 3 || WARD | 1250.00 | 30 | 2 || JONES | 2975.00 | 20 | 4 || MARTIN | 1250.00 | 30 | 2 || BLAKE | 2850.00 | 30 | 4 || CLARK | 2450.00 | 10 | 4 || SCOTT | 3000.00 | 20 | 4 || KING | 5000.00 | 10 | 5 || TURNER | 1500.00 | 30 | 3 || ADAMS | 1100.00 | 20 | 1 || JAMES | 950.00 | 30 | 1 || FORD | 3000.00 | 20 | 4 || MILLER | 1300.00 | 10 | 2 |+--------+---------+--------+-------+第二步：将第一步的结果继续按deptno分组，求grade的平均值 select e.deptno, avg(s.grade) from emp e join salgrade s on e.sal between s.losal and s.hisal group by e.deptno;+--------+--------------+| deptno | avg(s.grade) |+--------+--------------+| 20 | 2.8000 || 30 | 2.5000 || 10 | 3.6667 |+--------+--------------+ select后面嵌套子查询题目：找出每个员工所在的部门名称。要求显示员工名和部门名。 123456789select e.ename, (select d.dname from dept d where e.deptno = d.deptno) as dnamefrom emp e; 123456789101112131415161718+--------+------------+| ename | dname |+--------+------------+| SMITH | RESEARCH || ALLEN | SALES || WARD | SALES || JONES | RESEARCH || MARTIN | SALES || BLAKE | SALES || CLARK | ACCOUNTING || SCOTT | RESEARCH || KING | ACCOUNTING || TURNER | SALES || ADAMS | RESEARCH || JAMES | SALES || FORD | RESEARCH || MILLER | ACCOUNTING |+--------+------------+ union(将查询结果集相加) union：将两种不相干的表的数据拼接在一起显示。 题目：找出工作岗位是SALESMAN和MANAGER的员工。 1234567891011121314151617181920212223242526272829303132333435363738394041424344用or来写： select ename, job from emp where job = &#x27;SALESMAN&#x27; or job = &#x27;MANAGER&#x27;;用in来写： select ename, job from emp where job in(&#x27;SALESMAN&#x27;,&#x27;MANAGER&#x27;);用union来写： select ename, job from emp where job = &#x27;SALESMAN&#x27; union select ename, job from emp where job = &#x27;MANAGER&#x27;;+--------+----------+| ename | job |+--------+----------+| ALLEN | SALESMAN || WARD | SALESMAN || JONES | MANAGER || MARTIN | SALESMAN || BLAKE | MANAGER || CLARK | MANAGER || TURNER | SALESMAN |+--------+----------+ limit limit是MYSQL特有的，其他数据库没有。（Oracle中有一个相同的机制，叫做rownum） 作用：取结果的部分数据 limit是SQL语句最后执行的一个环节。 12345格式： limit startIndex, lengthstartIndex：起始位置（从0开始，0表示第一条数据）length：取几个 题目：取出工资前5名的员工。（思路：降序取前5个） 1234567891011121314151617181920212223242526272829方法一： select ename, sal from emp order by sal desc limit 0, 5;方法二： select ename, sal from emp order by sal desc limit 5; 如果前面不写则起始位置默认从0开始。+-------+---------+| ename | sal |+-------+---------+| KING | 5000.00 || SCOTT | 3000.00 || FORD | 3000.00 || JONES | 2975.00 || BLAKE | 2850.00 |+-------+---------+ 题目：找出工资排名在第4到第9的员工。 12345678910111213141516171819 select ename, sal from emp order by sal desc limit 3, 6;+--------+---------+| ename | sal |+--------+---------+| JONES | 2975.00 || BLAKE | 2850.00 || CLARK | 2450.00 || ALLEN | 1600.00 || TURNER | 1500.00 || MILLER | 1300.00 |+--------+---------+ 通用的标准分页SQL 每页显示pagesize条记录 第pageNo页：（pageNo - 1） * pagesize, pagesize pagesize:每页显示多少条记录pageNo:第几页 创建表123456格式： create table 表名( 字段名1 数据类型 字段名2 数据类型 ... ); 关于MYSQL当中字段的类型 数据类型 描述 int 整型，相当于Java中的int bigint 整型，相当于Java中的long float 相当于Java中的float、double char 定点字符串，相当于Java中的String varchar 可变字符串，相当于StringBuffer/StringBuilder date 日期类型，相当于Java中的java.sql.Date BLOB 二进制对象(Binary Large Object)，存储图片、视频等流媒体信息。相当于Java中的Object CLOB 字符大对象(Character Large Object)，存储较大文本，比如可以存储4G的字符串 char和varchar怎么选择？ char： 在实际的开发中，某个字段的数据长度不发生改变是定长的，如性别、生日等用char。 varchar： 根据实际的大小动态分配大小。当一个字段的数据长度不确定的时候用varchar，例如：简介、姓名等。 创建学生表 表名在数据库中一般建议以t或者tbl开始。 1234567891011创建学生表： 学生信息一般包括：学号、姓名、性别、班级编号、生日... create table t_student( no bigint, name varchar(255), sex char(1), classno varchar(255), birth char(10) ); 插入数据（insert语句)12格式： insert into 表名(字段1，字段2，...) values(值1，值2，...) 要求： 字段的数量和值的数量相同，并且数据类型要对应相同。 注意：当一个insert语句执行成功之后，表格当中必然会多一行记录。即使多的这行记录当中某些字段是NULL，后期也没有办法在执行insert语句插入数据了，只能使用update进行更新。 全部插入1234567insert into t_student(no,name,sex,classno,birth) values(1,&#39;张三&#39;,&#39;1&#39;,&#39;高三1班&#39;,&#39;2000-12-2&#39;);+------+------+------+---------+-----------+| no | name | sex | classno | birth |+------+------+------+---------+-----------+| 1 | 张三 | 1 | 高三1班 | 2000-12-2 |+------+------+------+---------+-----------+ 插入一部分12345678910insert into t_student(name) values(&#39;王五&#39;);+------+------+------+---------+-----------+| no | name | sex | classno | birth |+------+------+------+---------+-----------+| 1 | 张三 | 1 | 高三1班 | 2000-12-2 || NULL | 王五 | NULL | NULL | NULL |+------+------+------+---------+-----------+除name字段外，剩下的所有字段自动插入NULL。 字段省略1234567insert into t_student values(2,&#39;jack&#39;,&#39;0&#39;,&#39;高三2班&#39;,&#39;2001-2-3&#39;);+------+------+------+---------+----------+| no | name | sex | classno | birth |+------+------+------+---------+----------+| 2 | jack | 0 | 高三2班 | 2001-2-3 |+------+------+------+---------+----------+如果字段省略的话，表示全部都要插入，后面不能少写。 建表的时候加入默认值123456789101112131415161718 create table t_student( no bigint, name varchar(255), sex char(1) default 1, classno varchar(255), birth char(10) );sex默认为1此时同上面插入语句：insert into t_student(name) values(&#39;王五&#39;);会发现sex中有默认值为1+------+------+------+---------+-------+| no | name | sex | classno | birth |+------+------+------+---------+-------+| NULL | 王五 | 1 | NULL | NULL |+------+------+------+---------+-------+ 一次插入多行数据12345678910insert into t_student(no,name,sex,classno,birth) values(3,&#39;rose&#39;,&#39;1&#39;,&#39;高三2班&#39;,&#39;2001-3-4&#39;),(4,&#39;Mary&#39;,&#39;0&#39;,&#39;高三3班&#39;,&#39;2000-5-6&#39;);+------+------+------+----------+----------+| no | name | sex | classno | birth |+------+------+------+----------+----------+| NULL | 王五 | 1 | NULL | NULL || 2 | jack | 0 | 高三2班 | 2001-2-3 || 3 | rose | 1 | 高三2班 | 2001-3-4 || 4 | Mary | 0 | 高三3班 | 2000-5-6 |+------+------+------+----------+----------+ 删表123drop table if exists t_student;如果该表存在则删除。 表的复制1234格式： create table 表名 as select语句；将查询结果当做表创建处理。 123456789101112131415161718192021create table emp1 as select ename,empno from emp;mysql&gt; select * from emp1;+--------+-------+| ename | empno |+--------+-------+| SMITH | 7369 || ALLEN | 7499 || WARD | 7521 || JONES | 7566 || MARTIN | 7654 || BLAKE | 7698 || CLARK | 7782 || SCOTT | 7788 || KING | 7839 || TURNER | 7844 || ADAMS | 7876 || JAMES | 7900 || FORD | 7902 || MILLER | 7934 |+--------+-------+ 将查询结果插入到一张表中12345678910111213141516171819202122232425262728293031323334353637emp2表：+-------+-------+| ename | empno |+-------+-------+| Mary | 8888 || Jack | 9999 |+-------+-------+emp1表：+--------+-------+| ename | empno |+--------+-------+| SMITH | 7369 || ALLEN | 7499 || WARD | 7521 || JONES | 7566 || MARTIN | 7654 || BLAKE | 7698 || CLARK | 7782 || SCOTT | 7788 || KING | 7839 || TURNER | 7844 || ADAMS | 7876 || JAMES | 7900 || FORD | 7902 || MILLER | 7934 |+--------+-------+将emp1表中的SIMTH开头的人插入到emp2中：insert into emp2 select ename,empno from emp1 where ename &#x3D; &#39;SMITH&#39;;+-------+-------+| ename | empno |+-------+-------+| Mary | 8888 || Jack | 9999 || SMITH | 7369 |+-------+-------+ 修改数据12格式：update 表名 set 字段名1 &#x3D; 值,，字段名2 &#x3D; 值2,... where 条件; 注意：如果没有条件则全部更新。 题目：将emp2中的Mary的员工号改成8899。 123456789update emp2 set empno &#x3D; 8899 where empno &#x3D; 8888;+-------+-------+| ename | empno |+-------+-------+| Mary | 8899 || Jack | 9999 || SMITH | 7369 |+-------+-------+ 题目：将emp2中的员工号全部修改为1111。 1234567891011 update emp2 set empno &#x3D; 1111;+-------+-------+| ename | empno |+-------+-------+| Mary | 1111 || Jack | 1111 || SMITH | 1111 |+-------+-------+不加条件全部更新。 删除表中的数据12格式：delete from 表名 where 条件; 注意：没有条件则全部删除。 题目：删除emp2表中Jack的数据。 12345678delete from emp2 where ename &#x3D; &#39;Jack&#39;;+-------+-------+| ename | empno |+-------+-------+| Mary | 1111 || SMITH | 1111 |+-------+-------+ 题目：删除emp2中的全部数据。 1234delete from emp2;mysql&gt; select * from emp2;Empty set (0.00 sec) 怎么删除大表中的数据123truncate table 表名;表被截断，不可回滚，永久丢失。 删除表12drop table 表名; &#x2F;&#x2F;通用drop table if exists 表名; &#x2F;&#x2F;Oracle不支持这种写法。 表结构的修改 表结构的修改，使用工具完成即可。因为在实际开发中表一旦设计好之后，对表的结构的修改是很少的，修改表结构就是对之前的设计进行了否定，即使需要修改表结构，我们也可以直接使用工具操作。 修改表结构的语句不会出现在Java代码当中，出现在Java代码当中的SQL语句包括：insert、delete、update、select。（这些都是表中的数据操作。）增删改查有一个术语：CRUD操作（增create、检查retrieve、修改update、删除delete） 约束(Constraint)什么是约束？ 在创建表的时候，可以给表的字段添加相应的约束，添加约束的目的是为了保证表中的数据的合法性、有效性、完整性。 常见的约束 非空约束(not null)：约束的字段不能为NULL 唯一约束(unique)：约束的字段不能重复 主键约束(primary key)：约束的字段既不能为NULL，也不能重复，简称PK。 外键约束(foreign key)：简称FK。 检查约束(check)：Oracle数据库有check约束，但是MYSQL没有。目前MYSQL不支持该约束。 非空约束（not null） 非空约束只有列级，没有表级。 123456drop table if exists t_user;create table t_user( id int, username varchar(255) not null, &#x2F;&#x2F;不为空，必须插入数据。 password varchar(255)); 唯一性约束（unique） 唯一约束修饰的字段具有唯一性，不能重复，但可以为NULL。 12345678910111213给一个字段添加unique约束： drop table if exists t_user; create table t_user( id int, username varchar(255) unique &#x2F;&#x2F;列级约束 );此时在插入数据时如下： insert into t_user values(1, &#39;zs&#39;); insert into t_user values(2, &#39;zs&#39;); &#x2F;&#x2F;报错，因为username重复了。 insert into t_user values(2); insert into t_user values(3); &#x2F;&#x2F;username可以为空。 1234567891011121314151617181920212223242526给两个字段添加约束：此时代表着两个字段联合起来不能一样。 drop table if exists t_user; create table t_user( id int, usercode varchar(255), username varchar(255), unique(usercode, username) &#x2F;&#x2F;多个字段联合起来添加一个约束 &#x2F;&#x2F;表级约束 );此时插入数据如下： insert into t_user values(1, ‘001’, &#39;zs&#39;); insert into t_user values(2, ‘002’, &#39;ls&#39;); insert into t_user values(3, ‘001’, &#39;ls&#39;); &#x2F;&#x2F;可以插入 insert into t_user values(4, ‘003’, &#39;ls&#39;); &#x2F;&#x2F;也可以插入 insert into t_user values(5, ‘001’, &#39;zs&#39;); &#x2F;&#x2F;插入错误，此时联合起来一样，不能插入。如果是如下这么插入的话，和上面的“联合起来不一样”不同，这里表示每一个都不能一样。 drop table if exists t_user; create table t_user( id int, usercode varchar(255) unique, username varchar(255) unique ); 主键约束（primary key） 主键约束是列级约束 添加方法：primary key关键字 注意：一张表的主键约束只能有一个 1234567891011121314151617181920给一张表添加主键约束： drop table if exists t_user; create table t_user( id int primary key, &#x2F;&#x2F;列级约束 username varchar(255), email varchar(255) );插入数据如下： insert into t_user(id,username,email) values(1,&#39;zs&#39;,&#39;zs@163.com&#39;); insert into t_user(id,username,email) values(2,&#39;ls&#39;,&#39;ls@163.com&#39;); insert into t_user(id,username,email) values(3,&#39;ww&#39;,&#39;ww@163.com&#39;);错误的插入方法： &#x2F;&#x2F;此时出错，因为id是PK。 insert into t_user(id,username,email) values(1,&#39;Jk&#39;,&#39;Jk@163.com&#39;); &#x2F;&#x2F;此时出错，因为id没有初始值。 insert into t_user(username,email) values(&#39;Rose&#39;,&#39;Rose@163.com&#39;); 根据上面测试得出，id是主键（添加了主键约束）。主键字段中的数据不能为NULL，也不能重复。 主键的特点：不能为NULL，不能重复。 主键相关的术语： 主键约束：primary key 主键字段：id字段添加primary key后，id叫做主键字段 主键值：id字段中的每一值都是主键值 主键的作用： 表的三范式中有要求第一范式要求任何一张表都应该有主键。主键值是这行记录在这张表中的唯一标识（就像一个人的身份证号码）。 主键的分类根据主键字段数量来划分： 单一主键（推荐的，常用的） 复合主键（多个字段联合起来添加一个主键约束）。—不推荐用，因为复合主键违背了三范式。 根据主键性质来划分： 自然主键:主键值是一个和业务没有任何关系的自然数。（这种方式是推荐的） 业务主键：主键值和系统业务挂钩。例如：银行卡号码、身份证号做主键（不推荐使用） 最好不要拿着和业务挂钩的字段作为主键，因为以后的业务一旦发生改变的时候，主键值可能也需要随着发生变化，但有的时候没有办法变化，因为变化可能导致主键值重复。 1234567891011121314使用表级约束方式定义主键： drop table if exists t_user; create table t_user( id int, username varchar(255), primary key(id) );插入数据如下： insert into t_user(id,username) values(1,&#39;zs&#39;); insert into t_user(id,username) values(2,&#39;ls&#39;); insert into t_user(id,username) values(3,&#39;ww&#39;); insert into t_user(id,username) values(4,&#39;jack&#39;); insert into t_user(id,username) values(4,&#39;rose&#39;); &#x2F;&#x2F;此行错误 MYSQL提供主键值自增（！！！）12345678910111213141516171819202122232425auto_increment:id字段自动维护一个自增的数字，从1开始，默认自增。 drop table if exists t_user; create table t_user( id int primary key auto_increment, username varchar(255) ); insert into t_user(username) values (&#39;a&#39;); insert into t_user(username) values (&#39;b&#39;); insert into t_user(username) values (&#39;c&#39;); insert into t_user(username) values (&#39;d&#39;); insert into t_user(username) values (&#39;e&#39;); +----+----------+ | id | username | +----+----------+ | 1 | a | | 2 | b | | 3 | c | | 4 | d | | 5 | e | +----+----------+补充：Oracle中也提供了一个自增机制，叫做序列（sequence）对象。 外键约束外键约束的相关术语 外键约束：foreign key 外键字段：添加有外键约束的字段 外键值：外键字段中的每一个值 业务背景设计一个数据表库，用来维护学生和班级的信息。 使用一张表存储所有的数据缺点：冗余（不推荐） 使用两张表：班级表t_class和学生表t_student t_class表：|cno(PK)|cname||:–:|:–:||101|1班||102|2班| t_student表：|sno(PK)|sname|classno(FK)||:–:|:–:|:–:||1|zs|101||2|ls|102||3|ww|101||4|jack|101||5|rose|102| 建表语句 顺序要求：删除数据的时候，先删除子表，再删除父表。添加数据的时候，先添加父表，再添加子表。创建表的时候，先创建父表，再创建子表。删除表的时候，先删除子表，再删除父表。 1234567891011121314151617181920212223242526272829303132333435363738394041424344t_student中的classno字段引用t_class表中的cno字段，此时t_student表叫做子表，t_class表叫做父表。 drop table if exists t_student; drop table if exists t_class; create table t_class( cno int primary key, cname varchar(255) ); create table t_student( sno int primary key, sname varchar(255), classno int, foreign key(classno) references t_class(cno) ); insert into t_class values(101,&#39;高一一班&#39;); insert into t_class values(102,&#39;高一二班&#39;); insert into t_student values(1,&#39;zs&#39;,101); insert into t_student values(2,&#39;ls&#39;,102); insert into t_student values(3,&#39;ww&#39;,101); insert into t_student values(4,&#39;jack&#39;,101); insert into t_student values(5,&#39;rose&#39;,102); &#x2F;&#x2F;错误插入，因为t_class中的cno没有103这个数据，所以t_student中的classno不能插入103。 insert into t_student values(6,&#39;hh&#39;,&#39;103&#39;); mysql&gt; select * from t_class; +-----+----------+ | cno | cname | +-----+----------+ | 101 | 高一一班 | | 102 | 高一二班 | +-----+----------+ mysql&gt; select * from t_student; +-----+-------+---------+ |sno | sname | classno | +-----+-------+---------+ | 1 | zs | 101 | | 2 | ls | 102 | | 3 | ww | 101 | | 4 | jack | 101 | | 5 | rose | 102 | +-----+-------+---------+ 外键字段可以为NULL嘛？ 可以为NULL。 外键字段引用其他表中的某个字段的时候，被引用的字段必须是主键嘛？ 被引用的字段不一定是主键，但至少具有unique约束。 存储引擎（了解）123456完整的建表语句： create table &#96;t_x&#96;( &#96;id&#96; int ) ENGINE &#x3D; InnoDB DEFAULT CHARSET &#x3D; utf8;注意：在MYSQL中，凡是标识符是可以用飘号&#96;&#96;括起来。（最好别用，不通用） 建表的时候可以指定存储引擎，也可以指定字符集。 MYSQL默认使用的存储引擎是InnoDB方式。 默认采用的字符集是UTF8。 什么是存储引擎？ 存储引擎这个名字只有在MYSQL中存在。（Oracle中有对应的机制，但不叫存储引擎。Oracle中没有特殊的名字，就是“表的存储方式”。） MYSQL支持很多存储引擎，每一个存储引擎都对应了一种不同的存储方式，每一个存储引擎都有自己的优缺点，需要在合适的时机选择合适的存储引擎。 查看当前MYSQL支持的存储引擎？1show engines \\G; 常见的存储引擎？MYISAM存储引擎 不支持事务，是MYSQL最常用的存储引擎，但这种引擎不是默认的。 特征：用三个文件表示每个表 格式文件：存储表结构的定义(.frm) 数据文件：存储表行的内容(.MYD) 索引文件：存储表上索引(.MYI) 优点：可被压缩，节省存储空间。并且可以转化为只读表，提高检索效率。 缺点： 不支持事务。 InnoDB存储引擎 优点：支持事务，这种存储引擎数据的安全得到保障。 表的结构存储在.frm文件中。 数据存储在table space这样的表空间中(逻辑概念)，无法被压缩，无法转化成只读。 这种InnoDB引擎在MYSQL数据库崩溃之后提供自动恢复机制。 InnoDB支持级联删除和级联更新。 MEMORY存储引擎（以前叫HEAP存储引擎） 缺点：不支持事务。数据容易丢失，因为所有数据和索引都是存储在内存当中。 优点：查询速度快。 事务（Transaction）什么是事务？ 一个事务是一个完整的业务逻辑单元，不可再分。 比如：银行账户转账，从A账户向B账户转账10000，需要执行两条updata语句：updata t_act set balance = balance - 10000 where actno = ‘act-001’;updata t_act set balance = balance + 10000 where actno = ‘act-002’;以上两条DML语句必须同时成功，或者同时失败，不允许出现一条成功一条失败。 要想保证以上两条DML语句同时成功或同时失败，那么就需要使用数据库的“事务机制”。 假设所有的业务都能使用一条DML语句解决，那么就不需要事务机制，但实际情况不是这样，通常一个事需要多条DML语句共同联合完成。 与事务相关的语句 只有DML语句：insert、delete、update因为这三个语句都是和数据库当中的“数据”相关的。事务的存在是为了保证数据的完整性、安全性。 事务的四大特性：ACID A：原子性：事务是最小的工作单元，不可再分。 B：一致性：事务必须保证多条DML语句同时成功或者同时失败。 C：隔离性：事务A与事务B之间具有隔离。 D：持久性：持久性说的是最终数据必须持久化到硬盘文件中，事务才算成功的结束。 关于事务之间的隔离性 事务隔离性存在隔离级别，理论上隔离级别包括四个 第一级别：读未提交（read uncommitted）：对方事务还没有提交，当前事务可以读取到对方未提交的数据。读未提交存在脏读（Dirty Read）现象，表示读到了脏的数据。 第二级别：读已提交（read committed）：对方事务提交后的数据，我方可以读到。这个隔离级别解决了脏读现象。读已提交存在的问题是：不可重复读。 第三级别：可重复读（repeatable read）：这种隔离级别解决了不可重复读问题。不可重复读存在的问题是：读到的数据都是幻象（幻读）。 第四级别：序列化读/串行化读（serializable）：解决了所有问题。存在的问题：效率低、事务需要排队。 数据库的默认级别 Oracle数据库默认的隔离级别是：读已提交MYSQL数据库默认的隔离级别是：可重复读 关闭事务的自动提交 MYSQL事务默认情况下是自动提交的，只要执行任意一条DML语句则提交一次。 关闭方法：start transaction; 设置事务的隔离级别 set global transaction isolation level read uncommitted; 查看全局隔离级别 set @@global transaction_isolation; 索引什么是索引？有什么用？ 索引就相当于一本书的目录，通过目录可以快速的找到对应的资源。 在数据库方面，查询一张表的时候有两种检索方式：全表扫描、根据索引检索（效率很高） 添加索引是给某一个字段或者某些字段添加索引。 主键和具有unique约束的字段自动会添加索引。根据主键查询效率交稿，尽量根据主键索引。 索引为什么可以提高检索效率呢？ 索引虽然可以提高检索效率，但是不能随意的添加索引，因为索引也是数据库当中的对象，也需要数据库不断的维护，是有维护成本的。比如，表中的数据经常被修改这样不适合添加索引，因为数据一旦修改，索引需要重新排序，进行维护。 举例123 select ename,sal from emp where ename &#x3D; &#39;SMITH&#39;;当ename字段上没有添加索引的时候，以上SQL语句会进行全表扫描，扫描ename字段中所有的值。当ename字段上添加索引的时候，以上SQl语句会根据索引扫描，快速定位。 查看SQL语句的执行计划：加上explain…（MYSQL特有）123456 explain select ename,sal from emp where sal &#x3D; 5000; 从该语句中可以看出此时扫描了14次。给薪资sal字段添加索引： create index emp_sal_index on emp(sal);此时在通过explain语句查看发现只扫描了一次。 创建、删除索引对象？12345创建索引对象： create index 索引名称 on 表名(字段名);删除索引对象： drop index 索引名称 on 表名; 索引底层数据结构 索引底层采用的数据结构是：B+ Tree 通过B Tree缩小扫描范围，底层索引进行了排序、分区，索引会携带数据在表中的“物理地址”。最终通过索引检索到数据之后，获取到关联的物理结构，通过物理地址定位表中的数据，效率是最高的。 123 select ename from emp where ename &#x3D; &#39;SMITH&#39;;通过索引转化成： select ename from emp where 物理地址 &#x3D; XXX; 什么时候考虑给字段添加索引？ 数据量庞大。（根据客户的需求，根据线上的环境） 该字段很少的DML操作。（因为字段进行修改操作，索引需要维护） 该字段经常出现在where子句中。（经常根据哪个字段查询） 索引的分类？ 单一索引：给单个字段添加索引 复合索引：给多个字段联合起来添加1个索引 主键索引：主键上会自动添加索引 唯一索引：有unique约束的字段会自动添加索引 索引什么时候失效？12 select ename from emp where ename like &#39;%A%&#39;;模糊查询时，第一个通配符使用的是%，这时候索引是失效的。 视图（view）什么是视图？ 站在不同的角度去看待数据（同一张表的数据通过不同的角度去看待） 怎么创建、删除视图？ 注意：只要DQL语句才能以视图对象的方式创建出来。 对视图进行增删改查，会影响到原表数据。 可以对视图进行CRUD操作。 1234创建视图： create view myview as select empno,ename from emp;删除视图： drop view myview; 面向视图操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687mysql&gt; select * from emp_bak;+-------+--------+-----------+------+------------+---------+---------+--------+| EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | DEPTNO |+-------+--------+-----------+------+------------+---------+---------+--------+| 7369 | SMITH | CLERK | 7902 | 1980-12-17 | 800.00 | NULL | 20 || 7499 | ALLEN | SALESMAN | 7698 | 1981-02-20 | 1600.00 | 300.00 | 30 || 7521 | WARD | SALESMAN | 7698 | 1981-02-22 | 1250.00 | 500.00 | 30 || 7566 | JONES | MANAGER | 7839 | 1981-04-02 | 2975.00 | NULL | 20 || 7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 | 30 || 7698 | BLAKE | MANAGER | 7839 | 1981-05-01 | 2850.00 | NULL | 30 || 7782 | CLARK | MANAGER | 7839 | 1981-06-09 | 2450.00 | NULL | 10 || 7788 | SCOTT | ANALYST | 7566 | 1987-04-19 | 3000.00 | NULL | 20 || 7839 | KING | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL | 10 || 7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 | 0.00 | 30 || 7876 | ADAMS | CLERK | 7788 | 1987-05-23 | 1100.00 | NULL | 20 || 7900 | JAMES | CLERK | 7698 | 1981-12-03 | 950.00 | NULL | 30 || 7902 | FORD | ANALYST | 7566 | 1981-12-03 | 3000.00 | NULL | 20 || 7934 | MILLER | CLERK | 7782 | 1982-01-23 | 1300.00 | NULL | 10 |+-------+--------+-----------+------+------------+---------+---------+--------+create view myview as select empno,ename,sal from emp_bak;mysql&gt; select * from myview;+-------+--------+---------+| empno | ename | sal |+-------+--------+---------+| 7369 | SMITH | 800.00 || 7499 | ALLEN | 1600.00 || 7521 | WARD | 1250.00 || 7566 | JONES | 2975.00 || 7654 | MARTIN | 1250.00 || 7698 | BLAKE | 2850.00 || 7782 | CLARK | 2450.00 || 7788 | SCOTT | 3000.00 || 7839 | KING | 5000.00 || 7844 | TURNER | 1500.00 || 7876 | ADAMS | 1100.00 || 7900 | JAMES | 950.00 || 7902 | FORD | 3000.00 || 7934 | MILLER | 1300.00 |+-------+--------+---------+通过视图修改原表数据：update myview set ename &#x3D; &#39;hehe&#39;,sal &#x3D; 1 where empno &#x3D; 7369;mysql&gt; select * from myview;+-------+--------+---------+| empno | ename | sal |+-------+--------+---------+| 7369 | hehe | 1.00 || 7499 | ALLEN | 1600.00 || 7521 | WARD | 1250.00 || 7566 | JONES | 2975.00 || 7654 | MARTIN | 1250.00 || 7698 | BLAKE | 2850.00 || 7782 | CLARK | 2450.00 || 7788 | SCOTT | 3000.00 || 7839 | KING | 5000.00 || 7844 | TURNER | 1500.00 || 7876 | ADAMS | 1100.00 || 7900 | JAMES | 950.00 || 7902 | FORD | 3000.00 || 7934 | MILLER | 1300.00 |+-------+--------+---------+此时查询原表emp_bak发现数据变了。mysql&gt; select * from emp_bak;+-------+--------+-----------+------+------------+---------+---------+--------+| EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | DEPTNO |+-------+--------+-----------+------+------------+---------+---------+--------+| 7369 | hehe | CLERK | 7902 | 1980-12-17 | 1.00 | NULL | 20 || 7499 | ALLEN | SALESMAN | 7698 | 1981-02-20 | 1600.00 | 300.00 | 30 || 7521 | WARD | SALESMAN | 7698 | 1981-02-22 | 1250.00 | 500.00 | 30 || 7566 | JONES | MANAGER | 7839 | 1981-04-02 | 2975.00 | NULL | 20 || 7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 | 30 || 7698 | BLAKE | MANAGER | 7839 | 1981-05-01 | 2850.00 | NULL | 30 || 7782 | CLARK | MANAGER | 7839 | 1981-06-09 | 2450.00 | NULL | 10 || 7788 | SCOTT | ANALYST | 7566 | 1987-04-19 | 3000.00 | NULL | 20 || 7839 | KING | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL | 10 || 7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 | 0.00 | 30 || 7876 | ADAMS | CLERK | 7788 | 1987-05-23 | 1100.00 | NULL | 20 || 7900 | JAMES | CLERK | 7698 | 1981-12-03 | 950.00 | NULL | 30 || 7902 | FORD | ANALYST | 7566 | 1981-12-03 | 3000.00 | NULL | 20 || 7934 | MILLER | CLERK | 7782 | 1982-01-23 | 1300.00 | NULL | 10 |+-------+--------+-----------+------+------------+---------+---------+--------+通过视图删除原表数据：delete from myview where empno &#x3D; 7369;这里和上面一样，不在做演示。 视图的作用？ 视图可以隐藏表的实现细节。保密级别较高的系统，数据库只对外提供相关的视图，Java程序员只对视图对象进行CRUD。 DBA命令将数据库当中的数据导出（导出整个库） 在Windows的dos命令窗口执行mysqldump firstsql &gt; D:\\firstsql.sql -uroot -p123456; 导出指定数据库中的指定表 mysqldump firstsql emp &gt; D:\\firstsql.sql -uroot -p123456; 导入数据123create datebase 名字;use 名字;source D:\\firstsql.sql; 数据库设计三范式什么是三范式 设计表的依据。按照这个三范式设计的表不会出现数据元素。 三范式有哪些？ 第一范式：任何一张表都应该有主键，并且每一个字段原子性不可再分。 第二范式：建立在第一范式的基础上，所有非主键字段完全依赖主键，不能产生部分依赖。多对多：三张表，关系表两个外键 第三范式：建立在第二范式的基础之上，所有非主键字段直接依赖主键，不能产生传递依赖。一对多：两张表，多的表加外键 提示：在实际的开发中，以满足客户需求为主，有的时候会拿冗余换执行速度。 一对一怎么设计？ 一对一设计有两种方案：主键共享、外键唯一。","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"}]},{"title":"基数排序","date":"2021-03-31T14:23:41.000Z","path":"2021/03/31/基数排序/","text":"概念1待补充 代码如下主方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import java.util.Scanner;public class Demo &#123; public static void main(String[] args) &#123; int number = 0;//数组B的下标 int k = 1;//看第k位，从（倒数）第一位开始看 int Max = 0;//数组当中最大的数有几位 int count = 0; Scanner sc = new Scanner(System.in); System.out.print(&quot;请输入要排序的数的数量：&quot;); count = sc.nextInt(); int[] arrayA = new int[count]; int[] arrayB = new int[arrayA.length]; System.out.print(&quot;请输入&quot;+count+&quot;个数：&quot;); for(int i = 0;i &lt; count;i++)&#123; arrayA[i] = sc.nextInt(); &#125; //int[] arrayC = new int[arrayA.length]; //求最高位数 for(int i = 0; i &lt;arrayA.length;i++)&#123; int temp = getMax(arrayA[i]); if(temp &gt;= Max)&#123; Max = temp; &#125; &#125; //System.out.println(Max);//最高位数 //打印输出原始数组 System.out.print(&quot;原始素组为:&quot;); for (int i = 0; i &lt; arrayA.length; i++) &#123; System.out.print(arrayA[i]+&quot; &quot;); &#125; System.out.println(); //基数排序 while(k != Max+1)&#123; int p = 0;//判断循环是否结束 for(int i = 0;i &lt;=9 ;i++)&#123;//0~9是第几位的范围 for(int j = 0;j &lt;arrayA.length;j++)&#123; if(getNum(arrayA[j],k) == i)&#123; arrayB[number] = arrayA[j]; number++;//数组B的下标要单独定义，每次赋值后都需要移动到下一个下标 if(number == arrayA.length)&#123; break;//如果数组B已经满了，则提前结束循环 &#125; &#125; &#125; if(number == arrayA.length)&#123;//数组B存满后 number = 0;//重置数组B的下标 //System.out.println(&quot;k:&quot;+k); k++;//看的位数进行移动 /* //将原本的A数组给数组C for (i = 0; i &lt; arrayA.length; i++) &#123; arrayC[i] = arrayA[i]; &#125; */ //将新的数组B重新赋值给arrayA for (i = 0; i &lt; arrayA.length; i++) &#123; arrayA[i] = arrayB[i]; &#125; //打印输出 System.out.print(&quot;第&quot;+(k-1)+&quot;轮输出：&quot;);//因为前面提前k++了，所以应该是k-1轮。 for (i = 0; i &lt; arrayA.length; i++) &#123; System.out.print(arrayA[i]+&quot; &quot;); &#125; System.out.println(); break;//数组B满了后这个循环也要提前结束 &#125; &#125; //错误，不能这么判断，否则若在还没排完前一样的时候会提前结束 //判断数组B、C是否一样，如果一样，则提前结束循环 / *for(int i = 0;i &lt;arrayA.length;i++)&#123; if(arrayA[i] == arrayC[i])&#123; p++;//1+1+1+1=arrayA.length &#125; &#125; if(p == arrayA.length)&#123; break; &#125; */ &#125; &#125; 方法1：给定一个数num，返回该数的倒数第k个数，例如 num = 231, k = 2,则返回 3123456789101112public static int getNum(int num, int k) &#123; int count = 0; while(k != 0) &#123; count = num % 10; num = num / 10; /* if(num == 0)&#123; break; &#125;*/ k--; &#125; return count;&#125; 方法2：得到一个数有几位123456789 public static int getMax(int array)&#123; int count = 0;//计数器 while (array != 0)&#123; array = array/10; count++; &#125; return count; &#125;&#125; 总结121、基数排序的原理比较简单，但是代码实现起来比较复杂。2、","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"Java学习记录","date":"2021-03-24T06:45:00.000Z","path":"2021/03/24/Java学习记录/","text":"算法设计与分析实验一第一题题目12345678910给定一个正整数，编写程序计算有多少对质数的和等于输入的这个正整数，并输出结果。输入值小于1000。如，输入为10, 程序应该输出结果为2。（共有两对质数的和为10，分别为(5, 5) , (3, 7)）。输入输入一个整数n( 3≤n&lt;1000)。输出输出对数。样例输入10样例输出2 举例说明123410 【3,7】、【5,5】 212 【1,11】、【5,7】 215 【2,13】 120 【1,19】、【3,17】、【7,13】 3 分析12341、写一个方法来判断一个数是不是素数2、从头开始遍历，判断每一个数是否满足条件 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package study01;import java.util.Scanner;public class demo01 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int num = sc.nextInt(); //键盘获取输入的num值 int count = 0; //定义一个count，用来记录最后有几个质数对 int a = 1;//定义两个数，它们的和为num int b = num - a; //循环从1开始到中间那个数，排除了 例如num=10，有【3,7】，【7,3】这样的重复 while( a!= (num/2 + 1) ) &#123; if (sushu ( a ) &amp;&amp; sushu ( b )) &#123; count ++; //如果a,b都是素数，则计数器加一 System.out.println(&quot;[&quot;+a+&quot;,&quot;+b+&quot;] &quot;); &#125; a++; //循环一次后a++,b--，进行下次循环,满足条件后跳出循环 b--; //System.out.println(a+&quot; &quot;+b); &#125; System.out.println(count); //输出结果 &#125; //素数：除了1和它本身外不能被其他数整除的数叫做素数。 //判断的方法是从2到num-1，遍历看能不能被整除，如果能被其中的一个整除，则不是素数，如果都不可以整除，那么就不是素数。 //用来判断一个数是否为素数，如果是素数则返回true，如果不是素数则返回false public static boolean sushu(int num) &#123; if (num == 2 ||num == 1) &#123; //如果num刚好为2，则判定直接为素数 return true; &#125; else &#123; for (int i = 2; i &lt; num; i++) &#123; if (num % i == 0) &#123; return false; &#125;else&#123; //这里特别注意一定要讲循环走完一圈才可以出去，否则判断一次后循环就会结束。 if(i==num-1)&#123; return true; //判定i==num-1时才是循环了一圈，所以结束循环 &#125;else continue; //否则跳过此次循环进行下一次循环 &#125; &#125; return false; &#125; &#125;&#125; 总结以及心得1231、循环判断数的时候，为了避免【7，3】、【3,7】这种相同的情况，因此只需要判断到一半的位置即可。2、判断一个数是否为素数的时候，只遍历除了1和这个数本身之外的其他数，能否被自己整除即可。如果可以被整除，那么就不是素数。如果不可以被整除，那么就是素数。注意2是一个特殊情况，需要单独考虑。 第二题题目1234567891011121314151617181920小明想给老师当助教从而得一些补助。老师会给小明一些作业让他去批改，并按批改的作业份数和批改正确率来确定小明的补助费。老师是这么规定的，批改一份作业小明会得到m元，如果该份作业批改完全正确那么会从中扣除k元复查费；如果批改中出现了错误会从中扣除x元当惩罚费用，此时这份作业不再扣除复查费。但是老师觉得小明勤工助学不容易，不想扣过多的费用，于是规定如果有一份作业批改错误扣了x元，那么可以抵消一份批改正确作业的复查费。举例，如果有两份作业，一份批改正确一份批改错误，那么错误的那份小明可以得到m-x元，正确的那份小明可以得到m元，不用扣复查费。最后，你能算出小明一共能得多少补助么?输入第一行四个整数n、m、x、k，n表示小明批改作业的总份数，m、x、k的含义如题面描述，1≤n≤100000，1≤m, x, k≤100，x, k≤m;第二行n个整数，每个整数只有两种可能，0表示该份作业批改错误，1表示该份作业批改正确。输出输出一个整数，表示小明最后一共得到的补助费。样例输入总份数n 批改正确得到的钱 m 惩罚费用x 复查费k4 5 2 11 1 1 0（三正确 一错误） 1 1 1 1 0 0 10-2+20-4样例输出16 24 举例说明121 1 1 1 0 0 24 分析12341、通过Scanner函数来进行数字的输入2、知道题目结果如何计算3、考虑错误题目大于正确题目的特殊情况 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344package study02;import java.util.Scanner;public class demo01 &#123; public static void main(String[] args) &#123; int n, m, x, k; int r = 0;//改正确的题目 int f = 0;//改错误的题目 //总份数n 批改正确得到的钱 m 惩罚费用x 复查费k System.out.print(&quot;请依次输入 总份数n 批改正确得到的钱 m 惩罚费用x 复查费k：&quot;); Scanner sc = new Scanner(System.in);//键盘输入n,m,x,k n = sc.nextInt(); m = sc.nextInt(); x = sc.nextInt(); k = sc.nextInt(); System.out.print(&quot;请输入作业更改情况（正确为1，错误为0,最多输入&quot;+n+&quot;个数）：&quot;); int array[] = new int[n];//定义一个数组，用来记录题目的错误，并统计正确与错误赋值给r,f for(int i = 0; i &lt; n; i++)&#123; array[i] = sc.nextInt(); //System.out.print(array[i]+&quot;\\t&quot;);//输出数组 if(array[i]==1)&#123; r++; &#125;else if(array[i]==0)&#123; f++; &#125;else&#123; System.out.println(&quot;输入错误！&quot;); break; &#125; &#125; //System.out.println(&quot;r=&quot;+r); //System.out.println(&quot;f=&quot;+f); int sum = 0;//总价格 if(r&gt;=f)&#123; //正确题数大于错误题数 sum = n*m - f*x - (r-f)*k; &#125;else&#123; //错误题数大于正确题数，此时（r-f)为负，不能用上面的计算方式，此时不需要考虑复查情况。 sum=n*m - f*x; &#125; System.out.println(&quot;小明得到的钱为&quot; + sum);//输出结果 &#125;&#125; 总结以及心得12341、此题并不难，只需要知道题目的计算方式即可2、通过这题要学会Scanner函数的使用方法，该函数可以通过多次获取做到多次输入给多个数据赋值 注意：如果定义的只有n个数据，那么输入超过n个数的时候，只会获取前n个数据并进行赋值。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]}]