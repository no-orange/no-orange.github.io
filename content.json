[{"title":"MyBatis中SQL映射文件解析","date":"2021-09-09T13:16:00.000Z","path":"2021/09/09/MyBatis中SQL映射文件解析/","text":"xml中各属性的解析（不全，具体看视频或者官方文档） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.orange.dao.EmployeeDao&quot;&gt; &lt;!-- namespace：写dao接口的全类名 --&gt; &lt;!-- 这个文件中能写的所有标签： cache：和缓存有关 cache-ref：和缓存有关 select、update、delete、insert parameterMap：参数map，废弃。原本是来做复杂参数映射 resultMap：结果映射，自定义结果集的封装规则 sql：抽取可重用的sql --&gt; &lt;!-- 现象： 1. 单个参数 基本类型： 取值：#&#123;随便写&#125; 传入POJO 2. 多个参数 public Employee getEmpByIdAndName(Integer id, String empName) 取值：#&#123;参数名&#125;无效 可用：arg0,arg1（参数的索引，从0开始）... 或者param1,param第几个参数paramN）... 原因：只要传入了多个参数，mybatis会自动的将这些参数封装在一个map中 封装时使用的可以就是参数的索引和参数的第几个表示 Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;1&quot;,传入的值);map.put(&quot;2&quot;,传入的值); #&#123;key&#125;就是从这个map中取值 我们可以告诉mybatis，封装参数map的时候使用我们指定的key 用@param(&quot;指定的key&quot;)在参数上 3. 传入了Map 将多个要使用的参数封装到Map中 4. 传入了POJO（JavaBean） 取值：#&#123;POJO的属性名&#125; 扩展：多个参数，自动封装map method(@param(&quot;id&quot;) Integer id, String empName, Employee employee); id -&gt; #&#123;id&#125; empName -&gt; #&#123;param2&#125; employee中的email -&gt; #&#123;param3.email&#125; 无论传入什么样的参数都需要正确的取出！ --&gt; &lt;!-- public Employee getEmpById(Integer id) --&gt; &lt;select id=&quot;getEmpById&quot; resultType=&quot;com.orange.bean.Employee&quot;&gt; select * from t_employee where id = #&#123;id&#125; &lt;/select&gt; &lt;!-- public Employee getEmpByIdAndName(Integer id, String empName) --&gt; &lt;select id=&quot;getEmpByIdAndName&quot; resultType=&quot;com.orange.bean.Employee&quot;&gt; select * from t_employee where id = #&#123;arg0&#125; and empname = #&#123;arg1&#125; &lt;/select&gt; &lt;!-- public int updateEmployee(Employee employee) --&gt; &lt;update id=&quot;updateEmployee&quot;&gt; update t_employee set empname = #&#123;empName&#125;, gender = #&#123;gender&#125;, email = #&#123;email&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;!-- public boolean deleteEmployee(Integer id) --&gt; &lt;delete id=&quot;deleteEmployee&quot;&gt; delete from t_employee where id = #&#123;id&#125; &lt;/delete&gt; &lt;!-- public int insertEmployee(Employee employee) --&gt; &lt;!-- 让MyBatis自动的将自增id赋值给传入的employee对象的id属性 useGeneratedKeys=&quot;true&quot; keyProperty=&quot;&quot;：将刚才自增的id封装给哪个属性 --&gt; &lt;insert id=&quot;insertEmployee&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into t_employee(empname, gender, email, login_account) values(#&#123;empName&#125;, #&#123;gender&#125;, #&#123;email&#125;, #&#123;loginAccount&#125;) &lt;/insert&gt; &lt;!-- public int insertEmployee2(Employee employee) --&gt; &lt;insert id=&quot;insertEmployee2&quot;&gt; /* order=&quot;BEFORE&quot;：之前 在核心sql语句之前运行一个查询sql查到id，将查到的id赋值给JavaBean的哪个属性 */ &lt;selectKey order=&quot;BEFORE&quot; keyProperty=&quot;id&quot; resultType=&quot;integer&quot;&gt; select max(id)+2 from t_employee; &lt;/selectKey&gt; insert into t_employee(id, empname, gender, email, login_account) values(#&#123;id&#125;, #&#123;empName&#125;, #&#123;gender&#125;, #&#123;email&#125;, #&#123;loginAccount&#125;) &lt;/insert&gt;&lt;/mapper&gt;","categories":[],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://example.com/tags/MyBatis/"}]},{"title":"MyBatis的全局配置文件解析","date":"2021-09-09T06:52:29.000Z","path":"2021/09/09/MyBatis的全局配置文件解析/","text":"properties属性 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!-- mybatis的全局配置文件，指定mybatis如何正确的运行，比如连向哪个数据库 --&gt;&lt;configuration&gt; &lt;!-- 1. 和Spring的context:property-placeholder；引用外部配置文件 --&gt; &lt;!-- resource：从类路径下开始引用 url：引用磁盘路径或者网络路径的资源 --&gt; &lt;properties resource=&quot;dbconfig.properties&quot;/&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!-- 配置连接池 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- $&#123;&#125;：取出配置文件中的值 --&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/configuration&gt; settings设置123456789101112131415161718192021222324252627282930&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!-- mybatis的全局配置文件，指定mybatis如何正确的运行，比如连向哪个数据库 --&gt;&lt;configuration&gt; &lt;!-- 2. 这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。--&gt; &lt;settings&gt; &lt;!-- name：配置项的key value：配置项的值 --&gt; &lt;!-- mapUnderscoreToCamelCase： 是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。 bean：loginAccount 数据库：login_account 我们数据库中的字段是login_account，bean中的字段是loginAccount 默认不开启我需要在查询的时候重命名才能查到，开启后MyBatis会帮我们自动映射 --&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;!-- 开启延迟加载 --&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;!-- 开启属性按需加载 --&gt; &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt; &lt;/settings&gt;&lt;/configuration&gt; typeAliases类型别名12345678910111213141516 &lt;!-- 3. 类型别名：为常用的类型（JavaBean）起别名 --&gt; &lt;typeAliases&gt; &lt;!-- typeAlias：就是为一个JavaBean起别名，别名默认就是类名（不区分大小写），配置文件中就可以用别名了 alias：指定一个别名 --&gt;&lt;!-- &lt;typeAlias type=&quot;com.orange.bean.Employee&quot; alias=&quot;emp&quot;/&gt;--&gt; &lt;!-- 批量起别名 name：指定包名，默认别名就是类名（大小写不区分） @Alias(value = &quot;emp&quot;)：通过在JavaBean上写注解单独指定一个别名 --&gt; &lt;package name=&quot;com.orange.bean&quot;/&gt; &lt;!-- 推荐我们就用全类名 --&gt; &lt;/typeAliases&gt; typeHandlers类型处理器12345 &lt;!-- 4. 类型处理器 --&gt;&lt;typeHandlers&gt; &lt;!-- 自定义好的类型处理器就在这进行配置 --&gt; &lt;typeHandler handler=&quot;&quot;/&gt;&lt;/typeHandlers&gt; environments环境配置123456789101112131415161718192021222324252627282930313233&lt;!-- 5. environments配置所有环境 environment：配置一个具体的环境，都需要一个事务管理器和一个数据源 transactionManager： dataSource： 后来数据源和事务管理都是Spring来做 --&gt;&lt;!-- default：默认使用哪个环境 --&gt;&lt;environments default=&quot;development&quot;&gt; &lt;!-- id：当前环境的唯一标识 --&gt; &lt;environment id=&quot;testEnv&quot;&gt; &lt;transactionManager type=&quot;&quot;/&gt; &lt;dataSource type=&quot;&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;!-- 连192.168.10.165 --&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://192.168.10.165:3306/mybatis_test?characterEncoding=utf-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!-- 配置连接池 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- $&#123;&#125;：取出配置文件中的值 --&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; databaseIdProvider数据库厂商标识1234567891011&lt;!-- 6. mybatis用来考虑数据库移植性的 --&gt;&lt;databaseIdProvider type=&quot;DB_VENDOR&quot;&gt; &lt;!-- name：数据库厂商标识 value：给这个标识起一个名字 MySQL、Oracle、SQL Server... --&gt; &lt;property name=&quot;MySql&quot; value=&quot;mysql&quot;/&gt; &lt;property name=&quot;SQL Server&quot; value=&quot;sqlerver&quot;/&gt; &lt;property name=&quot;Oracle&quot; value=&quot;oracle&quot;/&gt;&lt;/databaseIdProvider&gt; 12345678910111213141516&lt;!-- 在dao.xml中进行选择 --&gt;&lt;!-- 默认这个查询时不区分环境的 --&gt;&lt;select id=&quot;getEmpById&quot; resultType=&quot;emp&quot;&gt; /* sql语句后面不要写分号 */ select * from t_employee where id = #&#123;id&#125;&lt;/select&gt;&lt;!-- 如果能精确匹配就精确，不能就用模糊的 --&gt;&lt;select id=&quot;getEmpById&quot; resultType=&quot;emp&quot; databaseId=&quot;mysql&quot;&gt; /* sql语句后面不要写分号 */ select * from t_employee where id = #&#123;id&#125;&lt;/select&gt;&lt;select id=&quot;getEmpById&quot; resultType=&quot;emp&quot; databaseId=&quot;oracle&quot;&gt; /* sql语句后面不要写分号 */ select * from t_employee where id = #&#123;id&#125;&lt;/select&gt; mappers映射器123456789101112131415 &lt;!-- 7. 写好的SQL映射文件需要使用mappers注册进来 --&gt; &lt;!-- 引入我们自己编写的每一个接口的实现文件 --&gt; &lt;mappers&gt; &lt;!-- resource：在类路径下找sql映射文件 url：可以从磁盘或者网络路径中引用 class：直接引用接口的全类名 可以将xml放在和dao接口同目录下，而且文件名和接口名一致 class的另一种用法 配合使用：重要的dao可以写配置，简单的dao就直接标注解 --&gt;&lt;!-- &lt;mapper class=&quot;com.orange.dao.EmployeeDao&quot;/&gt;--&gt; &lt;mapper class=&quot;com.orange.dao.EmployeeDaoAnnotation&quot;/&gt; &lt;mapper resource=&quot;EmployeeDao.xml&quot;/&gt; &lt;/mappers&gt;","categories":[],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://example.com/tags/MyBatis/"}]},{"title":"Git的初始化提交及相关操作","date":"2021-09-08T02:49:37.000Z","path":"2021/09/08/Git的初始化提交及相关操作/","text":"第一次提交到远程仓库（以Gitee为例）步骤git bash here 创建本地仓库，在我们的仓库文件夹中右击git bash here git init 进行项目初始化，此时文件夹内多了一个隐藏的.git文件夹 复制文件 将我们的项目复制到仓库文件夹（也可在第一步的时候直接在项目文件夹进行初始化） git add . 将所有的内容添加到待提交中 git status 查看提交的状态 git commit -m “提交日志” 将项目提交到本地仓库 git remote add origin 仓库的HTTPS地址 设置提交的是哪个仓库 git push -u origin master 本地库推送到远程仓库","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"}]},{"title":"SpringMVC自定义类型转换器","date":"2021-09-07T06:07:54.000Z","path":"2021/09/07/SpringMVC自定义类型转换器/","text":"如何自定义类型转换器？ 1. 写一个类实现Converter&lt;S, T&gt;接口12345678910111213141516171819202122232425262728293031/* Converter有两个泛型 S：Source T：Target 将S转为T */public class MyStringToEmployeeComponent implements Converter&lt;String, Employee&gt; &#123; @Autowired DepartmentDao departmentDao; Employee employee = new Employee(); /** * 自定义的转化规则 * empAdmin-admin@qqcom-1-101转为Employee对象 * @param s 原对象empAdmin-admin@qqcom-1-101 * @return 返回转化后的Employee对象 */ @Override public Employee convert(String s) &#123; if(s.contains(&quot;-&quot;))&#123; String[] split = s.split(&quot;-&quot;); employee.setLastName(split[0]); employee.setEmail(split[1]); employee.setGender(Integer.parseInt(split[2])); employee.setDepartment(departmentDao.getDepartment(Integer.parseInt(split[3]))); &#125; return employee; &#125;&#125; 2. 在applicationContext.xml中配置相关信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!-- 一部分代码不全 --&gt;&lt;!-- 告诉SpringMVC别用默认的ConversionService，而用我自定义的 以后写自定义类型转换器配置的时候使用 FormattingConversionServiceFactoryBean来注册 这样既有类型转换还有格式化功能--&gt;&lt;bean id=&quot;formattingConversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt; &lt;!-- converters转化器中添加我们自定义的类型转换器 --&gt; &lt;property name=&quot;converters&quot;&gt; &lt;set&gt; &lt;!-- 我们写的那个类的位置 --&gt; &lt;bean class=&quot;com.orange.component.MyStringToEmployeeComponent&quot;/&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 告诉SpringMVC使用我们自己的转化组件 --&gt;&lt;mvc:annotation-driven conversion-service=&quot;formattingConversionService&quot;/&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!-- 只要请求不好使就召唤 &lt;mvc:annotation-driven/&gt; &lt;mvc:annotation-driven/&gt; &lt;mvc:default-servlet-handler/&gt; 1. 都没写 handlerMappings: BeanNameUrlHandlerMapping中 handlerMap中为空： 静态资源（.html，.js，.img等等）无法访问 DefaultAnnotationHandlerMapping中 handlerMap有每一个资源的映射信息： 动态资源（@RequestMapping映射的资源）可以访问 handlerAdapters: HttpRequestHandlerAdapter SimpleControllerHandlerAdapter AnnotationMethodHandlerAdapter（过时的）: 帮我们执行目标方法 2. 只写了&lt;mvc:default-servlet-handler/&gt; handlerMappings: BeanNameUrlHandlerMapping中： handlerMap：空 SimpleUrlHandlerMapping中 handlerMap：&#123;/**=DefaultServletHttpRequsetHandler&#125;，所有请求都交个Tomcat来处理： 静态资源可以访问 无DefaultAnnotationHandlerMapping： 动态资源不可以访问 handlerAdapters: HttpRequestHandlerAdapter SimpleControllerHandlerAdapter 无AnnotationMethodHandlerAdapter 3. 只写了&lt;mvc:annotation-driven/&gt; 动态资源可以访问 静态资源不可以访问 4. 两个都写 handlerMappings: RequestMappingHandlerMapping: handlerMethods:保存了每一个请求用哪个方法进行处理 动态资源可以访问 BeanNameUrlHandlerMapping SimpleUrlHandlerMapping：将请求直接交给Tomcat 静态资源可以访问 handlerAdapters: HttpRequestHandlerAdapter SimpleControllerHandlerAdapter RequestMappingHandlerAdapter --&gt;","categories":[],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://example.com/tags/SpringMVC/"}]},{"title":"SpringMVC项目初始化","date":"2021-09-05T06:07:17.000Z","path":"2021/09/05/SpringMVC项目初始化/","text":"web.xml中1. 写DispatcherServlet1将&lt;servlet-mapping&gt;中的&lt;url-pattern&gt;改为/ 2. 配置字符编码过滤器（一定要放在所有filter之前）12345678910111213141516&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 3. 支持Rest风格转换的filter123456789&lt;!-- 支持Rest风格转换的filter --&gt;&lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 在applicationContext.xml1. 写包扫描和前置组件12345678&lt;!-- 注解驱动 SpringMVC可以保证动态请求和静态请求都能访问 --&gt;&lt;mvc:annotation-driven/&gt;&lt;!-- 告诉SpringMVC自己映射的请求就自己处理，不能处理的请求直接交给Tomcat --&gt;&lt;mvc:default-servlet-handler/&gt;&lt;context:component-scan base-package=&quot;com.orange&quot;/&gt; 2. 写返回的视图解析器1234&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt;","categories":[],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://example.com/tags/SpringMVC/"}]},{"title":"Spring的REST问题总结","date":"2021-09-02T06:59:09.000Z","path":"2021/09/02/Spring的REST问题总结/","text":"如何初始化设置Rest风格123456789101112131415161718192021222324252627/*发起图书的增删改查，使用Rest风格的URL地址请求URL 请求方式 表示含义/book/1 GET 查询1号图书/book/1 POST 添加1号图书/book/1 DELETE 删除1号图书/book/1 PUT 更新1号图书如何从页面发起PUT、DELETE请求？ Spring提供了对Rest风格的支持 1. SpringMVC中有一个Filter，它可以把普通的请求转化为规定形式的请求 1.1 在web.xml中配置Filter &lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 2. 如何发起其他形式请求？ 按照一下要求 2.1 创建一个POST类型的表单 2.2 表单项中携带一个_method的参数 2.3 这个_method的值就是DELETE或者PUT*/ 常见问题jsp页面被拦截 在DELETE和PUT请求中跳转页面不成功，而且报405 JSP 只允许 GET、POST 或 HEAD。Jasper 还允许 OPTIONS错误 一般发送在高版本的Tomcat服务器中 解决方案：在跳转的 jsp 头中添加 isErrorPage=”true” 即可解决 获取中文数据乱码 从页面中获取中文数据的时候，打印出来的数据时乱码 解决方案：在web.xml中添加filter过滤器同时修改Tomcat配置中的server.xml ```xml CharacterEncodingFilter org.springframework.web.filter.CharacterEncodingFilter encoding UTF-8 forceEncoding true CharacterEncodingFilter /* 12345678910111213142. &#96;&#96;&#96;java &#x2F;* 提交的数据可能有乱码： 请求乱码： GET请求：改Tomcat下conf文件下的server.xml &lt;Connector URIEncoding&#x3D;&quot;UTF-8&quot; port&#x3D;&quot;8080&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot; connectionTimeout&#x3D;&quot;20000&quot; redirectPort&#x3D;&quot;8443&quot; &#x2F;&gt; POST请求： 在第一次获取请求参数前设置 request.setCharacterEncoding(&quot;UTF-8&quot;) 自己写一个filter,SpringMVC有这个filter 响应乱码： response.setContentType(&quot;text&#x2F;html;charset&#x3D;utf-8&quot;) *&#x2F;","categories":[],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://example.com/tags/SpringMVC/"}]},{"title":"SpringMVC配置的一些问题","date":"2021-09-01T07:46:17.000Z","path":"2021/09/01/SpringMVC配置的一些问题/","text":"在idea中生成SpringMVC项目，系统会自动生成几个配置文件 配置文件的有关解释（可能有错误的地方） applicationContext.xml12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 需要加入这个才能识别controller层 --&gt; &lt;mvc:annotation-driven/&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 扫描所有组件 --&gt; &lt;context:component-scan base-package=&quot;com.orange&quot;/&gt; &lt;!-- 配置一个视图解析器，能帮我们拼接页面地址 --&gt; &lt;!-- 这里是拼接一个页面的地址 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;1 &lt;/bean&gt;&lt;/beans&gt; web.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!-- SpringMVC思想是有一个前段控制器能拦截所有请求，并智能派发 这个前段控制器是一个servlet，应该在web.xml中配置这个servlet来拦截所有请求 --&gt; &lt;context-param&gt; &lt;!-- contextConfigLocation：指定SpringMVC配置文件位置 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- servlet启动加载，servlet原本是第一次访问创建对象 load-on-startup：服务器启动的时候创建对象；值越小优先级越高，越先创建对象 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;!-- 视频中 / 与 /* 的区别 /：会拦截所有请求，但是不会拦截*.jsp，能保证jsp访问正常 /*：范围更大，会拦截到*.jsp这些请求，但一旦拦截jsp页面就不能显示了 处理*.jsp是Tomcat做的事；所有项目的小web.xml都是继承于大web.xml DefaultServlet是Tomcat中处理静态资源的： 除了jsp和servlet外剩下的都是静态资源 index.html：静态资源，Tomcat就会在服务器下找到这个资源并返回 我们前端控制器的/禁用了Tomcat服务器中的DefaultServlet 1. 服务器的大web.xml中有一个DefaultServlet是url-pattern=/ 2. 我们的配置中前端服务器url-pattern=/ 静态资源会来到DispatcherServlet（前端控制器）看哪个方法的RequestMapping是这个index.html 3. 为什么jsp可以访问？ 因为我们没有覆盖服务器中的JspServlet的配置 4. /* 直接拦截所有请求；我们写/也是为了迎合后来的Rest风格的URL地址 初始的是 *.form ，会到时无法进入controller层 具体原因：*.form表示拦截所有以form结尾的请求 --&gt; &lt;url-pattern&gt;*.form&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; File is included in 4 contexts的解决方案 Project Structure—-&gt;Modules—-&gt;Spring—-&gt;Spring Application Context—–&gt;点减号—-&gt;yes—-&gt;Apply—-&gt;OK 关于controller层不生效的问题 需要将web.xml中的 &lt;url-pattern&gt;*.form&lt;/url-pattern&gt; 改为 &lt;url-pattern&gt;/&lt;/url-pattern&gt; 在applicationContext.xml中添加如下代码 123456&lt;!-- 需要加入这个才能识别controller层 --&gt; &lt;mvc:annotation-driven/&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 扫描所有组件 --&gt; &lt;context:component-scan base-package=&quot;com.orange&quot;/&gt;","categories":[],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://example.com/tags/SpringMVC/"}]},{"title":"数据结构绪论","date":"2021-06-21T13:57:53.000Z","path":"2021/06/21/数据结构/","text":"基本概念数据 ：对客观事务的符号表示，在计算机科学中是指所有能输入到计算机中并被计算机程序所处理的符号的总称，它是计算机程序加工的“原料”。 数据元素：数据的基本单位，数据中的个体。 数据对象：由性质相同的数据元素构成得集合。 数据结构：数据对象上加上数据元素之间的关系。 逻辑结构：数据结构的种类 集合结构 线性结构 树形结构 图状结构 存储结构：数据结构映射到内存 顺序结构 链式结构 索引结构 散列结构 抽象数据类型：数据结构加上操作 数据对象 数据关系 基本操作 抽象数据类型（ADT） 抽象数据类型（Abstract Data Type）：是指一个数学模型以及定义在此数学模型上的一组操作。 形式定义用三元组（D，S，P）表示： D：数据对象 S：D上的关系集 P：对D的基本操作集 定义格式123456789101112131415161718192021ADT 抽象数据类型名&#123; 数据对象：&lt; 数据对象的定义 &gt; 数据关系：&lt; 数据关系的定义 &gt; 基本操作：&lt; 基本操作的定义 &gt;&#125; ADT 抽象数据类型名 /*数据对象、数据关系的定义用伪代码描述 基本操作的定义格式为： - 基本操作名（参数表） 参数表： 赋值参数 只为操作提供输入值 引用参数 以&amp;打头，除可提供输入值外，还将返回操作结果 - 初始条件：&lt; 初始条件描述 &gt; 初始条件： 描述操作执行之前数据结构和参数应满足的条件，若不满足，则操作失败，并返回相应出错信息。若初始条件为空，则省略之。 - 操作结果：&lt; 操作结果描述 &gt; 操作结果： 说明操作正常完成之后，数据结构的变化状况和应返回的结果。*/ 定义举例Circle的定义1234567891011121314ADT Circle&#123; 数据对象：D = &#123;r, x, y | r, x, y均为实数&#125; 数据关系：R = &#123;&lt;r, x, y&gt; | r表示半径，&lt;x, y&gt;是圆心坐标 基本操作： Circle(&amp;C, r, x, y) 操作结果：构造一个圆 double Area(C) 初始条件：圆已存在 操作结果：计算面积 double Circumference(C) 初始条件：圆已存在 操作结果：计算周长 ......&#125; ADT Circle 复数的定义1234567891011121314151617181920ADT Complex&#123; D = &#123;r1, r2 | r1, r2都是实数&#125; S = &#123;&lt;r1, r2&gt; | r1是实部，r2是虚部&#125; Assign(&amp;C, v1, v2) 初始条件：空的复数C已存在 操作结果：构造复数C，r1,r2分别被赋以参数v1,v2的值 Destory(&amp;C) 初始条件：复数C已存在 操作结果：复数C被销毁 GetReal(Z, &amp;realPart) 初始条件：复数已存在 操作结果：用realPart返回复数Z的实部值 GetImag(Z, &amp;ImagPart) 初始条件：复数已存在 操作结果：用ImagPart返回复数Z的虚部值 Add(z1, z2, &amp;sum) 初始条件：z1,z2是复数 操作结果：sum返回两个复数z1,z2的和 ......&#125; ADT Complex 算法与算法分析算法的定义对特定问题求解方法和步骤的一种描述，它是指令的有限序列。其中每个指令表示一个或多个操作。 算法的描述 自然语言：中文、英文… 流程图：传统流程图、NS流程图 伪代码：类语言：类C语言 程序代码：C语言程序、Java语言程序… 算法与程序算法：是解决问题的一种方法或一个过程，考虑如何将输入转换成输出，一个问题可以有多种算法 程序：用某种程序设计语言对算法的具体表现 程序 = 数据结构 + 算法 算法的特性 有穷性：一个算法必须总是在执行有穷步之后结束，且每一步都在有穷时间内完成 确定性：算法中的每一条指令必须有确切的含义，没有二义性，在任何条件下，只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出。 可行性：算法是可执行的，算法描述的操作可以通过已近实现的基本操作执行有限次来实现 输入：一个算法有零个或多个输入 输出：一个算法有一个或多个输出 算法设计的要求 正确性 可读性 健壮性 高效性 算法的效率 时间效率：算法所耗费的时间 空间效率：算法执行过程中所消耗的存储空间 算法时间效率的度量算法时间效率可以依据该算法编制的程序在计算机上执行所消耗的时间来度量。 度量一个程序的执行时间通常有两种方法： 事后统计 将算法实现，测算其时间和空间开销 缺点：编写程序实现算法将花费较多的时间和精力；所得实验结果依赖于计算机的软硬件等环境因素，掩盖算法本身的优劣 事前分析 对算法所消耗资源的一种估算方法 算法运行时间 = 一个简单操作所需的时间 x 简单操作次数 算法运行时间 = ∑ 每条语句频度 x 该语句执行一次所需的时间","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Timer()计时器","date":"2021-06-13T07:08:08.000Z","path":"2021/06/13/Timer-计时器/","text":"介绍 当我们需要一些周期性的操作的时候，例如每个1秒钟需要执行一次操作，这时候就可以使用Timer()计时器来实现 先使用java.util.Timer工具类 Timer是后台使用线性执行任务，可以安排任务执行一次或周期执行。本质上就是一个线程，定时调度它的TimerTask 再调用java.util.TimerTask TimerTask是一个抽象类，它的子类由Timer安排一次执行或者周期执行。本质上就是一个拥有run方法的类，需要定时执行的代码放在run方法体中。 调用方法及用法12345678Timer timer = new Timer();//注意：javax.swing中也有一个Timer类，不要导错包TimerTask task = new TimerTask()&#123; public void run()&#123; //...每次需要执行的代码放在这里 &#125;&#125;; 123456789101112131415//常用调度task的方法：//time为Data类型，在指定时间执行一次timer.schedule(task, Date time);//delay为long类型，从现在起过delay毫秒执行一次timer.schedule(task, long delay);//firstTime为Date类型，period为long类型//从firstTime时刻开始，每个period毫秒执行一次timer.schedule(task, Date firsttime, long period);//delay为long，period为long//从现在起过delay毫秒以后，每个period毫秒执行一次timer.schedule(task, long delay, long period); schedule()与scheduleAtFixedRate()的区别 schedule()方法更注重保持间隔时间的稳定：保障每隔period时间可调用一次。 scheduleAtFixedRate()方法更注重保持执行频率的稳定：保障多次调用的频率趋近于period时间，如果某一次调用时间大于period，下一次就会尽量小于period，以保障频率接近于period。 举例说明在控制台实时输出当前时间12345678910111213141516package com.timertest;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.TimerTask;public class TimeUpdate extends TimerTask &#123; @Override public void run() &#123; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); String nowtime = sdf.format(Calendar.getInstance().getTime()); System.out.println(nowtime); &#125; &#125; 123456789101112131415package com.timertest;import java.util.Date;import java.util.Timer;public class DemoTest &#123; public static void main(String[] args) &#123; Timer timer = new Timer(); Date time = new Date(); timer.schedule(new TimeUpdate(), time, 1000); &#125; &#125; 1//此时在控制台会持续输出当前的时间。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java8的其他新特性","date":"2021-05-13T02:49:06.000Z","path":"2021/05/13/Java8的其他新特性/","text":"Lambda表达式Lambda表达式的使用举例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import org.junit.Test;import java.util.Comparator;/** * Lambda表达式的使用举例 * */public class LambdaTest &#123; @Test public void test1()&#123; Runnable r1 = new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;我爱北京天安门&quot;); &#125; &#125;; r1.run(); System.out.println(&quot;***********************&quot;); Runnable r2 = () -&gt; System.out.println(&quot;我爱北京故宫&quot;); r2.run(); &#125; @Test public void test2()&#123; Comparator&lt;Integer&gt; com1 = new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return Integer.compare(o1,o2); &#125; &#125;; int compare1 = com1.compare(12,21); System.out.println(compare1); System.out.println(&quot;***********************&quot;); //Lambda表达式的写法 Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; Integer.compare(o1,o2); int compare2 = com2.compare(32,21); System.out.println(compare2); System.out.println(&quot;***********************&quot;); //方法引用 Comparator&lt;Integer&gt; com3 = Integer :: compare; int compare3 = com3.compare(32,21); System.out.println(compare3); &#125;&#125; Lambda表达式的使用 举例： (o1,o2) -&gt; Integer.compare(o1,o2); 格式： -&gt; :lambda操作符 或 箭头操作符-&gt;左边：lambda形参列表 （其实就是接口中的抽象方法的形参列表）-&gt;右边：lambda体 （其实就是重写的抽象方法的方法体） Lambda表达式的使用：（分为6种情况介绍）总结：-&gt;左边：lambda形参列表的参数类型可以省略(类型推断)；如果lambda形参列表只有一个参数，其一对()也可以省略-&gt;右边：lambda体应该使用一对{}包裹；如果lambda体只有一条执行语句（可能是return语句），省略这一对{}和return关键字 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154import org.junit.Test;import java.util.ArrayList;import java.util.Comparator;import java.util.function.Consumer;public class LambdaTest1 &#123; //语法格式一：无参，无返回值 @Test public void test1()&#123; Runnable r1 = new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;我爱北京天安门&quot;); &#125; &#125;; r1.run(); System.out.println(&quot;***********************&quot;); Runnable r2 = () -&gt; &#123; System.out.println(&quot;我爱北京故宫&quot;); &#125;; r2.run(); &#125; //语法格式二：Lambda 需要一个参数，但是没有返回值。 @Test public void test2()&#123; Consumer&lt;String&gt; con = new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) &#123; System.out.println(s); &#125; &#125;; con.accept(&quot;谎言和誓言的区别是什么？&quot;); System.out.println(&quot;*******************&quot;); Consumer&lt;String&gt; con1 = (String s) -&gt; &#123; System.out.println(s); &#125;; con1.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;); &#125; //语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断” @Test public void test3()&#123; Consumer&lt;String&gt; con1 = (String s) -&gt; &#123; System.out.println(s); &#125;; con1.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;); System.out.println(&quot;*******************&quot;); Consumer&lt;String&gt; con2 = (s) -&gt; &#123; System.out.println(s); &#125;; con2.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;); &#125; @Test public void test4()&#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();//类型推断 int[] arr = &#123;1,2,3&#125;;//类型推断 &#125; //语法格式四：Lambda 若只需要一个参数时，参数的小括号可以省略 @Test public void test5()&#123; Consumer&lt;String&gt; con1 = (s) -&gt; &#123; System.out.println(s); &#125;; con1.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;); System.out.println(&quot;*******************&quot;); Consumer&lt;String&gt; con2 = s -&gt; &#123; System.out.println(s); &#125;; con2.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;); &#125; //语法格式五：Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值 @Test public void test6()&#123; Comparator&lt;Integer&gt; com1 = new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; System.out.println(o1); System.out.println(o2); return o1.compareTo(o2); &#125; &#125;; System.out.println(com1.compare(12,21)); System.out.println(&quot;*****************************&quot;); Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; &#123; System.out.println(o1); System.out.println(o2); return o1.compareTo(o2); &#125;; System.out.println(com2.compare(12,6)); &#125; //语法格式六：当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略 @Test public void test7()&#123; Comparator&lt;Integer&gt; com1 = (o1,o2) -&gt; &#123; return o1.compareTo(o2); &#125;; System.out.println(com1.compare(12,6)); System.out.println(&quot;*****************************&quot;); Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; o1.compareTo(o2); System.out.println(com2.compare(12,21)); &#125; @Test public void test8()&#123; Consumer&lt;String&gt; con1 = s -&gt; &#123; System.out.println(s); &#125;; con1.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;); System.out.println(&quot;*****************************&quot;); Consumer&lt;String&gt; con2 = s -&gt; System.out.println(s); con2.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;); &#125;&#125; Lambda表达式的本质：作为函数式接口的实例 如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。我们可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口。 所以以前用匿名实现类表示的现在都可以用Lambda表达式来写。 函数式(Functional)接口 只包含一个抽象方法的接口，称为函数式接口。 可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口。 Java 内置四大核心函数式接口 函数式接口 参数类型 返回类型 用途 Consumer 消费型接口 T void 对类型为T的对象应用操作，包含方法：void accept(T t) Supplier 供给型接口 无 T 返回类型为T的对象，包含方法：T get() Function&lt;T,R&gt; 函数型接口 T R 对类型为T的对象应用操作，并返回结果。结果是R类型的对象。 包含方法：R apply(T t) Predicate 断定型接口 T boolean 确定类型为T的对象是否满足某约束，并返回boolean 值。 包含方法：boolean test(T t) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import org.junit.Test;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.function.Consumer;import java.util.function.Predicate;/** * java内置的4大核心函数式接口 * * 消费型接口 Consumer&lt;T&gt; void accept(T t) * 供给型接口 Supplier&lt;T&gt; T get() * 函数型接口 Function&lt;T,R&gt; R apply(T t) * 断定型接口 Predicate&lt;T&gt; boolean test(T t) * * */public class LambdaTest2 &#123; @Test public void test1()&#123; happyTime(500, new Consumer&lt;Double&gt;() &#123; @Override public void accept(Double aDouble) &#123; System.out.println(&quot;学习太累了，去天上人间买了瓶矿泉水，价格为：&quot; + aDouble); &#125; &#125;); System.out.println(&quot;********************&quot;); happyTime(400,money -&gt; System.out.println(&quot;学习太累了，去天上人间喝了口水，价格为：&quot; + money)); &#125; public void happyTime(double money, Consumer&lt;Double&gt; con)&#123; con.accept(money); &#125; @Test public void test2()&#123; List&lt;String&gt; list = Arrays.asList(&quot;北京&quot;,&quot;南京&quot;,&quot;天津&quot;,&quot;东京&quot;,&quot;西京&quot;,&quot;普京&quot;); List&lt;String&gt; filterStrs = filterString(list, new Predicate&lt;String&gt;() &#123; @Override public boolean test(String s) &#123; return s.contains(&quot;京&quot;); &#125; &#125;); System.out.println(filterStrs); List&lt;String&gt; filterStrs1 = filterString(list,s -&gt; s.contains(&quot;京&quot;)); System.out.println(filterStrs1); &#125; //根据给定的规则，过滤集合中的字符串。此规则由Predicate的方法决定 public List&lt;String&gt; filterString(List&lt;String&gt; list, Predicate&lt;String&gt; pre)&#123; ArrayList&lt;String&gt; filterList = new ArrayList&lt;&gt;(); for(String s : list)&#123; if(pre.test(s))&#123; filterList.add(s); &#125; &#125; return filterList; &#125;&#125; 方法引用与构造器引用方法引用举例 使用情境：当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！ 方法引用，本质上就是Lambda表达式，而Lambda表达式作为函数式接口的实例。所以方法引用，也是函数式接口的实例。 使用格式： 类(或对象) :: 方法名 具体分为如下的三种情况： 情况1 对象 :: 非静态方法 情况2 类 :: 静态方法 情况3 类 :: 非静态方法 方法引用使用的要求：要求接口中的抽象方法的形参列表和返回值类型与方法引用的方法的形参列表和返回值类型相同！（针对于情况1和情况2） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140import org.junit.Test;import java.io.PrintStream;import java.util.Comparator;import java.util.function.BiPredicate;import java.util.function.Consumer;import java.util.function.Function;import java.util.function.Supplier;/** * 方法引用的使用 * * 1.使用情境：当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！ * * 2.方法引用，本质上就是Lambda表达式，而Lambda表达式作为函数式接口的实例。所以方法引用，也是函数式接口的实例。 * * 3. 使用格式： 类(或对象) :: 方法名 * * 4. 具体分为如下的三种情况： * 情况1 对象 :: 非静态方法 * 情况2 类 :: 静态方法 * 情况3 类 :: 非静态方法 * * 5. 方法引用使用的要求：要求接口中的抽象方法的形参列表和返回值类型与方法引用的方法的形参列表和返回值类型相同！（针对于情况1和情况2） * */public class MethodRefTest &#123; // 情况一：对象 :: 实例方法 //Consumer中的void accept(T t) //PrintStream中的void println(T t) @Test public void test1() &#123; Consumer&lt;String&gt; con1 = str -&gt; System.out.println(str); con1.accept(&quot;北京&quot;); System.out.println(&quot;*******************&quot;); PrintStream ps = System.out; Consumer&lt;String&gt; con2 = ps::println; con2.accept(&quot;beijing&quot;); &#125; //Supplier中的T get() //Employee中的String getName() @Test public void test2() &#123; Employee emp = new Employee(1001,&quot;Tom&quot;,23,5600); Supplier&lt;String&gt; sup1 = () -&gt; emp.getName(); System.out.println(sup1.get()); System.out.println(&quot;*******************&quot;); Supplier&lt;String&gt; sup2 = emp::getName; System.out.println(sup2.get()); &#125; // 情况二：类 :: 静态方法 //Comparator中的int compare(T t1,T t2) //Integer中的int compare(T t1,T t2) @Test public void test3() &#123; Comparator&lt;Integer&gt; com1 = (t1,t2) -&gt; Integer.compare(t1,t2); System.out.println(com1.compare(12,21)); System.out.println(&quot;*******************&quot;); Comparator&lt;Integer&gt; com2 = Integer::compare; System.out.println(com2.compare(12,3)); &#125; //Function中的R apply(T t) //Math中的Long round(Double d) @Test public void test4() &#123; Function&lt;Double,Long&gt; func = new Function&lt;Double, Long&gt;() &#123; @Override public Long apply(Double d) &#123; return Math.round(d); &#125; &#125;; System.out.println(&quot;*******************&quot;); Function&lt;Double,Long&gt; func1 = d -&gt; Math.round(d); System.out.println(func1.apply(12.3)); System.out.println(&quot;*******************&quot;); Function&lt;Double,Long&gt; func2 = Math::round; System.out.println(func2.apply(12.6)); &#125; // 情况三：类 :: 实例方法 (有难度) // Comparator中的int comapre(T t1,T t2) // String中的int t1.compareTo(t2) @Test public void test5() &#123; Comparator&lt;String&gt; com1 = (s1,s2) -&gt; s1.compareTo(s2); System.out.println(com1.compare(&quot;abc&quot;,&quot;abd&quot;)); System.out.println(&quot;*******************&quot;); Comparator&lt;String&gt; com2 = String :: compareTo; System.out.println(com2.compare(&quot;abd&quot;,&quot;abm&quot;)); &#125; //BiPredicate中的boolean test(T t1, T t2); //String中的boolean t1.equals(t2) @Test public void test6() &#123; BiPredicate&lt;String,String&gt; pre1 = (s1,s2) -&gt; s1.equals(s2); System.out.println(pre1.test(&quot;abc&quot;,&quot;abc&quot;)); System.out.println(&quot;*******************&quot;); BiPredicate&lt;String,String&gt; pre2 = String :: equals; System.out.println(pre2.test(&quot;abc&quot;,&quot;abd&quot;)); &#125; // Function中的R apply(T t) // Employee中的String getName(); @Test public void test7() &#123; Employee employee = new Employee(1001, &quot;Jerry&quot;, 23, 6000); Function&lt;Employee,String&gt; func1 = e -&gt; e.getName(); System.out.println(func1.apply(employee)); System.out.println(&quot;*******************&quot;); Function&lt;Employee,String&gt; func2 = Employee::getName; System.out.println(func2.apply(employee)); &#125;&#125; 构造器引用举例 构造器引用 和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。 抽象方法的返回值类型即为构造器所属的类的类型。 数组引用 大家可以把数组看做是一个特殊的类，则写法与构造器引用一致。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import org.junit.Test;import java.util.Arrays;import java.util.function.BiFunction;import java.util.function.Function;import java.util.function.Supplier;/** * 一、构造器引用 * 和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。 * 抽象方法的返回值类型即为构造器所属的类的类型 * * 二、数组引用 * 大家可以把数组看做是一个特殊的类，则写法与构造器引用一致。 * */public class ConstructorRefTest &#123; //构造器引用 //Supplier中的T get() //Employee的空参构造器：Employee() @Test public void test1()&#123; Supplier&lt;Employee&gt; sup = new Supplier&lt;Employee&gt;() &#123; @Override public Employee get() &#123; return new Employee(); &#125; &#125;; System.out.println(&quot;*******************&quot;); Supplier&lt;Employee&gt; sup1 = () -&gt; new Employee(); System.out.println(sup1.get()); System.out.println(&quot;*******************&quot;); Supplier&lt;Employee&gt; sup2 = Employee :: new; System.out.println(sup2.get()); &#125; //Function中的R apply(T t) @Test public void test2()&#123; Function&lt;Integer,Employee&gt; func1 = id -&gt; new Employee(id); Employee employee = func1.apply(1001); System.out.println(employee); System.out.println(&quot;*******************&quot;); Function&lt;Integer,Employee&gt; func2 = Employee :: new; Employee employee1 = func2.apply(1002); System.out.println(employee1); &#125; //BiFunction中的R apply(T t,U u) @Test public void test3()&#123; BiFunction&lt;Integer,String,Employee&gt; func1 = (id,name) -&gt; new Employee(id,name); System.out.println(func1.apply(1001,&quot;Tom&quot;)); System.out.println(&quot;*******************&quot;); BiFunction&lt;Integer,String,Employee&gt; func2 = Employee :: new; System.out.println(func2.apply(1002,&quot;Tom&quot;)); &#125; //数组引用 //Function中的R apply(T t) @Test public void test4()&#123; Function&lt;Integer,String[]&gt; func1 = length -&gt; new String[length]; String[] arr1 = func1.apply(5); System.out.println(Arrays.toString(arr1)); System.out.println(&quot;*******************&quot;); Function&lt;Integer,String[]&gt; func2 = String[] :: new; String[] arr2 = func2.apply(10); System.out.println(Arrays.toString(arr2)); &#125;&#125; 上述举例用于测试的两个类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798//Employee类：public class Employee &#123; private int id; private String name; private int age; private double salary; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125; public Employee() &#123; System.out.println(&quot;Employee().....&quot;); &#125; public Employee(int id) &#123; this.id = id; System.out.println(&quot;Employee(int id).....&quot;); &#125; public Employee(int id, String name) &#123; this.id = id; this.name = name; &#125; public Employee(int id, String name, int age, double salary) &#123; this.id = id; this.name = name; this.age = age; this.salary = salary; &#125; @Override public String toString() &#123; return &quot;Employee&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, salary=&quot; + salary + &#x27;&#125;&#x27;; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Employee employee = (Employee) o; if (id != employee.id) return false; if (age != employee.age) return false; if (Double.compare(employee.salary, salary) != 0) return false; return name != null ? name.equals(employee.name) : employee.name == null; &#125; @Override public int hashCode() &#123; int result; long temp; result = id; result = 31 * result + (name != null ? name.hashCode() : 0); result = 31 * result + age; temp = Double.doubleToLongBits(salary); result = 31 * result + (int) (temp ^ (temp &gt;&gt;&gt; 32)); return result; &#125;&#125; 123456789101112131415161718192021222324252627//EmployeeData类：import java.util.ArrayList;import java.util.List;/** * 提供用于测试的数据 * * */public class EmployeeData &#123; public static List&lt;Employee&gt; getEmployees()&#123; List&lt;Employee&gt; list = new ArrayList&lt;&gt;(); list.add(new Employee(1001, &quot;马化腾&quot;, 34, 6000.38)); list.add(new Employee(1002, &quot;马云&quot;, 12, 9876.12)); list.add(new Employee(1003, &quot;刘强东&quot;, 33, 3000.82)); list.add(new Employee(1004, &quot;雷军&quot;, 26, 7657.37)); list.add(new Employee(1005, &quot;李彦宏&quot;, 65, 5555.32)); list.add(new Employee(1006, &quot;比尔盖茨&quot;, 42, 9500.43)); list.add(new Employee(1007, &quot;任正非&quot;, 26, 4333.32)); list.add(new Employee(1008, &quot;扎克伯格&quot;, 35, 2500.32)); return list; &#125; &#125; 强大的Stream API说明 Stream关注的是对数据的运算，与CPU打交道集合关注的是数据的存储，与内存打交道 Stream 自己不会存储元素。 Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。 Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。 Stream 执行流程 Stream的实例化 一系列的中间操作（过滤、映射、…) 终止操作 说明： 一个中间操作链，对数据源的数据进行处理 一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用 Stream的实例化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import study07.Employee;//前面提到的测试类import study07.EmployeeData;//前面提到的测试类import org.junit.Test;import java.util.Arrays;import java.util.List;import java.util.stream.IntStream;import java.util.stream.Stream;/** * * 测试Stream的实例化 * */public class StreamAPITest &#123; //创建 Stream方式一：通过集合 @Test public void test1()&#123; List&lt;Employee&gt; employees = EmployeeData.getEmployees();// default Stream&lt;E&gt; stream() : 返回一个顺序流 Stream&lt;Employee&gt; stream = employees.stream();// default Stream&lt;E&gt; parallelStream() : 返回一个并行流 Stream&lt;Employee&gt; parallelStream = employees.parallelStream(); &#125; //创建 Stream方式二：通过数组 @Test public void test2()&#123; int[] arr = new int[]&#123;1,2,3,4,5,6&#125;; //调用Arrays类的static &lt;T&gt; Stream&lt;T&gt; stream(T[] array): 返回一个流 IntStream stream = Arrays.stream(arr); Employee e1 = new Employee(1001,&quot;Tom&quot;); Employee e2 = new Employee(1002,&quot;Jerry&quot;); Employee[] arr1 = new Employee[]&#123;e1,e2&#125;; Stream&lt;Employee&gt; stream1 = Arrays.stream(arr1); &#125; //创建 Stream方式三：通过Stream的of() @Test public void test3()&#123; Stream&lt;Integer&gt; stream = Stream.of(1, 2, 3, 4, 5, 6); &#125; //创建 Stream方式四：创建无限流 @Test public void test4()&#123;// 迭代// public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f) //遍历前10个偶数 Stream.iterate(0, t -&gt; t + 2).limit(10).forEach(System.out::println);// 生成// public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s) Stream.generate(Math::random).limit(10).forEach(System.out::println); &#125;&#125; Stream的中间操作筛选与切片1234567891011121314151617181920212223242526272829 @Test public void test1()&#123; List&lt;Employee&gt; list = EmployeeData.getEmployees();// filter(Predicate p)——接收 Lambda ， 从流中排除某些元素。 Stream&lt;Employee&gt; stream = list.stream(); //练习：查询员工表中薪资大于7000的员工信息 stream.filter(e -&gt; e.getSalary() &gt; 7000).forEach(System.out::println); System.out.println();// limit(n)——截断流，使其元素不超过给定数量。 list.stream().limit(3).forEach(System.out::println); System.out.println();// skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补 list.stream().skip(3).forEach(System.out::println); System.out.println();// distinct()——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素 list.add(new Employee(1010,&quot;刘强东&quot;,40,8000)); list.add(new Employee(1010,&quot;刘强东&quot;,41,8000)); list.add(new Employee(1010,&quot;刘强东&quot;,40,8000)); list.add(new Employee(1010,&quot;刘强东&quot;,40,8000)); list.add(new Employee(1010,&quot;刘强东&quot;,40,8000));// System.out.println(list); list.stream().distinct().forEach(System.out::println); &#125; 映射123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 @Test public void test2()&#123;// map(Function f)——接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应用到每个元素上，并将其映射成一个新的元素。 List&lt;String&gt; list = Arrays.asList(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;); list.stream().map(str -&gt; str.toUpperCase()).forEach(System.out::println);// 练习1：获取员工姓名长度大于3的员工的姓名。 List&lt;Employee&gt; employees = EmployeeData.getEmployees(); Stream&lt;String&gt; namesStream = employees.stream().map(Employee::getName); namesStream.filter(name -&gt; name.length() &gt; 3).forEach(System.out::println); System.out.println(); //练习2： Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream().map(StreamAPITest1::fromStringToStream); streamStream.forEach(s -&gt;&#123; s.forEach(System.out::println); &#125;); System.out.println();// flatMap(Function f)——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。 Stream&lt;Character&gt; characterStream = list.stream().flatMap(StreamAPITest1::fromStringToStream); characterStream.forEach(System.out::println); &#125; //将字符串中的多个字符构成的集合转换为对应的Stream的实例 public static Stream&lt;Character&gt; fromStringToStream(String str)&#123;//aa ArrayList&lt;Character&gt; list = new ArrayList&lt;&gt;(); for(Character c : str.toCharArray())&#123; list.add(c); &#125; return list.stream(); &#125; @Test public void test3()&#123; ArrayList list1 = new ArrayList(); list1.add(1); list1.add(2); list1.add(3); ArrayList list2 = new ArrayList(); list2.add(4); list2.add(5); list2.add(6);// list1.add(list2); list1.addAll(list2); System.out.println(list1); &#125; 排序123456789101112131415161718192021222324 @Test public void test4()&#123;// sorted()——自然排序 List&lt;Integer&gt; list = Arrays.asList(12, 43, 65, 34, 87, 0, -98, 7); list.stream().sorted().forEach(System.out::println); //抛异常，原因:Employee没有实现Comparable接口// List&lt;Employee&gt; employees = EmployeeData.getEmployees();// employees.stream().sorted().forEach(System.out::println);// sorted(Comparator com)——定制排序 List&lt;Employee&gt; employees = EmployeeData.getEmployees(); employees.stream().sorted( (e1,e2) -&gt; &#123; int ageValue = Integer.compare(e1.getAge(),e2.getAge()); if(ageValue != 0)&#123; return ageValue; &#125;else&#123; return -Double.compare(e1.getSalary(),e2.getSalary()); &#125; &#125;).forEach(System.out::println); &#125; Stream的终止操作匹配与查找12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 @Test public void test1()&#123; List&lt;Employee&gt; employees = EmployeeData.getEmployees();// allMatch(Predicate p)——检查是否匹配所有元素。// 练习：是否所有的员工的年龄都大于18 boolean allMatch = employees.stream().allMatch(e -&gt; e.getAge() &gt; 18); System.out.println(allMatch);// anyMatch(Predicate p)——检查是否至少匹配一个元素。// 练习：是否存在员工的工资大于 10000 boolean anyMatch = employees.stream().anyMatch(e -&gt; e.getSalary() &gt; 10000); System.out.println(anyMatch);// noneMatch(Predicate p)——检查是否没有匹配的元素。// 练习：是否存在员工姓“雷” boolean noneMatch = employees.stream().noneMatch(e -&gt; e.getName().startsWith(&quot;雷&quot;)); System.out.println(noneMatch);// findFirst——返回第一个元素 Optional&lt;Employee&gt; employee = employees.stream().findFirst(); System.out.println(employee);// findAny——返回当前流中的任意元素 Optional&lt;Employee&gt; employee1 = employees.parallelStream().findAny(); System.out.println(employee1); &#125; @Test public void test2()&#123; List&lt;Employee&gt; employees = EmployeeData.getEmployees(); // count——返回流中元素的总个数 long count = employees.stream().filter(e -&gt; e.getSalary() &gt; 5000).count(); System.out.println(count);// max(Comparator c)——返回流中最大值// 练习：返回最高的工资： Stream&lt;Double&gt; salaryStream = employees.stream().map(e -&gt; e.getSalary()); Optional&lt;Double&gt; maxSalary = salaryStream.max(Double::compare); System.out.println(maxSalary);// min(Comparator c)——返回流中最小值// 练习：返回最低工资的员工 Optional&lt;Employee&gt; employee = employees.stream().min((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())); System.out.println(employee); System.out.println();// forEach(Consumer c)——内部迭代 employees.stream().forEach(System.out::println); //使用集合的遍历操作 employees.forEach(System.out::println); &#125; 归约123456789101112131415161718 @Test public void test3()&#123;// reduce(T identity, BinaryOperator)——可以将流中元素反复结合起来，得到一个值。返回 T// 练习1：计算1-10的自然数的和 List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6,7,8,9,10); Integer sum = list.stream().reduce(0, Integer::sum); System.out.println(sum);// reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值。返回 Optional&lt;T&gt;// 练习2：计算公司所有员工工资的总和 List&lt;Employee&gt; employees = EmployeeData.getEmployees(); Stream&lt;Double&gt; salaryStream = employees.stream().map(Employee::getSalary);// Optional&lt;Double&gt; sumMoney = salaryStream.reduce(Double::sum); Optional&lt;Double&gt; sumMoney = salaryStream.reduce((d1,d2) -&gt; d1 + d2); System.out.println(sumMoney.get()); &#125; 收集123456789101112131415 @Test public void test4()&#123;// collect(Collector c)——将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法// 练习1：查找工资大于6000的员工，结果返回为一个List或Set List&lt;Employee&gt; employees = EmployeeData.getEmployees(); List&lt;Employee&gt; employeeList = employees.stream().filter(e -&gt; e.getSalary() &gt; 6000).collect(Collectors.toList()); employeeList.forEach(System.out::println); System.out.println(); Set&lt;Employee&gt; employeeSet = employees.stream().filter(e -&gt; e.getSalary() &gt; 6000).collect(Collectors.toSet()); employeeSet.forEach(System.out::println); &#125; Optional类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106//Optional类的使用举例import org.junit.Test;import java.util.Optional;/** * Optional类：为了在程序中避免出现空指针异常而创建的。 * * 常用的方法：ofNullable(T t) * orElse(T t) * */public class OptionalTest &#123;/*Optional.of(T t) : 创建一个 Optional 实例，t必须非空；Optional.empty() : 创建一个空的 Optional 实例Optional.ofNullable(T t)：t可以为null */ @Test public void test1()&#123; Girl girl = new Girl();// girl = null; //of(T t):保证t是非空的 Optional&lt;Girl&gt; optionalGirl = Optional.of(girl); &#125; @Test public void test2()&#123; Girl girl = new Girl();// girl = null; //ofNullable(T t)：t可以为null Optional&lt;Girl&gt; optionalGirl = Optional.ofNullable(girl); System.out.println(optionalGirl); //orElse(T t1):如果单前的Optional内部封装的t是非空的，则返回内部的t. //如果内部的t是空的，则返回orElse()方法中的参数t1. Girl girl1 = optionalGirl.orElse(new Girl(&quot;赵丽颖&quot;)); System.out.println(girl1); &#125; public String getGirlName(Boy boy)&#123; return boy.getGirl().getName(); &#125; @Test public void test3()&#123; Boy boy = new Boy(); boy = null; String girlName = getGirlName(boy); System.out.println(girlName); &#125; //优化以后的getGirlName(): public String getGirlName1(Boy boy)&#123; if(boy != null)&#123; Girl girl = boy.getGirl(); if(girl != null)&#123; return girl.getName(); &#125; &#125; return null; &#125; @Test public void test4()&#123; Boy boy = new Boy(); boy = null; String girlName = getGirlName1(boy); System.out.println(girlName); &#125; //使用Optional类的getGirlName(): public String getGirlName2(Boy boy)&#123; Optional&lt;Boy&gt; boyOptional = Optional.ofNullable(boy); //此时的boy1一定非空 Boy boy1 = boyOptional.orElse(new Boy(new Girl(&quot;迪丽热巴&quot;))); Girl girl = boy1.getGirl(); Optional&lt;Girl&gt; girlOptional = Optional.ofNullable(girl); //girl1一定非空 Girl girl1 = girlOptional.orElse(new Girl(&quot;古力娜扎&quot;)); return girl1.getName(); &#125; @Test public void test5()&#123; Boy boy = null; boy = new Boy(); boy = new Boy(new Girl(&quot;苍老师&quot;)); String girlName = getGirlName2(boy); System.out.println(girlName); &#125;&#125; 1234567891011121314151617181920212223242526272829//Boy类：public class Boy &#123; private Girl girl; @Override public String toString() &#123; return &quot;Boy&#123;&quot; + &quot;girl=&quot; + girl + &#x27;&#125;&#x27;; &#125; public Girl getGirl() &#123; return girl; &#125; public void setGirl(Girl girl) &#123; this.girl = girl; &#125; public Boy() &#123; &#125; public Boy(Girl girl) &#123; this.girl = girl; &#125;&#125; 123456789101112131415161718192021222324252627282930//Girl类：public class Girl &#123; private String name; @Override public String toString() &#123; return &quot;Girl&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Girl() &#123; &#125; public Girl(String name) &#123; this.name = name; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"LeetCode算法合集","date":"2021-05-12T01:04:14.000Z","path":"2021/05/12/LeetCode算法合集/","text":"1. 两数之和题目给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例示例 1： 123输入：nums &#x3D; [2,7,11,15], target &#x3D; 9输出：[0,1]解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。 示例 2： 12输入：nums &#x3D; [3,2,4], target &#x3D; 6输出：[1,2] 示例 3： 12输入：nums &#x3D; [3,3], target &#x3D; 6输出：[0,1] 题解1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.HashMap;/** * * */public class Demo &#123; public static void main(String[] args) &#123;/* 可以使用键盘输入数据 Scanner sc1 = new Scanner(System.in); Scanner sc2 = new Scanner(System.in); Scanner sc3 = new Scanner(System.in); System.out.print(&quot;请输入数组长度：&quot;); int numslength = sc1.nextInt(); System.out.print(&quot;请输入数组：&quot;); int[] nums = new int[numslength]; for (int i = 0; i &lt; nums.length; i++) &#123; nums[i] = sc2.nextInt(); &#125; System.out.println(&quot;请输入目标值：&quot;); int target = sc3.nextInt(); System.out.println();*/ int[] nums = new int[]&#123;2, 4, 6, 7, 9&#125;; int target = 11; //key --&gt; 值 //value --&gt; 下标 HashMap&lt;Integer,Integer&gt; hashMap = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if(hashMap.containsKey(target - nums[i]))&#123; System.out.println(&quot;[&quot; + hashMap.get(target - nums[i]) + &quot;,&quot; + i + &quot;]&quot;); &#125; hashMap.put(nums[i], i); &#125; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"反射","date":"2021-05-10T11:46:43.000Z","path":"2021/05/10/反射/","text":"Java反射机制概述Java Reflection Reflection（反射）是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。 加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。 Java反射机制提供的功能 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时获取泛型信息 在运行时调用任意一个对象的成员变量和方法 在运行时处理注解 生成动态代理 反射相关的主要API java.lang.Class:代表一个类 java.lang.reflect.Method:代表类的方法 java.lang.reflect.Field:代表类的成员变量 java.lang.reflect.Constructor:代表类的构造器 … … 理解Class类并获取Class实例使用反射与不使用反射的对比123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128import org.junit.Test;import java.lang.annotation.ElementType;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;public class ReflectionTest &#123; //反射之前，对于Person的操作 @Test public void test1() &#123; //1.创建Person类的对象 Person p1 = new Person(&quot;Tom&quot;, 12); //2.通过对象，调用其内部的属性、方法 p1.age = 10; System.out.println(p1.toString()); p1.show(); //在Person类外部，不可以通过Person类的对象调用其内部私有结构。 //比如：name、showNation()以及私有的构造器 &#125; //反射之后，对于Person的操作 @Test public void test2() throws Exception&#123; Class clazz = Person.class; //1.通过反射，创建Person类的对象 Constructor cons = clazz.getConstructor(String.class,int.class); Object obj = cons.newInstance(&quot;Tom&quot;, 12); Person p = (Person) obj; System.out.println(p.toString()); //2.通过反射，调用对象指定的属性、方法 //调用属性 Field age = clazz.getDeclaredField(&quot;age&quot;); age.set(p,10); System.out.println(p.toString()); //调用方法 Method show = clazz.getDeclaredMethod(&quot;show&quot;); show.invoke(p); System.out.println(&quot;*******************************&quot;); //通过反射，可以调用Person类的私有结构的。比如：私有的构造器、方法、属性 //调用私有的构造器 Constructor cons1 = clazz.getDeclaredConstructor(String.class); cons1.setAccessible(true); Person p1 = (Person) cons1.newInstance(&quot;Jerry&quot;); System.out.println(p1); //调用私有的属性 Field name = clazz.getDeclaredField(&quot;name&quot;); name.setAccessible(true); name.set(p1,&quot;HanMeimei&quot;); System.out.println(p1); //调用私有的方法 Method showNation = clazz.getDeclaredMethod(&quot;showNation&quot;, String.class); showNation.setAccessible(true); String nation = (String) showNation.invoke(p1,&quot;中国&quot;);//相当于String nation = p1.showNation(&quot;中国&quot;) System.out.println(nation); &#125;&#125;//Person类：public class Person &#123; private String name; public int age; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; private Person(String name) &#123; this.name = name; &#125; public Person() &#123; System.out.println(&quot;Person()&quot;); &#125; public void show()&#123; System.out.println(&quot;你好，我是一个人&quot;); &#125; private String showNation(String nation)&#123; System.out.println(&quot;我的国籍是：&quot; + nation); return nation; &#125;&#125; 相关问题 疑问1：通过直接new的方式或反射的方式都可以调用公共的结构，开发中到底用那个？ 建议：直接new的方式。//什么时候会使用：反射的方式。 反射的特征：动态性 疑问2：反射机制与面向对象中的封装性是不是矛盾的？如何看待两个技术？ 不矛盾。 关于java.lang.Class类的理解 类的加载过程：程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class结尾)。接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此运行时类，就作为Class的一个实例。 换句话说，Class的实例就对应着一个运行时类。 加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类。 123456789101112131415161718192021222324252627 //获取Class的实例的方式（前三种方式需要掌握） @Test public void test3() throws ClassNotFoundException &#123; //方式一：调用运行时类的属性：.class Class clazz1 = Person.class; System.out.println(clazz1); //方式二：通过运行时类的对象,调用getClass() Person p1 = new Person(); Class clazz2 = p1.getClass(); System.out.println(clazz2); //方式三：调用Class的静态方法：forName(String classPath) Class clazz3 = Class.forName(&quot;com.atguigu.java.Person&quot;);// clazz3 = Class.forName(&quot;java.lang.String&quot;); System.out.println(clazz3); System.out.println(clazz1 == clazz2); System.out.println(clazz1 == clazz3); //方式四：使用类的加载器：ClassLoader (了解) ClassLoader classLoader = ReflectionTest.class.getClassLoader(); Class clazz4 = classLoader.loadClass(&quot;com.atguigu.java.Person&quot;); System.out.println(clazz4); System.out.println(clazz1 == clazz4); &#125; Class实例可以是哪些结构的说明1234567891011121314151617181920@Testpublic void test4()&#123; Class c1 = Object.class; Class c2 = Comparable.class; Class c3 = String[].class; Class c4 = int[][].class; Class c5 = ElementType.class; Class c6 = Override.class; Class c7 = int.class; Class c8 = void.class; Class c9 = Class.class; int[] a = new int[10]; int[] b = new int[100]; Class c10 = a.getClass(); Class c11 = b.getClass(); // 只要数组的元素类型与维度一样，就是同一个Class System.out.println(c10 == c11);&#125; 类的加载与ClassLoader的理解（了解）了解类的加载器1234567891011121314151617@Testpublic void test1()&#123; //对于自定义类，使用系统类加载器进行加载 ClassLoader classLoader = ClassLoaderTest.class.getClassLoader(); System.out.println(classLoader); //调用系统类加载器的getParent()：获取扩展类加载器 ClassLoader classLoader1 = classLoader.getParent(); System.out.println(classLoader1); //调用扩展类加载器的getParent()：无法获取引导类加载器 //引导类加载器主要负责加载java的核心类库，无法加载自定义类的。 ClassLoader classLoader2 = classLoader1.getParent(); System.out.println(classLoader2); ClassLoader classLoader3 = String.class.getClassLoader(); System.out.println(classLoader3);&#125; 使用ClassLoader加载配置文件123456789101112131415161718192021222324 /* Properties：用来读取配置文件。 */ @Test public void test2() throws Exception &#123; Properties pros = new Properties(); //此时的文件默认在当前的module下。 //读取配置文件的方式一：// FileInputStream fis = new FileInputStream(&quot;jdbc.properties&quot;);// FileInputStream fis = new FileInputStream(&quot;src\\\\jdbc1.properties&quot;);// pros.load(fis); //读取配置文件的方式二：使用ClassLoader //配置文件默认识别为：当前module的src下 ClassLoader classLoader = ClassLoaderTest.class.getClassLoader(); InputStream is = classLoader.getResourceAsStream(&quot;jdbc1.properties&quot;); pros.load(is); String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); System.out.println(&quot;user = &quot; + user + &quot;,password = &quot; + password); &#125; 创建运行时类的对象通过反射创建对应的运行时类的对象 newInstance():调用此方法，创建对应的运行时类的对象。内部调用了运行时类的空参的构造器。(已过时) 要求： 运行时类必须提供空参的构造器、 空参的构造器的访问权限得够。通常，设置为public。 注意：在javabean中要求提供一个public的空参构造器。 原因： 便于通过反射，创建运行时类的对象 便于子类继承此运行时类时，默认调用super()时，保证父类有此构造器 12345678@Testpublic void test1() throws IllegalAccessException, InstantiationException &#123; Class&lt;Person&gt; clazz = Person.class; Person obj = clazz.newInstance(); System.out.println(obj);&#125; 体会反射的动态性12345678910111213141516171819202122232425262728293031323334353637@Testpublic void test2()&#123; for(int i = 0;i &lt; 100;i++)&#123; int num = new Random().nextInt(3);//0,1,2 String classPath = &quot;&quot;; switch(num)&#123; case 0: classPath = &quot;java.util.Date&quot;; break; case 1: classPath = &quot;java.lang.Object&quot;; break; case 2: classPath = &quot;com.atguigu.java.Person&quot;; break; &#125; try &#123; Object obj = getInstance(classPath); System.out.println(obj); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;/*创建一个指定类的对象。classPath:指定类的全类名*/public Object getInstance(String classPath) throws Exception &#123; Class clazz = Class.forName(classPath); return clazz.newInstance();&#125; 获取运行时类的完整结构结构丰富的Person类Creature父类123456789101112131415import java.io.Serializable;public class Creature&lt;T&gt; implements Serializable &#123; private char gender; public double weight; private void breath()&#123; System.out.println(&quot;生物呼吸&quot;); &#125; public void eat()&#123; System.out.println(&quot;生物吃东西&quot;); &#125;&#125; Person子类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@MyAnnotation(value=&quot;hi&quot;)public class Person extends Creature&lt;String&gt; implements Comparable&lt;String&gt;,MyInterface&#123; private String name; int age; public int id; public Person()&#123;&#125; @MyAnnotation(value=&quot;abc&quot;) private Person(String name)&#123; this.name = name; &#125; Person(String name,int age)&#123; this.name = name; this.age = age; &#125; @MyAnnotation private String show(String nation)&#123; System.out.println(&quot;我的国籍是：&quot; + nation); return nation; &#125; public String display(String interests,int age) throws NullPointerException,ClassCastException&#123; return interests + age; &#125; @Override public void info() &#123; System.out.println(&quot;我是一个人&quot;); &#125; @Override public int compareTo(String o) &#123; return 0; &#125; private static void showDesc()&#123; System.out.println(&quot;我是一个可爱的人&quot;); &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, id=&quot; + id + &#x27;&#125;&#x27;; &#125;&#125; 自定义接口123public interface MyInterface &#123; void info();&#125; 自定义注解123456789101112import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import static java.lang.annotation.ElementType.*;@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation &#123; String value() default &quot;hello&quot;;&#125; 获取运行时类的属性结构及其内部结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import org.junit.Test;import study07.Person;import java.lang.reflect.Field;import java.lang.reflect.Modifier;/** * 获取当前运行时类的属性结构 * */public class FieldTest &#123; @Test public void test1()&#123; Class clazz = Person.class; //获取属性结构 //getFields():获取当前运行时类及其父类中声明为public访问权限的属性 Field[] fields = clazz.getFields(); for(Field f : fields)&#123; System.out.println(f); &#125; System.out.println(); //getDeclaredFields():获取当前运行时类中声明的所有属性。（不包含父类中声明的属性） Field[] declaredFields = clazz.getDeclaredFields(); for(Field f : declaredFields)&#123; System.out.println(f); &#125; &#125; //权限修饰符 数据类型 变量名 @Test public void test2()&#123; Class clazz = Person.class; Field[] declaredFields = clazz.getDeclaredFields(); for(Field f : declaredFields)&#123; //1.权限修饰符 int modifier = f.getModifiers(); System.out.print(Modifier.toString(modifier) + &quot;\\t&quot;); //2.数据类型 Class type = f.getType(); System.out.print(type.getName() + &quot;\\t&quot;); //3.变量名 String fName = f.getName(); System.out.print(fName); System.out.println(); &#125; &#125;&#125; 获取运行时类的方法结构以及内部结构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import study07.Person;import org.junit.Test;import java.lang.annotation.Annotation;import java.lang.reflect.Method;import java.lang.reflect.Modifier;/** * 获取运行时类的方法结构 * */public class MethodTest &#123; @Test public void test1()&#123; Class clazz = Person.class; //getMethods():获取当前运行时类及其所有父类中声明为public权限的方法 Method[] methods = clazz.getMethods(); for(Method m : methods)&#123; System.out.println(m); &#125; System.out.println(); //getDeclaredMethods():获取当前运行时类中声明的所有方法。（不包含父类中声明的方法） Method[] declaredMethods = clazz.getDeclaredMethods(); for(Method m : declaredMethods)&#123; System.out.println(m); &#125; &#125;/*@Xxxx权限修饰符 返回值类型 方法名(参数类型1 形参名1,...) throws XxxException&#123;&#125;*/ @Test public void test2()&#123; Class clazz = Person.class; Method[] declaredMethods = clazz.getDeclaredMethods(); for(Method m : declaredMethods)&#123; //1.获取方法声明的注解 Annotation[] annos = m.getAnnotations(); for(Annotation a : annos)&#123; System.out.println(a); &#125; //2.权限修饰符 System.out.print(Modifier.toString(m.getModifiers()) + &quot;\\t&quot;); //3.返回值类型 System.out.print(m.getReturnType().getName() + &quot;\\t&quot;); //4.方法名 System.out.print(m.getName()); System.out.print(&quot;(&quot;); //5.形参列表 Class[] parameterTypes = m.getParameterTypes(); if(!(parameterTypes == null &amp;&amp; parameterTypes.length == 0))&#123; for(int i = 0;i &lt; parameterTypes.length;i++)&#123; if(i == parameterTypes.length - 1)&#123; System.out.print(parameterTypes[i].getName() + &quot; args_&quot; + i); break; &#125; System.out.print(parameterTypes[i].getName() + &quot; args_&quot; + i + &quot;,&quot;); &#125; &#125; System.out.print(&quot;)&quot;); //6.抛出的异常 Class[] exceptionTypes = m.getExceptionTypes(); if(exceptionTypes.length &gt; 0)&#123; System.out.print(&quot;throws &quot;); for(int i = 0;i &lt; exceptionTypes.length;i++)&#123; if(i == exceptionTypes.length - 1)&#123; System.out.print(exceptionTypes[i].getName()); break; &#125; System.out.print(exceptionTypes[i].getName() + &quot;,&quot;); &#125; &#125; System.out.println(); &#125; &#125;&#125; 获取运行时类的构造器结构123456789101112131415161718@Testpublic void test1()&#123; Class clazz = Person.class; //getConstructors():获取当前运行时类中声明为public的构造器 Constructor[] constructors = clazz.getConstructors(); for(Constructor c : constructors)&#123; System.out.println(c); &#125; System.out.println(); //getDeclaredConstructors():获取当前运行时类中声明的所有的构造器 Constructor[] declaredConstructors = clazz.getDeclaredConstructors(); for(Constructor c : declaredConstructors)&#123; System.out.println(c); &#125;&#125; 获取运行时类的父类及父类的泛型12345678910111213141516171819202122232425262728293031323334353637383940 /* 获取运行时类的父类 */ @Test public void test2()&#123; Class clazz = Person.class; Class superclass = clazz.getSuperclass(); System.out.println(superclass); &#125; /* 获取运行时类的带泛型的父类 */ @Test public void test3()&#123; Class clazz = Person.class; Type genericSuperclass = clazz.getGenericSuperclass(); System.out.println(genericSuperclass); &#125; /* 获取运行时类的带泛型的父类的泛型 代码：逻辑性代码 vs 功能性代码 */ @Test public void test4()&#123; Class clazz = Person.class; Type genericSuperclass = clazz.getGenericSuperclass(); ParameterizedType paramType = (ParameterizedType) genericSuperclass; //获取泛型类型 Type[] actualTypeArguments = paramType.getActualTypeArguments();// System.out.println(actualTypeArguments[0].getTypeName()); System.out.println(((Class)actualTypeArguments[0]).getName()); &#125; 获取运行时类的接口、所在包、注解等123456789101112131415161718192021222324252627282930313233343536373839404142434445/*获取运行时类实现的接口 */@Testpublic void test5()&#123; Class clazz = Person.class; Class[] interfaces = clazz.getInterfaces(); for(Class c : interfaces)&#123; System.out.println(c); &#125; System.out.println(); //获取运行时类的父类实现的接口 Class[] interfaces1 = clazz.getSuperclass().getInterfaces(); for(Class c : interfaces1)&#123; System.out.println(c); &#125;&#125;/* 获取运行时类所在的包 */@Testpublic void test6()&#123; Class clazz = Person.class; Package pack = clazz.getPackage(); System.out.println(pack);&#125;/* 获取运行时类声明的注解 */@Testpublic void test7()&#123; Class clazz = Person.class; Annotation[] annotations = clazz.getAnnotations(); for(Annotation annos : annotations)&#123; System.out.println(annos); &#125;&#125; 调用运行时类的指定结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131import study07.Person;import org.junit.Test;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;/** * 调用运行时类中指定的结构：属性、方法、构造器 * */public class ReflectionTest &#123; /* 不需要掌握 */ @Test public void testField() throws Exception &#123; Class clazz = Person.class; //创建运行时类的对象 Person p = (Person) clazz.newInstance(); //获取指定的属性：要求运行时类中属性声明为public //通常不采用此方法 Field id = clazz.getField(&quot;id&quot;); /* 设置当前属性的值 set():参数1：指明设置哪个对象的属性 参数2：将此属性值设置为多少 */ id.set(p,1001); /* 获取当前属性的值 get():参数1：获取哪个对象的当前属性值 */ int pId = (int) id.get(p); System.out.println(pId); &#125; /* 如何操作运行时类中的指定的属性 -- 需要掌握 */ @Test public void testField1() throws Exception &#123; Class clazz = Person.class; //创建运行时类的对象 Person p = (Person) clazz.newInstance(); //1. getDeclaredField(String fieldName):获取运行时类中指定变量名的属性 Field name = clazz.getDeclaredField(&quot;name&quot;); //2.保证当前属性是可访问的 name.setAccessible(true); //3.获取、设置指定对象的此属性值 name.set(p,&quot;Tom&quot;); System.out.println(name.get(p)); &#125; /* 如何操作运行时类中的指定的方法 -- 需要掌握 */ @Test public void testMethod() throws Exception &#123; Class clazz = Person.class; //创建运行时类的对象 Person p = (Person) clazz.newInstance(); /* 1.获取指定的某个方法 getDeclaredMethod():参数1 ：指明获取的方法的名称 参数2：指明获取的方法的形参列表 */ Method show = clazz.getDeclaredMethod(&quot;show&quot;, String.class); //2.保证当前方法是可访问的 show.setAccessible(true); /* 3. 调用方法的invoke():参数1：方法的调用者 参数2：给方法形参赋值的实参 invoke()的返回值即为对应类中调用的方法的返回值。 */ Object returnValue = show.invoke(p,&quot;CHN&quot;); //String nation = p.show(&quot;CHN&quot;); System.out.println(returnValue); System.out.println(&quot;*************如何调用静态方法*****************&quot;); // private static void showDesc() Method showDesc = clazz.getDeclaredMethod(&quot;showDesc&quot;); showDesc.setAccessible(true); //如果调用的运行时类中的方法没有返回值，则此invoke()返回null// Object returnVal = showDesc.invoke(null); Object returnVal = showDesc.invoke(Person.class); System.out.println(returnVal);//null &#125; /* 如何调用运行时类中的指定的构造器 */ @Test public void testConstructor() throws Exception &#123; Class clazz = Person.class; //private Person(String name) /* 1.获取指定的构造器 getDeclaredConstructor():参数：指明构造器的参数列表 */ Constructor constructor = clazz.getDeclaredConstructor(String.class); //2.保证此构造器是可访问的 constructor.setAccessible(true); //3.调用此构造器创建运行时类的对象 Person per = (Person) constructor.newInstance(&quot;Tom&quot;); System.out.println(per); &#125;&#125; 反射的应用：动态代理静态代理举例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 静态代理举例 * * 特点：代理类和被代理类在编译期间，就确定下来了。 * */interface ClothFactory&#123; void produceCloth();&#125;//代理类class ProxyClothFactory implements ClothFactory&#123; private ClothFactory factory;//用被代理类对象进行实例化 public ProxyClothFactory(ClothFactory factory)&#123; this.factory = factory; &#125; @Override public void produceCloth() &#123; System.out.println(&quot;代理工厂做一些准备工作&quot;); factory.produceCloth(); System.out.println(&quot;代理工厂做一些后续的收尾工作&quot;); &#125;&#125;//被代理类class NikeClothFactory implements ClothFactory&#123; @Override public void produceCloth() &#123; System.out.println(&quot;Nike工厂生产一批运动服&quot;); &#125;&#125;public class StaticProxyTest &#123; public static void main(String[] args) &#123; //创建被代理类的对象 ClothFactory nike = new NikeClothFactory(); //创建代理类的对象 ClothFactory proxyClothFactory = new ProxyClothFactory(nike); proxyClothFactory.produceCloth(); &#125;&#125; 动态代理的举例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * * 动态代理的举例 * */interface Human&#123; String getBelief(); void eat(String food);&#125;//被代理类class SuperMan implements Human&#123; @Override public String getBelief() &#123; return &quot;I believe I can fly!&quot;; &#125; @Override public void eat(String food) &#123; System.out.println(&quot;我喜欢吃&quot; + food); &#125;&#125;class HumanUtil&#123; public void method1()&#123; System.out.println(&quot;====================通用方法一====================&quot;); &#125; public void method2()&#123; System.out.println(&quot;====================通用方法二====================&quot;); &#125;&#125;/*要想实现动态代理，需要解决的问题？问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象。问题二：当通过代理类的对象调用方法a时，如何动态的去调用被代理类中的同名方法a。 */class ProxyFactory&#123; //调用此方法，返回一个代理类的对象。解决问题一 public static Object getProxyInstance(Object obj)&#123;//obj:被代理类的对象 MyInvocationHandler handler = new MyInvocationHandler(); handler.bind(obj); return Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),handler); &#125;&#125;class MyInvocationHandler implements InvocationHandler&#123; private Object obj;//需要使用被代理类的对象进行赋值 public void bind(Object obj)&#123; this.obj = obj; &#125; //当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke() //将被代理类要执行的方法a的功能就声明在invoke()中 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; HumanUtil util = new HumanUtil(); util.method1(); //method:即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法 //obj:被代理类的对象 Object returnValue = method.invoke(obj,args); util.method2(); //上述方法的返回值就作为当前类中的invoke()的返回值。 return returnValue; &#125;&#125;public class ProxyTest &#123; public static void main(String[] args) &#123; SuperMan superMan = new SuperMan(); //proxyInstance:代理类的对象 Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan); //当通过代理类对象调用方法时，会自动的调用被代理类中同名的方法 String belief = proxyInstance.getBelief(); System.out.println(belief); proxyInstance.eat(&quot;四川麻辣烫&quot;); System.out.println(&quot;*****************************&quot;); NikeClothFactory nikeClothFactory = new NikeClothFactory(); ClothFactory proxyClothFactory = (ClothFactory) ProxyFactory.getProxyInstance(nikeClothFactory); proxyClothFactory.produceCloth(); &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"网络编程","date":"2021-05-09T11:23:16.000Z","path":"2021/05/09/网络编程/","text":"网络编程概述计算机网络 把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规 模大、功能强的网络系统，从而使众多的计算机可以方便地互相传递信息、 共享硬件、软件、数据信息等资源。 网络编程的目的 直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯。 网络编程中有两个主要的问题： 如何准确地定位网络上一台或多台主机；定位主机上的特定的应用 找到主机后如何可靠高效地进行数据传输 网络通信要素概述如何实现网络中的主机互相通信： 通信双方地址（对应问题1） IP 端口号 一定的规则（即：网络通信协议。有两套参考模型）（对应问题2） OSI参考模型：模型过于理想化，未能在因特网上进行广泛推广 TCP/IP参考模型(或TCP/IP协议)：（应用层、传输层、网络层、物理+数据链路层），事实上的国际标准。 网络通讯协议 OSI参考模型 TCP/IP参考模型 TCP/IP参考模型各层对应协议 应用层 应用层 HTTP、FTP、Telnet、 DNS… 表示层 应用层 HTTP、FTP、Telnet、 DNS… 会话层 应用层 HTTP、FTP、Telnet、 DNS… 传输层 传输层 TCP、UDP、… 网络层 网络层 IP、ICMP、ARP… 数据链路层 物理+数据链路层 Link 物理层 物理+数据链路层 Link 通信要素1：IP和端口号 IP:唯一的标识 Internet 上的计算机（通信实体） 在Java中使用InetAddress类代表IP IP分类：IPv4 和 IPv6 ; 万维网 和 局域网 域名: www.baidu.com www.mi.com www.sina.com www.jd.com www.vip.com 本地回路地址：127.0.0.1 对应着：localhost 如何实例化InetAddress:两个方法：getByName(String host) 、 getLocalHost() 两个常用方法：getHostName() / getHostAddress() 端口号：正在计算机上运行的进程。要求：不同的进程有不同的端口号 范围：被规定为一个 16 位的整数 0~65535。 端口号与IP地址的组合得出一个网络套接字：Socket 123456789101112131415161718192021222324252627282930public class InetAddressTest &#123; public static void main(String[] args) &#123; try &#123; //File file = new File(&quot;hello.txt&quot;); InetAddress inet1 = InetAddress.getByName(&quot;192.168.10.14&quot;); System.out.println(inet1); InetAddress inet2 = InetAddress.getByName(&quot;www.atguigu.com&quot;); System.out.println(inet2); InetAddress inet3 = InetAddress.getByName(&quot;127.0.0.1&quot;); System.out.println(inet3); //获取本地ip InetAddress inet4 = InetAddress.getLocalHost(); System.out.println(inet4); //getHostName() System.out.println(inet2.getHostName()); //getHostAddress() System.out.println(inet2.getHostAddress()); &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 通信要素2：网络协议TCP/IP协议簇 传输层协议中有两个非常重要的协议：传输控制协议TCP(Transmission Control Protocol) 用户数据报协议UDP(User Datagram Protocol)。 TCP/IP 以其两个主要协议：传输控制协议(TCP)和网络互联协议(IP)而得名，实际上是一组协议，包括多个具有不同功能且互为关联的协议。 IP(Internet Protocol)协议是网络层的主要协议，支持网间互连的数据通信。 TCP/IP协议模型从更实用的角度出发，形成了高效的四层体系结构，即物理链路层、IP层、传输层和应用层。 TCP 和 UDPTCP协议 使用TCP协议前，须先建立TCP连接，形成传输数据通道 传输前，采用“三次握手”方式，点对点通信，是可靠的 TCP协议进行通信的两个应用进程：客户端、服务端。 在连接中可进行大数据量的传输 传输完毕，需释放已建立的连接，效率低 UDP协议 将数据、源、目的封装成数据包，不需要建立连接 每个数据报的大小限制在64K内 发送不管对方是否准备好，接收方收到也不确认，故是不可靠的 可以广播发送 发送数据结束时无需释放资源，开销小，速度快 Socket 利用套接字(Socket)开发网络应用程序早已被广泛的采用，以至于成为事实上的标准。 网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字。 通信的两端都要有Socket，是两台机器间通信的端点。 网络通信其实就是Socket间的通信。 Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输。 一般主动发起通信的应用程序属客户端，等待通信请求的为服务端。 Socket分类：流套接字（stream socket）：使用TCP提供可依赖的字节流服务 数据报套接字（datagram socket）：使用UDP提供“尽力而为”的数据报服务 123456789101112131415/*Socket类的常用构造器： public Socket(InetAddress address,int port)创建一个流套接字并将其连接到指定 IP 地址的指定端口号。 public Socket(String host,int port)创建一个流套接字并将其连接到指定主机上的指定端口号。Socket类的常用方法： public InputStream getInputStream()返回此套接字的输入流。可以用于接收网络消息 public OutputStream getOutputStream()返回此套接字的输出流。可以用于发送网络消息 public InetAddress getInetAddress()此套接字连接到的远程 IP 地址；如果套接字是未连接的，则返回 null。 public InetAddress getLocalAddress()获取套接字绑定的本地地址。 即本端的IP地址 public int getPort()此套接字连接到的远程端口号；如果尚未连接套接字，则返回 0。 public int getLocalPort()返回此套接字绑定到的本地端口。 如果尚未绑定套接字，则返回 -1。即本端的端口号。 public void close()关闭此套接字。套接字被关闭后，便不可在以后的网络连接中使用（即无法重新连接或重新绑定）。需要创建新的套接字对象。 关闭此套接字也将会关闭该套接字的 InputStream 和OutputStream。 public void shutdownInput()如果在套接字上调用 shutdownInput() 后从套接字输入流读取内容，则流将返回 EOF（文件结束符）。 即不能在从此套接字的输入流中接收任何数据。 public void shutdownOutput()禁用此套接字的输出流。对于 TCP 套接字，任何以前写入的数据都将被发送，并且后跟 TCP 的正常连接终止序列。 如果在套接字上调用 shutdownOutput() 后写入套接字输出流，则该流将抛出 IOException。 即不能通过此套接字的输出流发送任何数据。*/ TCP网络编程例题1：客户端发送信息给服务端，服务端将数据显示在控制台上123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127import org.junit.Test;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.InetAddress;import java.net.ServerSocket;import java.net.Socket;/** * 实现TCP的网络编程 * 例子1：客户端发送信息给服务端，服务端将数据显示在控制台上 */public class TCPTest1 &#123; //客户端 @Test public void client() &#123; Socket socket = null; OutputStream os = null; try &#123; //1.创建Socket对象，指明服务器端的ip和端口号 InetAddress inet = InetAddress.getByName(&quot;192.168.14.100&quot;); socket = new Socket(inet,8899); //2.获取一个输出流，用于输出数据 os = socket.getOutputStream(); //3.写出数据的操作 os.write(&quot;你好，我是客户端mm&quot;.getBytes()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //4.资源的关闭 if(os != null)&#123; try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(socket != null)&#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; //服务端 @Test public void server() &#123; ServerSocket ss = null; Socket socket = null; InputStream is = null; ByteArrayOutputStream baos = null; try &#123; //1.创建服务器端的ServerSocket，指明自己的端口号 ss = new ServerSocket(8899); //2.调用accept()表示接收来自于客户端的socket socket = ss.accept(); //3.获取输入流 is = socket.getInputStream(); //不建议这样写，可能会有乱码// byte[] buffer = new byte[1024];// int len;// while((len = is.read(buffer)) != -1)&#123;// String str = new String(buffer,0,len);// System.out.print(str);// &#125; //4.读取输入流中的数据 baos = new ByteArrayOutputStream(); byte[] buffer = new byte[5]; int len; while((len = is.read(buffer)) != -1)&#123; baos.write(buffer,0,len); &#125; System.out.println(baos.toString()); System.out.println(&quot;收到了来自于：&quot; + socket.getInetAddress().getHostAddress() + &quot;的数据&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(baos != null)&#123; //5.关闭资源 try &#123; baos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(is != null)&#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(socket != null)&#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(ss != null)&#123; try &#123; ss.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 例题2：客户端发送文件给服务端，服务端将文件保存在本地。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import org.junit.Test;import java.io.*;import java.net.InetAddress;import java.net.ServerSocket;import java.net.Socket;/** * * 实现TCP的网络编程 * 例题2：客户端发送文件给服务端，服务端将文件保存在本地。 * */public class TCPTest2 &#123; /* 这里涉及到的异常，应该使用try-catch-finally处理 */ @Test public void client() throws IOException &#123; //1. Socket socket = new Socket(InetAddress.getByName(&quot;127.0.0.1&quot;),9090); //2. OutputStream os = socket.getOutputStream(); //3. FileInputStream fis = new FileInputStream(new File(&quot;beauty.jpg&quot;)); //4. byte[] buffer = new byte[1024]; int len; while((len = fis.read(buffer)) != -1)&#123; os.write(buffer,0,len); &#125; //5. fis.close(); os.close(); socket.close(); &#125; /* 这里涉及到的异常，应该使用try-catch-finally处理 */ @Test public void server() throws IOException &#123; //1. ServerSocket ss = new ServerSocket(9090); //2. Socket socket = ss.accept(); //3. InputStream is = socket.getInputStream(); //4. FileOutputStream fos = new FileOutputStream(new File(&quot;beauty1.jpg&quot;)); //5. byte[] buffer = new byte[1024]; int len; while((len = is.read(buffer)) != -1)&#123; fos.write(buffer,0,len); &#125; //6. fos.close(); is.close(); socket.close(); ss.close(); &#125;&#125; 例题3：从客户端发送文件给服务端，服务端保存到本地。并返回“发送成功”给客户端。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import org.junit.Test;import java.io.*;import java.net.InetAddress;import java.net.ServerSocket;import java.net.Socket;/** * 实现TCP的网络编程 * 例题3：从客户端发送文件给服务端，服务端保存到本地。并返回“发送成功”给客户端。 * 并关闭相应的连接。 */public class TCPTest3 &#123; /* 这里涉及到的异常，应该使用try-catch-finally处理 */ @Test public void client() throws IOException &#123; //1. Socket socket = new Socket(InetAddress.getByName(&quot;127.0.0.1&quot;),9090); //2. OutputStream os = socket.getOutputStream(); //3. FileInputStream fis = new FileInputStream(new File(&quot;beauty.jpg&quot;)); //4. byte[] buffer = new byte[1024]; int len; while((len = fis.read(buffer)) != -1)&#123; os.write(buffer,0,len); &#125; //关闭数据的输出 socket.shutdownOutput(); //5.接收来自于服务器端的数据，并显示到控制台上 InputStream is = socket.getInputStream(); ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] buffer1 = new byte[20]; int len1; while((len1 = is.read(buffer1)) != -1)&#123; baos.write(buffer1,0,len1); &#125; System.out.println(baos.toString()); //6. fis.close(); os.close(); socket.close(); baos.close(); &#125; /* 这里涉及到的异常，应该使用try-catch-finally处理 */ @Test public void server() throws IOException &#123; //1. ServerSocket ss = new ServerSocket(9090); //2. Socket socket = ss.accept(); //3. InputStream is = socket.getInputStream(); //4. FileOutputStream fos = new FileOutputStream(new File(&quot;beauty2.jpg&quot;)); //5. byte[] buffer = new byte[1024]; int len; while((len = is.read(buffer)) != -1)&#123; fos.write(buffer,0,len); &#125; System.out.println(&quot;图片传输完成&quot;); //6.服务器端给予客户端反馈 OutputStream os = socket.getOutputStream(); os.write(&quot;你好，美女，照片我已收到，非常漂亮！&quot;.getBytes()); //7. fos.close(); is.close(); socket.close(); ss.close(); os.close(); &#125;&#125; UDP网络编程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import org.junit.Test;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;/** * UDP协议的网络编程 */public class UDPTest &#123; //发送端 @Test public void sender() throws IOException &#123; DatagramSocket socket = new DatagramSocket(); String str = &quot;我是UDP方式发送的导弹&quot;; byte[] data = str.getBytes(); InetAddress inet = InetAddress.getLocalHost(); DatagramPacket packet = new DatagramPacket(data,0,data.length,inet,9090); socket.send(packet); socket.close(); &#125; //接收端 @Test public void receiver() throws IOException &#123; DatagramSocket socket = new DatagramSocket(9090); byte[] buffer = new byte[100]; DatagramPacket packet = new DatagramPacket(buffer,0,buffer.length); socket.receive(packet); System.out.println(new String(packet.getData(),0,packet.getLength())); socket.close(); &#125;&#125; URL编程 URL:统一资源定位符，对应着互联网的某一资源地址 格式：http://localhost:8080/examples/beauty.jpg?username=Tom 协议 主机名 端口号 资源地址 参数列表 URL类的实例化123456789101112131415161718192021222324252627282930import java.net.MalformedURLException;import java.net.URL;public class URLTest &#123; public static void main(String[] args) &#123; try &#123; URL url = new URL(&quot;http://localhost:8080/examples/beauty.jpg?username=Tom&quot;);// public String getProtocol( ) 获取该URL的协议名 System.out.println(url.getProtocol());// public String getHost( ) 获取该URL的主机名 System.out.println(url.getHost());// public String getPort( ) 获取该URL的端口号 System.out.println(url.getPort());// public String getPath( ) 获取该URL的文件路径 System.out.println(url.getPath());// public String getFile( ) 获取该URL的文件名 System.out.println(url.getFile());// public String getQuery( ) 获取该URL的查询名 System.out.println(url.getQuery()); &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; URL网络编程实现Tomcat服务端数据下载123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.net.HttpURLConnection;import java.net.URL;public class URLTest1 &#123; public static void main(String[] args) &#123; HttpURLConnection urlConnection = null; InputStream is = null; FileOutputStream fos = null; try &#123; URL url = new URL(&quot;http://localhost:8080/examples/beauty.jpg&quot;); urlConnection = (HttpURLConnection) url.openConnection(); urlConnection.connect(); is = urlConnection.getInputStream(); fos = new FileOutputStream(&quot;day10\\\\beauty3.jpg&quot;); byte[] buffer = new byte[1024]; int len; while((len = is.read(buffer)) != -1)&#123; fos.write(buffer,0,len); &#125; System.out.println(&quot;下载完成&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //关闭资源 if(is != null)&#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(fos != null)&#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(urlConnection != null)&#123; urlConnection.disconnect(); &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"IO流","date":"2021-05-04T12:56:03.000Z","path":"2021/05/04/IO流/","text":"File类的使用File的说明 File类的一个对象，代表一个文件或一个文件目录(俗称：文件夹) File类声明在java.io包下 File类中涉及到关于文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法，并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成。 后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的”终点”。 File的实例化操作构造方法 File(String filePath) File(String parentPath,String childPath) File(File parentFile,String childPath) 相对路径与绝对路径 相对路径：相较于某个路径下，指明的路径。 绝对路径：包含盘符在内的文件或文件目录的路径 路径分隔符 windows:\\\\ unix:/ 1234567891011121314151617@Testpublic void test1()&#123; //构造器1 File file1 = new File(&quot;hello.txt&quot;);//相对于当前module下 File file2 = new File(&quot;D:\\\\游戏放这\\\\尚硅谷Java文档技术文档\\\\资料下载平台-教学课件\\\\01-尚硅谷_JAVASE\\\\Java基础课件、项目、源码等\\\\04-代码\\\\代码\\\\第2部分：Java高级编程\\\\JavaSenior\\\\day08\\\\he.txt&quot;);//这是此时的存放路径 System.out.println(file1); System.out.println(file2); //构造器2： File file3 = new File(&quot;D:\\\\游戏放这\\\\尚硅谷Java文档技术文档\\\\资料下载平台-教学课件\\\\01-尚硅谷_JAVASE\\\\Java基础课件、项目、源码等\\\\04-代码\\\\代码\\\\第2部分：Java高级编程&quot;,&quot;JavaSenior&quot;); System.out.println(file3); //构造器3： File file4 = new File(file3,&quot;hi.txt&quot;); System.out.println(file4);&#125; File类的常用方法123456789101112131415161718192021222324252627282930/*public String getAbsolutePath()：获取绝对路径public String getPath() ：获取路径public String getName() ：获取名称public String getParent()：获取上层文件目录路径。若无，返回nullpublic long length() ：获取文件长度（即：字节数）。不能获取目录的长度。public long lastModified() ：获取最后一次的修改时间，毫秒值*/ @Test public void test2()&#123; File file1 = new File(&quot;hello.txt&quot;); File file2 = new File(&quot;d:\\\\io\\\\hi.txt&quot;); System.out.println(file1.getAbsolutePath()); System.out.println(file1.getPath()); System.out.println(file1.getName()); System.out.println(file1.getParent()); System.out.println(file1.length()); System.out.println(new Date(file1.lastModified())); System.out.println(); System.out.println(file2.getAbsolutePath()); System.out.println(file2.getPath()); System.out.println(file2.getName()); System.out.println(file2.getParent()); System.out.println(file2.length()); System.out.println(file2.lastModified()); &#125; 12345678910111213141516171819202122/*如下的两个方法适用于文件目录：public String[] list() ：获取指定目录下的所有文件或者文件目录的名称数组public File[] listFiles() ：获取指定目录下的所有文件或者文件目录的File数组*/ @Test public void test3()&#123; File file = new File(&quot;D:\\\\workspace_idea1\\\\JavaSenior&quot;);//不存在就报错 String[] list = file.list(); for(String s : list)&#123; System.out.println(s);//遍历文件夹名字 &#125; System.out.println(); File[] files = file.listFiles(); for(File f : files)&#123; System.out.println(f);//以绝对路径遍历出来 &#125; &#125; 123456789101112131415/*public boolean renameTo(File dest):把文件重命名为指定的文件路径 //剪切+改名 比如：file1.renameTo(file2)为例： 要想保证返回true,需要file1在硬盘中是存在的，且file2不能在硬盘中存在。 */@Testpublic void test4()&#123; File file1 = new File(&quot;hello.txt&quot;); File file2 = new File(&quot;D:\\\\io\\\\hi.txt&quot;); boolean renameTo = file2.renameTo(file1);//将file1的“hello.txt”剪切到file2的“hi.txt”的路径下并重新命名 System.out.println(renameTo);&#125; 12345678910111213141516171819202122232425262728293031323334/*public boolean isDirectory()：判断是否是文件目录public boolean isFile() ：判断是否是文件public boolean exists() ：判断是否存在public boolean canRead() ：判断是否可读public boolean canWrite() ：判断是否可写public boolean isHidden() ：判断是否隐藏*/ @Test public void test5()&#123; File file1 = new File(&quot;hello.txt&quot;);// file1 = new File(&quot;hello1.txt&quot;); System.out.println(file1.isDirectory()); System.out.println(file1.isFile()); System.out.println(file1.exists()); System.out.println(file1.canRead()); System.out.println(file1.canWrite()); System.out.println(file1.isHidden()); System.out.println(); File file2 = new File(&quot;d:\\\\io&quot;);// file2 = new File(&quot;d:\\\\io1&quot;); System.out.println(file2.isDirectory()); System.out.println(file2.isFile()); System.out.println(file2.exists()); System.out.println(file2.canRead()); System.out.println(file2.canWrite()); System.out.println(file2.isHidden()); &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/*创建硬盘中对应的文件或文件目录public boolean createNewFile() ：创建文件。若文件存在，则不创建，返回falsepublic boolean mkdir() ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。public boolean mkdirs() ：创建文件目录。如果此文件目录存在，就不创建了。如果上层文件目录不存在，一并创建删除磁盘中的文件或文件目录public boolean delete()：删除文件或者文件夹删除注意事项：Java中的删除不走回收站。*/ @Test public void test6() throws IOException &#123; File file1 = new File(&quot;hi.txt&quot;); if(!file1.exists())&#123; //文件的创建 file1.createNewFile(); System.out.println(&quot;创建成功&quot;); &#125;else&#123;//文件存在 file1.delete(); System.out.println(&quot;删除成功&quot;); &#125; &#125; @Test public void test7()&#123; //文件目录的创建 //如果创建的文件上一层目录存在，那么mkdir和mkdirs没有区别，都会直接创建对应的文件夹，这里不举例。 //io文件夹中不存在io1文件夹 File file1 = new File(&quot;d:\\\\io\\\\io1\\\\io3&quot;); boolean mkdir = file1.mkdir();//此时mkdir无法创建 if(mkdir)&#123; System.out.println(&quot;创建成功1&quot;); &#125; File file2 = new File(&quot;d:\\\\io\\\\io1\\\\io4&quot;); boolean mkdir1 = file2.mkdirs();//此时mkdirs可以创建 if(mkdir1)&#123; System.out.println(&quot;创建成功2&quot;); &#125; //要想删除成功，io4文件目录下不能有子目录或文件 File file3 = new File(&quot;D:\\\\io\\\\io1\\\\io4&quot;); file3 = new File(&quot;D:\\\\io\\\\io1&quot;); System.out.println(file3.delete()); &#125; IO流原理及流的分类流的分类 按操作数据单位不同分为：字节流(8 bit)，字符流(16 bit) 按数据流的流向不同分为：输入流，输出流 按流的角色的不同分为：节点流，处理流 抽象基类： (抽象基类) 字节流 字符流 输入流 InputStream Reader 输出流 OutputStream Writer IO流体系 分类 字节输入流 字节输出流 字符输入流 字符输出流 抽象基流 InputStream OutputStream Reader Writer 访问文件 FileInputStream FileOutputStream FileReader FileWriter 访问数组 ByteArrayInputStream ByteArrayOutputStream CharArrayReader CharArrayWriter 访问管道 PipedInputStream PipedOutputStream PipedReader PipedWriter 访问字符串 StringReader StringWriter 缓冲流 BufferedInputStream BufferedOutputStream BufferedReader BufferedWriter 转换流 InputStreamReader OutputStreamWriter 对象流 ObjectInputStream ObjectOutputStream FilterInputStream FilterOutputStream FilterReader FilterWriter 打印流 PrintStream PrintWriter 推回输入流 PushbackInputStream PushbackReader 特殊流 DataInputStream DataOutputStream 节点流(或文件流) FileInputStream FileOutputStream FileReader FileWriter FileReader与FileWriterFileReader读入数据的基本操作将hello.txt文件内容读入程序中，并输出到控制台 说明： read()的理解：返回读入的一个字符。如果达到文件末尾，返回-1 异常的处理：为了保证流资源一定可以执行关闭操作。需要使用try-catch-finally处理 读入的文件一定要存在，否则就会报FileNotFoundException。 1234567891011121314151617181920212223242526272829303132333435363738394041424344 @Test public void testFileReader()&#123; FileReader fr = null; try &#123; //1.实例化File类的对象，指明要操作的文件 File file = new File(&quot;hello.txt&quot;);//相较于当前Module //2.提供具体的流 fr = new FileReader(file); //3.数据的读入 //read():返回读入的一个字符。如果达到文件末尾，返回-1 //方式一：// int data = fr.read();// while(data != -1)&#123;// System.out.print((char)data);// data = fr.read();// &#125; //方式二：语法上针对于方式一的修改 int data; while((data = fr.read()) != -1)&#123; System.out.print((char)data); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //4.流的关闭操作// try &#123;// if(fr != null)// fr.close();// &#125; catch (IOException e) &#123;// e.printStackTrace();// &#125; //或 if(fr != null)&#123; try &#123; fr.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; FileReader中使用read(char[] cbuf)读入数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//对read()操作升级：使用read的重载方法 @Test public void testFileReader1() &#123; FileReader fr = null; try &#123; //1.File类的实例化 File file = new File(&quot;hello.txt&quot;); //2.FileReader流的实例化 fr = new FileReader(file); //3.读入的操作 //read(char[] cbuf):返回每次读入cbuf数组中的字符的个数。如果达到文件末尾，返回-1 char[] cbuf = new char[5]; int len; while((len = fr.read(cbuf)) != -1)&#123; //方式一： //错误的写法// for(int i = 0;i &lt; cbuf.length;i++)&#123;// System.out.print(cbuf[i]);// &#125; //正确的写法// for(int i = 0;i &lt; len;i++)&#123;// System.out.print(cbuf[i]);// &#125; //方式二： //错误的写法,对应着方式一的错误的写法// String str = new String(cbuf);// System.out.print(str); //正确的写法 String str = new String(cbuf,0,len); System.out.print(str); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(fr != null)&#123; //4.资源的关闭 try &#123; fr.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; FileWriter写出数据的操作 输出操作，对应的File可以不存在的。并不会报异常 File对应的硬盘中的文件如果不存在，在输出的过程中，会自动创建此文件。 File对应的硬盘中的文件如果存在： 如果流使用的构造器是：FileWriter(file,false) / FileWriter(file):对原有文件的覆盖 如果流使用的构造器是：FileWriter(file,true):不会对原有文件覆盖，而是在原有文件基础上追加内容 123456789101112131415161718192021222324252627@Testpublic void testFileWriter() &#123; FileWriter fw = null; try &#123; //1.提供File类的对象，指明写出到的文件 File file = new File(&quot;hello1.txt&quot;); //2.提供FileWriter的对象，用于数据的写出 fw = new FileWriter(file,false); //3.写出的操作 fw.write(&quot;I have a dream!\\n&quot;); fw.write(&quot;you need to have a dream!&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //4.流资源的关闭 if(fw != null)&#123; try &#123; fw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 使用FileReader和FileWriter实现文本文件的复制123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 @Test public void testFileReaderFileWriter() &#123; FileReader fr = null; FileWriter fw = null; try &#123; //1.创建File类的对象，指明读入和写出的文件 File srcFile = new File(&quot;hello.txt&quot;); File destFile = new File(&quot;hello2.txt&quot;); //不能使用字符流来处理图片等字节数据// File srcFile = new File(&quot;爱情与友情.jpg&quot;);// File destFile = new File(&quot;爱情与友情1.jpg&quot;); //2.创建输入流和输出流的对象 fr = new FileReader(srcFile); fw = new FileWriter(destFile); //3.数据的读入和写出操作 char[] cbuf = new char[5]; int len;//记录每次读入到cbuf数组中的字符的个数 while((len = fr.read(cbuf)) != -1)&#123; //每次写出len个字符 fw.write(cbuf,0,len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //4.关闭流资源 //方式一：// try &#123;// if(fw != null)// fw.close();// &#125; catch (IOException e) &#123;// e.printStackTrace();// &#125;finally&#123;// try &#123;// if(fr != null)// fr.close();// &#125; catch (IOException e) &#123;// e.printStackTrace();// &#125;// &#125; //方式二： try &#123; if(fw != null) fw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if(fr != null) fr.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; FileInputStream与FileOutputStreamFileInputStream不能读取文本文件 对于文本文件(.txt,.java,.c,.cpp)，使用字符流处理 对于非文本文件(.jpg,.mp3,.mp4,.avi,.doc,.ppt,…)，使用字节流处理 1234567891011121314151617181920212223242526272829303132333435//使用字节流FileInputStream处理文本文件，可能出现乱码。@Testpublic void testFileInputStream() &#123; FileInputStream fis = null; try &#123; //1. 造文件 File file = new File(&quot;hello.txt&quot;); //2.造流 fis = new FileInputStream(file); //3.读数据 byte[] buffer = new byte[5]; int len;//记录每次读取的字节的个数 while((len = fis.read(buffer)) != -1)&#123; String str = new String(buffer,0,len); System.out.print(str); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(fis != null)&#123; //4.关闭资源 try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; FileInputStream和FileOutputStream读写非文本文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*实现对图片的复制操作 */@Testpublic void testFileInputOutputStream() &#123; FileInputStream fis = null; FileOutputStream fos = null; try &#123; // File srcFile = new File(&quot;爱情与友情.jpg&quot;); File destFile = new File(&quot;爱情与友情2.jpg&quot;); // fis = new FileInputStream(srcFile); fos = new FileOutputStream(destFile); //复制的过程 byte[] buffer = new byte[5]; int len; while((len = fis.read(buffer)) != -1)&#123; fos.write(buffer,0,len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(fos != null)&#123; // try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(fis != null)&#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 使用FileInputStream和FileOutputStream复制文件的方法测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 //指定路径下文件的复制 public void copyFile(String srcPath,String destPath)&#123; FileInputStream fis = null; FileOutputStream fos = null; try &#123; // File srcFile = new File(srcPath); File destFile = new File(destPath); // fis = new FileInputStream(srcFile); fos = new FileOutputStream(destFile); //复制的过程 byte[] buffer = new byte[1024]; int len; while((len = fis.read(buffer)) != -1)&#123; fos.write(buffer,0,len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(fos != null)&#123; // try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(fis != null)&#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; @Test public void testCopyFile()&#123; long start = System.currentTimeMillis(); String srcPath = &quot;C:\\\\Users\\\\Administrator\\\\Desktop\\\\01-视频.avi&quot;; String destPath = &quot;C:\\\\Users\\\\Administrator\\\\Desktop\\\\02-视频.avi&quot;; //如果不经过控制窗口看一下直接复制过去，不会出现乱码。相当于原封不动的搬过去。// String srcPath = &quot;hello.txt&quot;;// String destPath = &quot;hello3.txt&quot;; copyFile(srcPath,destPath); long end = System.currentTimeMillis(); System.out.println(&quot;复制操作花费的时间为：&quot; + (end - start));//618 &#125; 缓冲流(处理流的一种) BufferedInputStream BufferedOutputStream BufferedReader BufferedWriter 作用：提供流的读取、写入的速度。（提高读写速度的原因：内部提供了一个缓冲区） 处理流，就是“套接”在已有的流的基础上。 BufferedInputStream与BufferedOutputStream实现非文本文件的复制1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 /* 实现非文本文件的复制 */ @Test public void BufferedStreamTest() throws FileNotFoundException &#123; BufferedInputStream bis = null; BufferedOutputStream bos = null; try &#123; //1.造文件 File srcFile = new File(&quot;爱情与友情.jpg&quot;); File destFile = new File(&quot;爱情与友情3.jpg&quot;); //2.造流 //2.1 造节点流 FileInputStream fis = new FileInputStream(srcFile); FileOutputStream fos = new FileOutputStream(destFile); //2.2 造缓冲流 bis = new BufferedInputStream(fis); bos = new BufferedOutputStream(fos); //3.复制的细节：读取、写入 byte[] buffer = new byte[10]; int len; while((len = bis.read(buffer)) != -1)&#123; bos.write(buffer,0,len);// bos.flush();//刷新缓冲区 &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //4.资源关闭 //要求：先关闭外层的流，再关闭内层的流 if(bos != null)&#123; try &#123; bos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(bis != null)&#123; try &#123; bis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略.// fos.close();// fis.close(); &#125; &#125; 缓冲流与节点流读写速度的对比 提高读写速度的原因：内部提供了一个缓冲区 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 //实现文件复制的方法 public void copyFileWithBuffered(String srcPath,String destPath)&#123; BufferedInputStream bis = null; BufferedOutputStream bos = null; try &#123; //1.造文件 File srcFile = new File(srcPath); File destFile = new File(destPath); //2.造流 //2.1 造节点流 FileInputStream fis = new FileInputStream((srcFile)); FileOutputStream fos = new FileOutputStream(destFile); //2.2 造缓冲流 bis = new BufferedInputStream(fis); bos = new BufferedOutputStream(fos); //3.复制的细节：读取、写入 byte[] buffer = new byte[1024]; int len; while((len = bis.read(buffer)) != -1)&#123; bos.write(buffer,0,len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //4.资源关闭 //要求：先关闭外层的流，再关闭内层的流 if(bos != null)&#123; try &#123; bos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(bis != null)&#123; try &#123; bis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略.// fos.close();// fis.close(); &#125; &#125; @Test public void testCopyFileWithBuffered()&#123; long start = System.currentTimeMillis(); String srcPath = &quot;C:\\\\Users\\\\Administrator\\\\Desktop\\\\01-视频.avi&quot;; String destPath = &quot;C:\\\\Users\\\\Administrator\\\\Desktop\\\\03-视频.avi&quot;; copyFileWithBuffered(srcPath,destPath); long end = System.currentTimeMillis(); System.out.println(&quot;复制操作花费的时间为：&quot; + (end - start));//618 - 176 &#125; BufferedReader与BufferedWriter实现文本文件的复制123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/*使用BufferedReader和BufferedWriter实现文本文件的复制*/ @Test public void testBufferedReaderBufferedWriter()&#123; BufferedReader br = null; BufferedWriter bw = null; try &#123; //创建文件和相应的流 br = new BufferedReader(new FileReader(new File(&quot;dbcp.txt&quot;))); bw = new BufferedWriter(new FileWriter(new File(&quot;dbcp1.txt&quot;))); //读写操作 //方式一：使用char[]数组// char[] cbuf = new char[1024];// int len;// while((len = br.read(cbuf)) != -1)&#123;// bw.write(cbuf,0,len);// // bw.flush();// &#125; //方式二：使用String String data; while((data = br.readLine()) != null)&#123; //方法一：// bw.write(data + &quot;\\n&quot;);//data中不包含换行符 //方法二： bw.write(data);//data中不包含换行符 bw.newLine();//提供换行的操作 &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //关闭资源 if(bw != null)&#123; try &#123; bw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(br != null)&#123; try &#123; br.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 转换流(处理流的一种) 作用：转换流提供了在字节流和字符流之间的转换 属于字符流 InputStreamReader：将一个字节的输入流转换为字符的输入流（解码） OutputStreamWriter：将一个字符的输出流转换为字节的输出流（编码） InputStreamReader的使用1234567891011121314151617181920212223/*此时处理异常的话，仍然应该使用try-catch-finallyInputStreamReader的使用，实现字节的输入流到字符的输入流的转换*/ @Test public void test1() throws IOException &#123; FileInputStream fis = new FileInputStream(&quot;dbcp.txt&quot;);// InputStreamReader isr = new InputStreamReader(fis);//使用系统默认的字符集 //参数2指明了字符集，具体使用哪个字符集，取决于文件dbcp.txt保存时使用的字符集 InputStreamReader isr = new InputStreamReader(fis,&quot;UTF-8&quot;);//使用系统默认的字符集 char[] cbuf = new char[20]; int len; while((len = isr.read(cbuf)) != -1)&#123; String str = new String(cbuf,0,len); System.out.print(str); &#125; isr.close(); &#125; 综合使用InputStreamReader和OutputStreamWriter1234567891011121314151617181920212223242526272829/*此时处理异常的话，仍然应该使用try-catch-finally综合使用InputStreamReader和OutputStreamWriter */@Testpublic void test2() throws Exception &#123; //1.造文件、造流 File file1 = new File(&quot;dbcp.txt&quot;); File file2 = new File(&quot;dbcp_gbk.txt&quot;); FileInputStream fis = new FileInputStream(file1); FileOutputStream fos = new FileOutputStream(file2); InputStreamReader isr = new InputStreamReader(fis,&quot;utf-8&quot;); OutputStreamWriter osw = new OutputStreamWriter(fos,&quot;gbk&quot;); //2.读写过程 char[] cbuf = new char[20]; int len; while((len = isr.read(cbuf)) != -1)&#123; osw.write(cbuf,0,len); &#125; //3.关闭资源 isr.close(); osw.close();&#125; 字符集 ASCII：美国标准信息交换码。用一个字节的7位可以表示。 ISO8859-1：拉丁码表。欧洲码表。用一个字节的8位表示。 GB2312：中国的中文编码表。最多两个字节编码所有字符 GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码 Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。 UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。 标准输入、输出流 System.in：标准的输入流，默认从键盘输入 System.out：标准的输出流，默认从控制台输出 System类的setIn(InputStream is) / setOut(PrintStream ps)方式重新指定输入和输出的流。 12345678910111213141516171819202122232425262728293031323334353637383940/*从键盘输入字符串，要求将读取到的整行字符串转成大写输出。然后继续进行输入操作，直至当输入“e”或者“exit”时，退出程序。方法一：使用Scanner实现，调用next()返回一个字符串方法二：使用System.in实现。System.in ---&gt; 转换流 ---&gt; BufferedReader的readLine() */public static void main(String[] args) &#123; BufferedReader br = null; try &#123; InputStreamReader isr = new InputStreamReader(System.in); br = new BufferedReader(isr); while (true) &#123; System.out.println(&quot;请输入字符串：&quot;); String data = br.readLine(); if (&quot;e&quot;.equalsIgnoreCase(data) || &quot;exit&quot;.equalsIgnoreCase(data)) &#123; System.out.println(&quot;程序结束&quot;); break; &#125; String upperCase = data.toUpperCase(); System.out.println(upperCase); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (br != null) &#123; try &#123; br.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 打印流 PrintStream PrintWriter 提供了一系列重载的print() 和 println() 123456789101112131415161718192021222324252627282930313233/*不在控制台显示打印结果，而将打印结果保存到一个文件中。*/@Testpublic void test2() &#123; PrintStream ps = null; try &#123; FileOutputStream fos = new FileOutputStream(new File(&quot;D:\\\\IO\\\\text.txt&quot;)); // 创建打印输出流,设置为自动刷新模式(写入换行符或字节 &#x27;\\n&#x27; 时都会刷新输出缓冲区) ps = new PrintStream(fos, true); if (ps != null) &#123;// 把标准输出流(控制台输出)改成文件 System.setOut(ps); &#125; for (int i = 0; i &lt;= 255; i++) &#123; // 输出ASCII字符 System.out.print((char) i); if (i % 50 == 0) &#123; // 每50个数据一行 System.out.println(); // 换行 &#125; &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if (ps != null) &#123; ps.close(); &#125; &#125;&#125; 数据流 DateInputStream DateOutputStream 作用：用于读取或写出基本数据类型的变量或字符串 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*练习：将内存中的字符串、基本数据类型的变量写出到文件中。注意：处理异常的话，仍然应该使用try-catch-finally. */@Testpublic void test3() throws IOException &#123; //1. DataOutputStream dos = new DataOutputStream(new FileOutputStream(&quot;data.txt&quot;)); //2. dos.writeUTF(&quot;刘建辰&quot;); dos.flush();//刷新操作，将内存中的数据写入文件 dos.writeInt(23); dos.flush(); dos.writeBoolean(true); dos.flush(); //3. dos.close();&#125;/*将文件中存储的基本数据类型变量和字符串读取到内存中，保存在变量中。注意点：读取不同类型的数据的顺序要与当初写入文件时，保存的数据的顺序一致！ */@Testpublic void test4() throws IOException &#123; //1. DataInputStream dis = new DataInputStream(new FileInputStream(&quot;data.txt&quot;)); //2. String name = dis.readUTF(); int age = dis.readInt(); boolean isMale = dis.readBoolean(); System.out.println(&quot;name = &quot; + name); System.out.println(&quot;age = &quot; + age); System.out.println(&quot;isMale = &quot; + isMale); //3. dis.close();&#125; 对象流 ObjectInputStream ObjectOutputStream 用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。 要想一个java对象是可序列化的，需要满足相应的要求。见Person.java。 对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其它程序获取了这种二进制流，就可以恢复成原来的Java对象。 对象流序列化和反序列化字符串操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/*序列化过程：将内存中的java对象保存到磁盘中或通过网络传输出去使用ObjectOutputStream实现 */@Testpublic void testObjectOutputStream()&#123; ObjectOutputStream oos = null; try &#123; //1. oos = new ObjectOutputStream(new FileOutputStream(&quot;object.dat&quot;)); //2. oos.writeObject(new String(&quot;我爱北京天安门&quot;)); oos.flush();//刷新操作 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(oos != null)&#123; //3. try &#123; oos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;/*反序列化：将磁盘文件中的对象还原为内存中的一个java对象使用ObjectInputStream来实现 */@Testpublic void testObjectInputStream()&#123; ObjectInputStream ois = null; try &#123; ois = new ObjectInputStream(new FileInputStream(&quot;object.dat&quot;)); Object obj = ois.readObject(); String str = (String) obj; System.out.println(str); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if(ois != null)&#123; try &#123; ois.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 自定义类实现序列化和反序列化操作Person需要满足如下的要求，方可序列化 需要实现接口：Serializable 当前类提供一个全局常量：serialVersionUID 除了当前Person类需要实现Serializable接口之外，还必须保证其内部所有属性也必须是可序列化的。（默认情况下，基本数据类型可序列化） 补充：ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179//Person类：import java.io.Serializable;public class Person implements Serializable&#123; public static final long serialVersionUID = 475463534532L; private String name; private int age; private int id; private Account acct; public Person(String name, int age, int id) &#123; this.name = name; this.age = age; this.id = id; &#125; public Person(String name, int age, int id, Account acct) &#123; this.name = name; this.age = age; this.id = id; this.acct = acct; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, id=&quot; + id + &quot;, acct=&quot; + acct + &#x27;&#125;&#x27;; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public Person() &#123; &#125;&#125;class Account implements Serializable&#123; public static final long serialVersionUID = 4754534532L; private double balance; @Override public String toString() &#123; return &quot;Account&#123;&quot; + &quot;balance=&quot; + balance + &#x27;&#125;&#x27;; &#125; public double getBalance() &#123; return balance; &#125; public void setBalance(double balance) &#123; this.balance = balance; &#125; public Account(double balance) &#123; this.balance = balance; &#125;&#125;//***************************************************************************//有Person类对象的序列化与反序列化 /* 序列化过程：将内存中的java对象保存到磁盘中或通过网络传输出去 使用ObjectOutputStream实现 */ @Test public void testObjectOutputStream()&#123; ObjectOutputStream oos = null; try &#123; //1. oos = new ObjectOutputStream(new FileOutputStream(&quot;object.dat&quot;)); //2. oos.writeObject(new String(&quot;我爱北京天安门&quot;)); oos.flush();//刷新操作 oos.writeObject(new Person(&quot;王铭&quot;,23)); oos.flush(); oos.writeObject(new Person(&quot;张学良&quot;,23,1001,new Account(5000))); oos.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(oos != null)&#123; //3. try &#123; oos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /* 反序列化：将磁盘文件中的对象还原为内存中的一个java对象 使用ObjectInputStream来实现 */ @Test public void testObjectInputStream()&#123; ObjectInputStream ois = null; try &#123; ois = new ObjectInputStream(new FileInputStream(&quot;object.dat&quot;)); Object obj = ois.readObject(); String str = (String) obj; Person p = (Person) ois.readObject(); Person p1 = (Person) ois.readObject(); System.out.println(str); System.out.println(p); System.out.println(p1); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if(ois != null)&#123; try &#123; ois.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 随机存取文件流(RandomAccessFile类)RandomAccessFile的使用 RandomAccessFile直接继承于java.lang.Object类，实现了DataInput和DataOutput接口 RandomAccessFile既可以作为一个输入流，又可以作为一个输出流 12345678910111213141516171819202122232425262728293031323334353637@Testpublic void test1() &#123; RandomAccessFile raf1 = null; RandomAccessFile raf2 = null; try &#123; //1. raf1 = new RandomAccessFile(new File(&quot;爱情与友情.jpg&quot;),&quot;r&quot;); raf2 = new RandomAccessFile(new File(&quot;爱情与友情1.jpg&quot;),&quot;rw&quot;); //2. byte[] buffer = new byte[1024]; int len; while((len = raf1.read(buffer)) != -1)&#123; raf2.write(buffer,0,len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //3. if(raf1 != null)&#123; try &#123; raf1.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(raf2 != null)&#123; try &#123; raf2.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 如果RandomAccessFile作为输出流时，写出到的文件如果不存在，则在执行过程中自动创建。如果写出到的文件存在，则会对原有文件内容进行覆盖。（默认情况下，从头覆盖） 1234567891011@Testpublic void test2() throws IOException &#123; RandomAccessFile raf1 = new RandomAccessFile(&quot;hello.txt&quot;,&quot;rw&quot;); raf1.seek(3);//将指针调到角标为3的位置,从第四位开始覆盖（覆盖第4、5、6位） raf1.write(&quot;xyz&quot;.getBytes());// raf1.close(); &#125; 可以通过相关的操作，实现RandomAccessFile“插入”数据的效果。 12345678910111213141516171819202122232425262728/*使用RandomAccessFile实现数据的插入效果*/ @Test public void test3() throws IOException &#123; RandomAccessFile raf1 = new RandomAccessFile(&quot;hello.txt&quot;,&quot;rw&quot;); raf1.seek(3);//将指针调到角标为3的位置 //保存指针3后面的所有数据到StringBuilder中 StringBuilder builder = new StringBuilder((int) new File(&quot;hello.txt&quot;).length()); byte[] buffer = new byte[20]; int len; while((len = raf1.read(buffer)) != -1)&#123; builder.append(new String(buffer,0,len)) ; &#125; //调回指针，写入“xyz” raf1.seek(3); raf1.write(&quot;xyz&quot;.getBytes()); //将StringBuilder中的数据写入到文件中 raf1.write(builder.toString().getBytes()); raf1.close(); //思考：将StringBuilder替换为ByteArrayOutputStream &#125; NIO.2中Path、Paths、 11 Files类的使用 jdk 7.0 时，引入了 Path、Paths、Files三个类。 此三个类声明在：java.nio.file包下。 Path可以看做是java.io.File类的升级版本。也可以表示文件或文件目录，与平台无关 如何实例化Path:使用Paths.static Path get(String first, String … more) : 用于将多个字符串串连成路径static Path get(URI uri): 返回指定uri对应的Path路径 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import org.junit.Test;import java.io.File;import java.nio.file.Path;import java.nio.file.Paths;public class PathTest &#123; //如何使用Paths实例化Path @Test public void test1() &#123; Path path1 = Paths.get(&quot;d:\\\\nio\\\\hello.txt&quot;);//new File(String filepath) Path path2 = Paths.get(&quot;d:\\\\&quot;, &quot;nio\\\\hello.txt&quot;);//new File(String parent,String filename); System.out.println(path1); System.out.println(path2); Path path3 = Paths.get(&quot;d:\\\\&quot;, &quot;nio&quot;); System.out.println(path3); &#125; //Path中的常用方法 @Test public void test2() &#123; Path path1 = Paths.get(&quot;d:\\\\&quot;, &quot;nio\\\\nio1\\\\nio2\\\\hello.txt&quot;); Path path2 = Paths.get(&quot;hello.txt&quot;);// String toString() ： 返回调用 Path 对象的字符串表示形式 System.out.println(path1);// boolean startsWith(String path) : 判断是否以 path 路径开始 System.out.println(path1.startsWith(&quot;d:\\\\nio&quot;));// boolean endsWith(String path) : 判断是否以 path 路径结束 System.out.println(path1.endsWith(&quot;hello.txt&quot;));// boolean isAbsolute() : 判断是否是绝对路径 System.out.println(path1.isAbsolute() + &quot;~&quot;); System.out.println(path2.isAbsolute() + &quot;~&quot;);// Path getParent() ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径 System.out.println(path1.getParent()); System.out.println(path2.getParent());// Path getRoot() ：返回调用 Path 对象的根路径 System.out.println(path1.getRoot()); System.out.println(path2.getRoot());// Path getFileName() : 返回与调用 Path 对象关联的文件名 System.out.println(path1.getFileName() + &quot;~&quot;); System.out.println(path2.getFileName() + &quot;~&quot;);// int getNameCount() : 返回Path 根目录后面元素的数量// Path getName(int idx) : 返回指定索引位置 idx 的路径名称 for (int i = 0; i &lt; path1.getNameCount(); i++) &#123; System.out.println(path1.getName(i) + &quot;*****&quot;); &#125;// Path toAbsolutePath() : 作为绝对路径返回调用 Path 对象 System.out.println(path1.toAbsolutePath()); System.out.println(path2.toAbsolutePath());// Path resolve(Path p) :合并两个路径，返回合并后的路径对应的Path对象 Path path3 = Paths.get(&quot;d:\\\\&quot;, &quot;nio&quot;); Path path4 = Paths.get(&quot;nioo\\\\hi.txt&quot;); path3 = path3.resolve(path4); System.out.println(path3);// File toFile(): 将Path转化为File类的对象 File file = path1.toFile();//Path---&gt;File的转换 Path newPath = file.toPath();//File---&gt;Path的转换 &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"泛型","date":"2021-05-04T01:47:41.000Z","path":"2021/05/04/泛型/","text":"为什么要有泛型（Generic）泛型的概念 所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参）。 从JDK1.5以后，Java引入了“参数化类型（Parameterized type）”的概念，允许我们在创建集合时再指定集合元素的类型，正如：List，这表明该List只能保存字符串类型的对象。 JDK1.5改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类型实参。 为什么要有泛型 解决元素存储的安全性问题，好比商品、药品标签，不会弄错。 解决获取数据元素时，需要类型强制转换的问题，好比不用每回拿商品、药品都要辨别。 Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁、健壮。 1234567891011121314151617181920 //在集合中使用泛型之前的情况： @Test public void test1()&#123; ArrayList list = new ArrayList(); //需求：存放学生的成绩 list.add(78); list.add(76); list.add(89); list.add(88); //问题一：类型不安全// list.add(&quot;Tom&quot;); for(Object score : list)&#123; //问题二：强转时，可能出现ClassCastException int stuScore = (Integer) score; System.out.println(stuScore); &#125; &#125; 在集合中使用泛型 集合接口或集合类在jdk5.0时都修改为带泛型的结构。 在实例化集合类时，可以指明具体的泛型类型 指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。比如：add(E e) —&gt;实例化以后：add(Integer e) 注意点：泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换 如果实例化时，没有指明泛型的类型。默认类型为java.lang.Object类型。 1234567891011121314151617181920212223242526272829303132import org.junit.Test;import java.util.*; //在集合中使用泛型的情况：以ArrayList为例 @Test public void test2()&#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(78); list.add(87); list.add(99); list.add(65); //编译时，就会进行类型检查，保证数据的安全// list.add(&quot;Tom&quot;); //方式一：// for(Integer score : list)&#123;// //避免了强转操作// int stuScore = score;//// System.out.println(stuScore);//// &#125; //方式二： Iterator&lt;Integer&gt; iterator = list.iterator(); while(iterator.hasNext())&#123; int stuScore = iterator.next(); System.out.println(stuScore); &#125; &#125; 12345678910111213141516171819202122232425262728import org.junit.Test;import java.util.*;//在集合中使用泛型的情况：以HashMap为例 @Test public void test3()&#123;// Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(); //jdk7新特性：类型推断 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(&quot;Tom&quot;,87); map.put(&quot;Jerry&quot;,87); map.put(&quot;Jack&quot;,67);// map.put(123,&quot;ABC&quot;); //泛型的嵌套 Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entry = map.entrySet(); Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = entry.iterator(); while(iterator.hasNext())&#123; Map.Entry&lt;String, Integer&gt; e = iterator.next(); String key = e.getKey(); Integer value = e.getValue(); System.out.println(key + &quot;----&quot; + value); &#125; &#125; 自定义泛型结构 泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：&lt;E1,E2,E3&gt;。 泛型类的构造器如下：public GenericClass(){}。而下面是错误的：public GenericClass&lt;E&gt;(){} 实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致。 泛型不同的引用不能相互赋值。 泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object。经验：泛型要使用一路都用。要不用，一路都不要用。 如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象。 12public class SubOrder extends Order&lt;Integer&gt; &#123;//SubOrder:不是泛型类&#125; 12public class SubOrder1&lt;T&gt; extends Order&lt;T&gt; &#123;//SubOrder1&lt;T&gt;:仍然是泛型类&#125; jdk1.7，泛型的简化操作：ArrayList&lt;Fruit&gt; flist = new ArrayList&lt;&gt;(); 泛型的指定中不能使用基本数据类型，可以使用包装类替换。 在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的泛型。 异常类不能是泛型的 123//异常类不能声明为泛型类//public class MyException&lt;T&gt; extends Exception&#123;//&#125; 不能使用new E[]。但是可以：E[] elements = (E[])new Object[capacity]; 父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型： 子类不保留父类的泛型：按需实现 没有类型 擦除 具体类型 子类保留父类的泛型：泛型子类 全部保留 部分保留 1234567891011121314151617181920212223242526272829303132333435class Father&lt;T1, T2&gt; &#123;&#125;// 子类不保留父类的泛型// 1)没有类型 擦除class Son1 extends Father &#123;// 等价于class Son extends Father&lt;Object,Object&gt;&#123;&#125;// 2)具体类型class Son2 extends Father&lt;Integer, String&gt; &#123;&#125;// 子类保留父类的泛型// 1)全部保留class Son3&lt;T1, T2&gt; extends Father&lt;T1, T2&gt; &#123;&#125;// 2)部分保留class Son4&lt;T2&gt; extends Father&lt;Integer, T2&gt; &#123;&#125;class Father&lt;T1, T2&gt; &#123;&#125;// 子类不保留父类的泛型// 1)没有类型 擦除class Son&lt;A, B&gt; extends Father&#123;//等价于class Son extends Father&lt;Object,Object&gt;&#123;&#125;// 2)具体类型class Son2&lt;A, B&gt; extends Father&lt;Integer, String&gt; &#123;&#125;// 子类保留父类的泛型// 1)全部保留class Son3&lt;T1, T2, A, B&gt; extends Father&lt;T1, T2&gt; &#123;&#125;// 2)部分保留class Son4&lt;T2, A, B&gt; extends Father&lt;Integer, T2&gt; &#123;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import org.junit.Test;import java.util.ArrayList;import java.util.List;/** 如何自定义泛型结构：泛型类、泛型接口；泛型方法。 * * 1. 关于自定义泛型类、泛型接口： */public class GenericTest1 &#123; @Test public void test1()&#123; //如果定义了泛型类，实例化没有指明类的泛型，则认为此泛型类型为Object类型 //要求：如果大家定义了类是带泛型的，建议在实例化时要指明类的泛型。 Order order = new Order(); order.setOrderT(123); order.setOrderT(&quot;ABC&quot;); //建议：实例化时指明类的泛型 Order&lt;String&gt; order1 = new Order&lt;String&gt;(&quot;orderAA&quot;,1001,&quot;order:AA&quot;); order1.setOrderT(&quot;AA:hello&quot;); &#125; @Test public void test2()&#123; SubOrder sub1 = new SubOrder(); //由于子类在继承带泛型的父类时，指明了泛型类型。则实例化子类对象时，不再需要指明泛型。 sub1.setOrderT(1122); SubOrder1&lt;String&gt; sub2 = new SubOrder1&lt;&gt;(); sub2.setOrderT(&quot;order2...&quot;); &#125; @Test public void test3()&#123; ArrayList&lt;String&gt; list1 = null; ArrayList&lt;Integer&gt; list2 = new ArrayList&lt;Integer&gt;(); //泛型不同的引用不能相互赋值。// list1 = list2; Person p1 = null; Person p2 = null; p1 = p2; &#125; //测试泛型方法 @Test public void test4()&#123; Order&lt;String&gt; order = new Order&lt;&gt;(); Integer[] arr = new Integer[]&#123;1,2,3,4&#125;; //泛型方法在调用时，指明泛型参数的类型。 List&lt;Integer&gt; list = order.copyFromArrayToList(arr); System.out.println(list); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.util.ArrayList;import java.util.List;public class Order&lt;T&gt; &#123; String orderName; int orderId; //类的内部结构就可以使用类的泛型 T orderT; public Order()&#123; //编译不通过// T[] arr = new T[10]; //编译通过 T[] arr = (T[]) new Object[10]; &#125; public Order(String orderName,int orderId,T orderT)&#123; this.orderName = orderName; this.orderId = orderId; this.orderT = orderT; &#125; //如下的三个方法都不是泛型方法 public T getOrderT()&#123; return orderT; &#125; public void setOrderT(T orderT)&#123; this.orderT = orderT; &#125; @Override public String toString() &#123; return &quot;Order&#123;&quot; + &quot;orderName=&#x27;&quot; + orderName + &#x27;\\&#x27;&#x27; + &quot;, orderId=&quot; + orderId + &quot;, orderT=&quot; + orderT + &#x27;&#125;&#x27;; &#125; //静态方法中不能使用类的泛型。// public static void show(T orderT)&#123;// System.out.println(orderT);// &#125; public void show()&#123; //编译不通过// try&#123;////// &#125;catch(T t)&#123;//// &#125; &#125; //泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系。 //换句话说，泛型方法所属的类是不是泛型类都没有关系。 //泛型方法，可以声明为静态的。原因：泛型参数是在调用方法时确定的。并非在实例化类时确定。 public static &lt;E&gt; List&lt;E&gt; copyFromArrayToList(E[] arr)&#123; ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;(); for(E e : arr)&#123; list.add(e); &#125; return list; &#125;&#125; 泛型在继承上的体现 虽然类A是类B的父类，但是G&lt;A&gt; 和G&lt;B&gt;二者不具备子父类关系，二者是并列关系。 补充：类A是类B的父类，A&lt;G&gt; 是 B&lt;G&gt; 的父类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//类A是类B的父类，但是G&lt;A&gt; 和G&lt;B&gt;二者不具备子父类关系，二者是并列关系。@Test public void test1()&#123; Object obj = null; String str = null; obj = str;//可以 Object[] arr1 = null; String[] arr2 = null; arr1 = arr2;//可以 //编译不通过// Date date = new Date();// str = date; List&lt;Object&gt; list1 = null; List&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); //此时的list1和list2的类型不具有子父类关系 //编译不通过// list1 = list2; /* 反证法： 假设list1 = list2; list1.add(123);导致混入非String的数据。出错。 */ show(list1); show1(list2); &#125; public void show1(List&lt;String&gt; list)&#123; &#125; public void show(List&lt;Object&gt; list)&#123; &#125;//类A是类B的父类，A&lt;G&gt; 是 B&lt;G&gt; 的父类 @Test public void test2()&#123; AbstractList&lt;String&gt; list1 = null; List&lt;String&gt; list2 = null; ArrayList&lt;String&gt; list3 = null; list1 = list3; list2 = list3; List&lt;String&gt; list4 = new ArrayList&lt;&gt;(); &#125; 通配符的使用通配符的使用 通配符：?（英文下的?） 类A是类B的父类，G&lt;A&gt;和G&lt;B&gt;是没有关系的，二者共同的父类是：G&lt;?&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142 @Test public void test3()&#123; List&lt;Object&gt; list1 = null; List&lt;String&gt; list2 = null; List&lt;?&gt; list = null; //此时都可以赋值给list list = list1; list = list2; //编译通过// print(list1);// print(list2); // List&lt;String&gt; list3 = new ArrayList&lt;&gt;(); list3.add(&quot;AA&quot;); list3.add(&quot;BB&quot;); list3.add(&quot;CC&quot;); list = list3; //添加(写入)：对于List&lt;?&gt;就不能向其内部添加数据。 //除了添加null之外。// list.add(&quot;DD&quot;);// list.add(&#x27;?&#x27;); list.add(null); //获取(读取)：允许读取数据，读取的数据类型为Object。 Object o = list.get(0); System.out.println(o); &#125; public void print(List&lt;?&gt; list)&#123; Iterator&lt;?&gt; iterator = list.iterator(); while(iterator.hasNext())&#123; Object obj = iterator.next(); System.out.println(obj); &#125; &#125; 有限制条件的通配符的使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* ? extends A: G&lt;? extends A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的子类 ? super A: G&lt;? super A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的父类*///父类public class Person &#123;&#125;//子类public class Student extends Person &#123;&#125; @Test public void test4()&#123; List&lt;? extends Person&gt; list1 = null; List&lt;? super Person&gt; list2 = null; List&lt;Student&gt; list3 = new ArrayList&lt;Student&gt;(); List&lt;Person&gt; list4 = new ArrayList&lt;Person&gt;(); List&lt;Object&gt; list5 = new ArrayList&lt;Object&gt;(); list1 = list3; list1 = list4;// list1 = list5;//出错// list2 = list3;//出错 list2 = list4; list2 = list5; //读取数据： list1 = list3; Person p = list1.get(0); //编译不通过 //Student s = list1.get(0); list2 = list4; Object obj = list2.get(0); ////编译不通过// Person obj = list2.get(0); //写入数据： //编译不通过// list1.add(new Student()); //编译通过 list2.add(new Person()); list2.add(new Student()); &#125; 泛型应用举例123456789101112131415161718public static void main(String[] args) &#123; HashMap&lt;String, ArrayList&lt;Citizen&gt;&gt; map = new HashMap&lt;String, ArrayList&lt;Citizen&gt;&gt;(); ArrayList&lt;Citizen&gt; list = new ArrayList&lt;Citizen&gt;(); list.add(new Citizen(&quot;刘恺威&quot;)); list.add(new Citizen(&quot;杨幂&quot;)); list.add(new Citizen(&quot;小糯米&quot;)); map.put(&quot;刘恺威&quot;, list); Set&lt;Entry&lt;String, ArrayList&lt;Citizen&gt;&gt;&gt; entrySet = map.entrySet(); Iterator&lt;Entry&lt;String, ArrayList&lt;Citizen&gt;&gt;&gt; iterator = entrySet.iterator(); while (iterator.hasNext()) &#123; Entry&lt;String, ArrayList&lt;Citizen&gt;&gt; entry = iterator.next(); String key = entry.getKey(); ArrayList&lt;Citizen&gt; value = entry.getValue(); System.out.println(&quot;户主：&quot; + key); System.out.println(&quot;家庭成员：&quot; + value); &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java集合","date":"2021-04-27T12:53:13.000Z","path":"2021/04/27/Java集合/","text":"Java集合框架概述集合框架的概述 集合、数组都是对多个数据进行存储操作的结构，简称Java容器。 说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（.txt,.jpg,.avi，数据库中） 数组在存储多个数据方面的特点： 一旦初始化以后，其长度就确定了。 数组一旦定义好，其元素的类型也就确定了。我们也就只能操作指定类型的数据了。 比如：String[] arr; int[] arr1;Object[] arr2; 数组在存储多个数据方面的缺点： 一旦初始化以后，其长度就不可修改。 数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。 获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用 数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足。 Java集合的两种体系Collection体系Collection接口：单列集合，用来存储一个一个的对象 List接口：存储有序的、可重复的数据。 –&gt;“动态”数组 ArrayList、LinkedList、Vector Set接口：存储无序的、不可重复的数据 –&gt;高中讲的“集合” HashSet、LinkedHashSet、TreeSet Map体系Map接口：双列集合，用来存储一对(key - value)一对的数据 –&gt;高中函数：y = f(x) HashMap、LinkedHashMap、TreeMap、Hashtable、Properties Collection接口方法 add(Object e):将元素e添加到集合coll中 addAll(Collection coll1):将coll1集合中的元素添加到当前的集合中 size():获取添加的元素的个数 clear():清空集合元素 isEmpty():判断当前集合是否为空 123456789101112131415161718192021222324252627282930313233import java.util.ArrayList;import java.util.Collection;public class Demo&#123; public static void main(String[] args) &#123; Collection coll = new ArrayList(); //add(Object e):将元素e添加到集合coll中 coll.add(&quot;AA&quot;); coll.add(&quot;bb&quot;); coll.add(123);// coll.add(new Date()); //size():获取添加的元素的个数 System.out.println(coll.size()); System.out.println(coll); Collection coll1 = new ArrayList(); coll1.add(456); //addAll(Collection coll1):将coll1集合中的元素添加到当前的集合中 coll.addAll(coll1); System.out.println(coll); System.out.println(coll.size()); //clear():清空集合元素 coll.clear(); System.out.println(coll); //isEmpty():判断当前集合是否为空 System.out.println(coll.isEmpty()); &#125;&#125; contains(Object obj):判断当前集合中是否包含obj containsAll(Collection coll1):判断形参coll1中的所有元素是否都存在于当前集合中。 12345678910111213141516171819202122232425 @Test public void test()&#123; Collection coll = new ArrayList(); coll.add(123); coll.add(456);// Person p = new Person(&quot;Jerry&quot;,20);// coll.add(p); coll.add(new Person(&quot;Jerry&quot;,20));//从自定义的Person类中添加 coll.add(new String(&quot;Tom&quot;)); coll.add(false); //1.contains(Object obj):判断当前集合中是否包含obj //我们在判断时会调用obj对象所在类的equals()。 boolean contains = coll.contains(123);//判断coll中有无123 System.out.println(contains); System.out.println(coll.contains(new String(&quot;Tom&quot;)));//true// System.out.println(coll.contains(p));//true //Person中重写了equals，此时从false变成true System.out.println(coll.contains(new Person(&quot;Jerry&quot;,20)));//false --&gt;true //2.containsAll(Collection coll1):判断形参coll1中的所有元素是否都存在于当前集合中。 Collection coll1 = Arrays.asList(123,4567);// System.out.println(&quot;coll1:&quot;+coll1);//coll1:[123, 4567] System.out.println(coll.containsAll(coll1));//false,此时[123, 4567]并不都在coll中。 &#125; remove(Object obj):从当前集合中移除的obj元素。（从前往后遍历，只删除第一次遇到的第一个obj元素。） removeAll(Collection coll1):差集：从当前集合中移除coll1中所有的元素。（这里是移除所有的元素） 1234567891011121314151617181920212223@Testpublic void test()&#123; //3.remove(Object obj):从当前集合中移除的obj元素。（从前往后遍历，只删除第一次遇到的第一个obj元素。） Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(new Person(&quot;Jerry&quot;,20)); coll.add(new String(&quot;Tom&quot;)); coll.add(false); coll.remove(1234);//移除1234，找到返回true，找不到返回false System.out.println(coll.remove(1234));//没找到1234，返回值为false System.out.println(coll);//这里没找到，输出的还是原来的coll coll.remove(new Person(&quot;Jerry&quot;,20));//重写equals后可以移除 System.out.println(coll); //4. removeAll(Collection coll1):差集：从当前集合中移除coll1中所有的元素。（这里是移除所有的元素） Collection coll1 = Arrays.asList(123,456); coll.removeAll(coll1); System.out.println(coll);&#125; retainAll(Collection coll1):交集：获取当前集合和coll1集合的交集，并返回给当前集合 equals(Object obj):要想返回true，需要当前集合和形参集合的元素都相同。 1234567891011121314151617181920212223242526 @Test public void test()&#123; Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(new Person(&quot;Jerry&quot;,20)); coll.add(new String(&quot;Tom&quot;)); coll.add(false); //5.retainAll(Collection coll1):交集：获取当前集合和coll1集合的交集，并返回给当前集合// Collection coll1 = Arrays.asList(123,456,789);//如果没有交集，则返回[]// coll.retainAll(coll1);// System.out.println(coll);//[123, 456],交集 //6.equals(Object obj):要想返回true，需要当前集合和形参集合的元素都相同。 Collection coll2 = new ArrayList();//ArrayList()是有序的。 coll2.add(456); coll2.add(123); coll2.add(new Person(&quot;Jerry&quot;,20)); coll2.add(new String(&quot;Tom&quot;)); coll2.add(false); System.out.println(&quot;coll:&quot;+coll); System.out.println(&quot;coll2:&quot;+coll2); System.out.println(coll.equals(coll2));//coll与coll2的顺序也必须一样才是一样的。 &#125; hashCode():返回当前对象的哈希值 集合 —&gt;数组：toArray() iterator():返回Iterator接口的实例，用于遍历集合元素。放在IteratorTest.java中测试 12345678910111213141516171819202122232425262728293031323334353637383940 @Test public void test()&#123; Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(new Person(&quot;Jerry&quot;,20)); coll.add(new String(&quot;Tom&quot;)); coll.add(false); //7.hashCode():返回当前对象的哈希值 System.out.println(coll.hashCode()); //8.集合 ---&gt;数组：toArray() Object[] arr = coll.toArray(); for(int i = 0;i &lt; arr.length;i++)&#123; if(i == 0 )&#123; System.out.print(arr[i]+&quot; &quot;); &#125;else if(i == arr.length-1)&#123; System.out.println(arr[i]); &#125;else&#123; System.out.print(arr[i]+&quot; &quot;); &#125; &#125; //拓展：数组 ---&gt;集合:调用Arrays类的静态方法asList() List&lt;String&gt; list = Arrays.asList(new String[]&#123;&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;&#125;); System.out.println(list); List arr1 = Arrays.asList(new int[]&#123;123, 456&#125;); System.out.println(arr1);//[[I@e580929] System.out.println(arr1.size());//1 List arr2 = Arrays.asList(new Integer[]&#123;123, 456&#125;); System.out.println(arr2);//[123, 456] System.out.println(arr2.size());//2 //9.iterator():返回Iterator接口的实例，用于遍历集合元素。后面详细说 &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//Person类import java.util.Objects;public class Person &#123; private String name; private int age; public Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; @Override public boolean equals(Object o) &#123; System.out.println(&quot;Person equals()....&quot;); if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return age == person.age &amp;&amp; Objects.equals(name, person.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125;&#125; Iterator迭代器接口集合元素的遍历操作：使用迭代器Iterator接口 内部的方法：hasNext() 和 next() 1234567891011121314151617181920212223242526272829303132 @Test public void test1()&#123; Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(new Person(&quot;Jerry&quot;,20)); coll.add(new String(&quot;Tom&quot;)); coll.add(false); Iterator iterator = coll.iterator(); //方式一：不推荐// System.out.println(iterator.next());// System.out.println(iterator.next());// System.out.println(iterator.next());// System.out.println(iterator.next());// System.out.println(iterator.next());// //报异常：NoSuchElementException// System.out.println(iterator.next()); //方式二：不推荐// for(int i = 0;i &lt; coll.size();i++)&#123;// System.out.println(iterator.next());// &#125; //方式三：推荐 ////hasNext():判断是否还有下一个元素 while(iterator.hasNext())&#123; //next():①指针下移 ②将下移以后集合位置上的元素返回 System.out.println(iterator.next()); &#125; &#125; Iterator遍历集合的两种错误方式 集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。 12345678910111213141516171819202122 @Test public void test2()&#123; Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(new Person(&quot;Jerry&quot;,20)); coll.add(new String(&quot;Tom&quot;)); coll.add(false); //错误方式一：// Iterator iterator = coll.iterator();// while((iterator.next()) != null)&#123;// System.out.println(iterator.next());// &#125; //错误方式二： //集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。 while (coll.iterator().hasNext())&#123; System.out.println(coll.iterator().next()); &#125; &#125; Iterator迭代器remove()的使用 内部定义了remove(),可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用remove() 1234567891011121314151617181920212223242526272829 @Test public void test()&#123; Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(new Person(&quot;Jerry&quot;,20)); coll.add(new String(&quot;Tom&quot;)); coll.add(false); //删除集合中&quot;Tom&quot; Iterator iterator = coll.iterator(); while (iterator.hasNext())&#123;// iterator.remove(); Object obj = iterator.next(); if(&quot;Tom&quot;.equals(obj))&#123; iterator.remove();// iterator.remove(); &#125; &#125; //遍历集合 iterator = coll.iterator(); while (iterator.hasNext())&#123; System.out.println(iterator.next()); &#125; &#125;//注意：//如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法，再调用remove都会报IllegalStateException。 使用foreach循环遍历集合元素 JDK5.0 新增了foreach循环，用于遍历集合、数组 123456789101112131415@Testpublic void test()&#123; Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(new Person(&quot;Jerry&quot;,20)); coll.add(new String(&quot;Tom&quot;)); coll.add(false); //for(集合元素的类型 局部变量 : 集合对象) //内部仍然调用了迭代器。 for(Object obj : coll)&#123; System.out.println(obj); &#125;&#125; 12345678910//遍历数组举例@Testpublic void test2()&#123; int[] arr = new int[]&#123;1,2,3,4,5,6&#125;; //for(数组元素的类型 局部变量 : 数组对象) for(int i : arr)&#123; System.out.println(i); &#125;&#125; 练习题1234567891011121314151617181920212223//比较普通for赋值与增强foreach赋值的区别@Testpublic void test3()&#123; String[] arr = new String[]&#123;&quot;MM&quot;,&quot;MM&quot;,&quot;MM&quot;&#125;; //方式一：普通for赋值 //此时输出的是GG for(int i = 0;i &lt; arr.length;i++)&#123; arr[i] = &quot;GG&quot;; &#125; //方式二：增强for循环 //此时输出的是MM，因为这里重新赋了一个值s for(String s : arr)&#123; s = &quot;GG&quot;; &#125; for(int i = 0;i &lt; arr.length;i++)&#123; System.out.println(arr[i]); &#125;&#125; Collection子接口一：ListList接口概述 List接口：存储有序的、可重复的数据。 –&gt;“动态”数组,替换原有的数组 JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。 ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储 LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储 Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储 ArrayList的源码分析JDK 7情况下12345678ArrayList list = new ArrayList();//底层创建了长度是10的Object[]数组elementDatalist.add(123);//elementData[0] = new Integer(123); ...list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容。//默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。//结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity) JDK 8中ArrayList的变化123456ArrayList list = new ArrayList();//底层Object[] elementData初始化为&#123;&#125;.并没有创建长度为10的数组list.add(123);//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]... //后续的添加和扩容操作与JDK 7 无异。 小结 jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。 LinkedList的源码分析123456789101112131415LinkedList list = new LinkedList(); 内部声明了Node类型的first和last属性，默认值为nulllist.add(123);//将123封装到Node中，创建了Node对象。//其中，Node定义为：体现了LinkedList的双向链表的说法private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; Vector的源码分析1//jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。在扩容方面，默认扩容为原来的数组长度的2倍。 ArrayList、LinkedList、Vector三者的异同？ 同：三个类都是实现了List接口，存储数据的特点相同：存储有序的、可重复的数据 不同：如上所示 List接口中的常用方法测试 void add(int index, Object ele):在index位置插入ele元素 boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来 Object get(int index):获取指定index位置的元素 12345678910111213141516171819202122232425 @Test public void test1()&#123; ArrayList list = new ArrayList(); list.add(123); list.add(456); list.add(&quot;AA&quot;); list.add(new Person(&quot;Tom&quot;,12)); list.add(456); System.out.println(list); //void add(int index, Object ele):在index位置插入ele元素 list.add(1,&quot;BB&quot;); System.out.println(list); //boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来 List list1 = Arrays.asList(1, 2, 3); list.addAll(list1);// list.add(list1);//将list1看出一个整体加入 System.out.println(list.size());//9 //Object get(int index):获取指定index位置的元素 System.out.println(list.get(0)); &#125; int indexOf(Object obj):返回obj在集合中首次出现的位置 int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置 Object remove(int index):移除指定index位置的元素，并返回此元素 Object set(int index, Object ele):设置指定index位置的元素为ele List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合 123456789101112131415161718192021222324252627282930@Testpublic void test2()&#123; ArrayList list = new ArrayList(); list.add(123); list.add(456); list.add(&quot;AA&quot;); list.add(new Person(&quot;Tom&quot;,12)); list.add(456); //int indexOf(Object obj):返回obj在集合中首次出现的位置。如果不存在，返回-1. int index = list.indexOf(4567); System.out.println(index); //int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置。如果不存在，返回-1. System.out.println(list.lastIndexOf(456)); //Object remove(int index):移除指定index位置的元素，并返回此元素 Object obj = list.remove(0); System.out.println(obj);//返回的是删除这个位置上的元素。 System.out.println(list); //Object set(int index, Object ele):设置指定index位置的元素为ele list.set(1,&quot;CC&quot;); System.out.println(list); //List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的左闭右开区间的子集合 List subList = list.subList(2, 4); System.out.println(subList); System.out.println(list); &#125; 总结1234567891011121314151617181920212223242526272829303132333435363738394041/*总结：常用方法增：add(Object obj)删：remove(int index) / remove(Object obj)改：set(int index, Object ele)查：get(int index)插：add(int index, Object ele)长度：size()遍历：① Iterator迭代器方式 ② 增强for循环 ③ 普通的循环*/ @Test public void test3()&#123; ArrayList list = new ArrayList(); list.add(123); list.add(456); list.add(&quot;AA&quot;); //方式一：Iterator迭代器方式 Iterator iterator = list.iterator(); while(iterator.hasNext())&#123; System.out.println(iterator.next()); &#125; System.out.println(&quot;***************&quot;); //方式二：增强for循环 for(Object obj : list)&#123; System.out.println(obj); &#125; System.out.println(&quot;***************&quot;); //方式三：普通for循环 for(int i = 0;i &lt; list.size();i++)&#123; System.out.println(list.get(i)); &#125; &#125; 面试题1234567891011121314151617181920212223import org.junit.Test;import java.util.ArrayList;import java.util.List;public class ListExer &#123; /* 区分List中remove(int index)和remove(Object obj) */ @Test public void testListRemove() &#123; List list = new ArrayList(); list.add(1); list.add(2); list.add(3); updateList(list); System.out.println(list);// &#125; private void updateList(List list) &#123;// list.remove(2); list.remove(new Integer(2)); &#125;&#125; Collection子接口二：SetSet接口概述 Set接口：存储无序的、不可重复的数据 –&gt;高中讲的“集合” JDK API中Set接口的实现类常用的有：HashSet、LinkedHashSet和TreeSet。 HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值。 LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历对于频繁的遍历操作，LinkedHashSet效率高于HashSet。 TreeSet：可以按照添加对象的指定属性，进行排序。 Set的一些说明(以HashSet为例)Set：存储无序的、不可重复的数据以HashSet为例说明： 无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。 不可重复性：保证添加的元素按照equals()判断时，不能返回true.即：相同的元素只能添加一个。 添加元素的过程以HashSet为例 123456789101112131415161718/*我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置），判断数组此位置上是否已经有元素： 如果此位置上没有其他元素，则元素a添加成功。 ---&gt;情况1 如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值： 如果hash值不相同，则元素a添加成功。---&gt;情况2 如果hash值相同，进而需要调用元素a所在类的equals()方法： equals()返回true,元素a添加失败 equals()返回false,则元素a添加成功。---&gt;情况2对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。jdk 7 :元素a放到数组中，指向原来的元素。jdk 8 :原来的元素在数组中，指向元素a总结：七上八下HashSet底层：数组+链表的结构。*/ 要求 要求：向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode()和equals() 要求：重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码 重写两个方法的小技巧：对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。 LinkedHashSet的使用 LinkedHashSet作为HashSet的子类，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。 优点：对于频繁的遍历操作，LinkedHashSet效率高于HashSet 123456789101112131415161718//此时怎么按添加的顺序来输出数据。@Test public void test2()&#123; Set set = new LinkedHashSet(); set.add(456); set.add(123); set.add(123); set.add(&quot;AA&quot;); set.add(&quot;CC&quot;); set.add(new User(&quot;Tom&quot;,12)); set.add(new User(&quot;Tom&quot;,12)); set.add(129); Iterator iterator = set.iterator(); while(iterator.hasNext())&#123; System.out.println(iterator.next()); &#125; &#125; TreeSet的使用TreeSet的自然排序 向TreeSet中添加的数据，要求是相同类的对象。 两种排序方式：自然排序（实现Comparable接口） 和 定制排序（Comparator） 自然排序中，比较两个对象是否相同的标准为：compareTo()返回0.不再是equals()。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 @Test public void test1()&#123; TreeSet set = new TreeSet(); //失败：不能添加不同类的对象// set.add(123);// set.add(456);// set.add(&quot;AA&quot;);// set.add(new User(&quot;Tom&quot;,12)); //举例一：// set.add(34);// set.add(-34);// set.add(43);// set.add(11);// set.add(8); //举例二： //需要重写User中的compareTo方法 set.add(new User(&quot;Tom&quot;,12)); set.add(new User(&quot;Jerry&quot;,32)); set.add(new User(&quot;Jim&quot;,2)); set.add(new User(&quot;Mike&quot;,65)); set.add(new User(&quot;Jack&quot;,33)); set.add(new User(&quot;Jack&quot;,56)); Iterator iterator = set.iterator(); while(iterator.hasNext())&#123; System.out.println(iterator.next()); &#125; &#125;//User类中：重写compareTo方法 @Override public int compareTo(Object o) &#123; if(o instanceof User)&#123; User user = (User)o;// return -this.name.compareTo(user.name); int compare = -this.name.compareTo(user.name); if(compare != 0)&#123; return compare; &#125;else&#123; return Integer.compare(this.age,user.age); &#125; &#125;else&#123; throw new RuntimeException(&quot;输入的类型不匹配&quot;); &#125; &#125; TreeSet的定制排序 定制排序中，比较两个对象是否相同的标准为：compare()返回0，不再是equals()。 1234567891011121314151617181920212223242526272829303132@Testpublic void test2()&#123; Comparator com = new Comparator() &#123; //按照年龄从小到大排列 @Override public int compare(Object o1, Object o2) &#123; if(o1 instanceof User &amp;&amp; o2 instanceof User)&#123; User u1 = (User)o1; User u2 = (User)o2; return Integer.compare(u1.getAge(),u2.getAge()); &#125;else&#123; throw new RuntimeException(&quot;输入的数据类型不匹配&quot;); &#125; &#125; &#125;; //不加参数com，按自然排序来；加了参数com，按这个参数来。 TreeSet set = new TreeSet(com); set.add(new User(&quot;Tom&quot;,12)); set.add(new User(&quot;Jerry&quot;,32)); set.add(new User(&quot;Jim&quot;,2)); set.add(new User(&quot;Mike&quot;,65)); set.add(new User(&quot;Mary&quot;,33)); set.add(new User(&quot;Jack&quot;,33)); set.add(new User(&quot;Jack&quot;,56)); Iterator iterator = set.iterator(); while(iterator.hasNext())&#123; System.out.println(iterator.next()); &#125;&#125; Map接口Map接口概述Map:双列数据，存储key-value对的数据 —类似于高中的函数：y = f(x) HashMap:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value LinkedHashMap:保证在遍历map元素时，可以按照添加的顺序实现遍历。 原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。对于频繁的遍历操作，此类执行效率高于HashMap。 TreeMap:保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序，底层使用红黑树。 Hashtable:作为古老的实现类；线程安全的，效率低；不能存储null的key和value Properties:常用来处理配置文件。key和value都是String类型 HashMap的底层： 数组+链表 （jdk7及之前） 数组+链表+红黑树 （jdk 8） Map结构的理解一个键值对：key-value构成了一个Entry对象。 Map中的key:无序的、不可重复的，使用Set存储所有的key —&gt; key所在的类要重写equals()和hashCode() （以HashMap为例） Map中的value:无序的、可重复的，使用Collection存储所有的value —&gt;value所在的类要重写equals() Map中的entry:无序的、不可重复的，使用Set存储所有的entry HashMap的底层实现原理以JDK7为例1234567891011121314151617/*HashMap map = new HashMap():在实例化以后，底层创建了长度是16的一维数组Entry[] table。...可能已经执行过多次put...map.put(key1,value1):首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。如果此位置上的数据为空，此时的key1-value1添加成功。 ----情况1如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据的哈希值： 如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。----情况2 如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较： 如果equals()返回false:此时key1-value1添加成功。----情况3 如果equals()返回true:使用value1替换value2。补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。*/ jdk8 相较于jdk7在底层实现方面的不同 new HashMap():底层没有创建一个长度为16的数组 jdk 8底层的数组是：Node[],而非Entry[] 首次调用put()方法时，底层创建长度为16的数组 jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。 形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素） 当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。 HashMap的源码分析专用词： DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16 DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75 threshold：扩容的临界值，=容量*填充因子：16 * 0.75 =&gt; 12 TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8 MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64 LinkedHashMap的底层实现原理（了解）1234567源码中：tatic class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after;//能够记录添加的元素的先后顺序 Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125;&#125; Map接口的常用方法1234567891011121314151617181920212223242526272829303132333435363738/*添加、删除、修改操作：Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中void putAll(Map m):将m中的所有key-value对存放到当前map中Object remove(Object key)：移除指定key的key-value对，并返回valuevoid clear()：清空当前map中的所有数据*/ @Test public void test()&#123; Map map = new HashMap(); //添加 map.put(&quot;AA&quot;,123); map.put(45,123); map.put(&quot;BB&quot;,56); //修改 map.put(&quot;AA&quot;,87); System.out.println(map); Map map1 = new HashMap(); map1.put(&quot;CC&quot;,123); map1.put(&quot;DD&quot;,123); map.putAll(map1); System.out.println(map); //remove(Object key) Object value = map.remove(&quot;CC&quot;); System.out.println(value); System.out.println(map); //clear() map.clear();//与map = null操作不同 System.out.println(map.size()); System.out.println(map); &#125; 123456789101112131415161718192021222324252627282930/*元素查询的操作：Object get(Object key)：获取指定key对应的valueboolean containsKey(Object key)：是否包含指定的keyboolean containsValue(Object value)：是否包含指定的valueint size()：返回map中key-value对的个数boolean isEmpty()：判断当前map是否为空boolean equals(Object obj)：判断当前map和参数对象obj是否相等*/ @Test public void test4()&#123; Map map = new HashMap(); map.put(&quot;AA&quot;,123); map.put(45,123); map.put(&quot;BB&quot;,56); // Object get(Object key) System.out.println(map.get(45)); //containsKey(Object key) boolean isExist = map.containsKey(&quot;BB&quot;); System.out.println(isExist); isExist = map.containsValue(123); System.out.println(isExist); map.clear(); System.out.println(map.isEmpty()); &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*元视图操作的方法：Set keySet()：返回所有key构成的Set集合Collection values()：返回所有value构成的Collection集合Set entrySet()：返回所有key-value对构成的Set集合*/ @Test public void test5()&#123; Map map = new HashMap(); map.put(&quot;AA&quot;,123); map.put(45,1234); map.put(&quot;BB&quot;,56); //遍历所有的key集：keySet() Set set = map.keySet(); Iterator iterator = set.iterator(); while(iterator.hasNext())&#123; System.out.println(iterator.next()); &#125; System.out.println(); //遍历所有的value集：values() Collection values = map.values(); for(Object obj : values)&#123; System.out.println(obj); &#125; System.out.println(); //遍历所有的key-value //方式一：entrySet() Set entrySet = map.entrySet(); Iterator iterator1 = entrySet.iterator(); while (iterator1.hasNext())&#123; Object obj = iterator1.next(); //entrySet集合中的元素都是entry Map.Entry entry = (Map.Entry) obj; System.out.println(entry.getKey() + &quot;----&gt;&quot; + entry.getValue()); &#125; System.out.println(); //方式二： Set keySet = map.keySet(); Iterator iterator2 = keySet.iterator(); while(iterator2.hasNext())&#123; Object key = iterator2.next(); Object value = map.get(key); System.out.println(key + &quot;=====&quot; + value); &#125; &#125; 12345678910//总结/*总结：常用方法：添加：put(Object key,Object value)删除：remove(Object key)修改：put(Object key,Object value)查询：get(Object key)长度：size()遍历：keySet() / values() / entrySet()*/ TreeMap 向TreeMap中添加key-value，要求key必须是由同一个类创建的对象 因为要按照key进行排序：自然排序 、定制排序 自然排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//自然排序@Testpublic void test1()&#123; TreeMap map = new TreeMap(); User u1 = new User(&quot;Tom&quot;,23); User u2 = new User(&quot;Jerry&quot;,32); User u3 = new User(&quot;Jack&quot;,20); User u4 = new User(&quot;Rose&quot;,18); map.put(u1,98); map.put(u2,89); map.put(u3,76); map.put(u4,100); Set entrySet = map.entrySet(); Iterator iterator1 = entrySet.iterator(); while (iterator1.hasNext())&#123; Object obj = iterator1.next(); Map.Entry entry = (Map.Entry) obj; System.out.println(entry.getKey() + &quot;----&gt;&quot; + entry.getValue()); &#125;&#125;//User类：public class User implements Comparable&#123; private String name; private int age; public User() &#123; &#125; public User(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; @Override public boolean equals(Object o) &#123; System.out.println(&quot;User equals()....&quot;); if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; User user = (User) o; if (age != user.age) return false; return name != null ? name.equals(user.name) : user.name == null; &#125; @Override public int hashCode() &#123; //return name.hashCode() + age; int result = name != null ? name.hashCode() : 0; result = 31 * result + age; return result; &#125; //按照姓名从大到小排列,年龄从小到大排列 @Override public int compareTo(Object o) &#123; if(o instanceof User)&#123; User user = (User)o;// return -this.name.compareTo(user.name); int compare = -this.name.compareTo(user.name); if(compare != 0)&#123; return compare; &#125;else&#123; return Integer.compare(this.age,user.age); &#125; &#125;else&#123; throw new RuntimeException(&quot;输入的类型不匹配&quot;); &#125; &#125;&#125; 定制排序123456789101112131415161718192021222324252627282930313233//定制排序@Testpublic void test2()&#123; TreeMap map = new TreeMap(new Comparator() &#123; @Override public int compare(Object o1, Object o2) &#123; if(o1 instanceof User &amp;&amp; o2 instanceof User)&#123; User u1 = (User)o1; User u2 = (User)o2; return Integer.compare(u1.getAge(),u2.getAge()); &#125; throw new RuntimeException(&quot;输入的类型不匹配！&quot;); &#125; &#125;); User u1 = new User(&quot;Tom&quot;,23); User u2 = new User(&quot;Jerry&quot;,32); User u3 = new User(&quot;Jack&quot;,20); User u4 = new User(&quot;Rose&quot;,18); map.put(u1,98); map.put(u2,89); map.put(u3,76); map.put(u4,100); Set entrySet = map.entrySet(); Iterator iterator1 = entrySet.iterator(); while (iterator1.hasNext())&#123; Object obj = iterator1.next(); Map.Entry entry = (Map.Entry) obj; System.out.println(entry.getKey() + &quot;----&gt;&quot; + entry.getValue()); &#125;&#125; Properties类 Properties 类是 Hashtable 的子类，该对象用于处理属性文件 由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 key 和 value 都是字符串类型 存取数据时，建议使用setProperty(String key,String value)方法和 getProperty(String key)方法 123456789101112131415161718192021222324252627282930313233343536//需要创建相关的配置文件import java.io.FileInputStream;import java.io.IOException;import java.util.Properties;public class PropertiesTest &#123; //Properties:常用来处理配置文件。key和value都是String类型 public static void main(String[] args) &#123; FileInputStream fis = null; try &#123; Properties pros = new Properties(); fis = new FileInputStream(&quot;jdbc.properties&quot;); pros.load(fis);//加载流对应的文件 String name = pros.getProperty(&quot;name&quot;); String password = pros.getProperty(&quot;password&quot;); System.out.println(&quot;name = &quot; + name + &quot;, password = &quot; + password); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(fis != null)&#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; Collections工具类 Collections 是一个操作 Set、List 和 Map 等集合的工具类 Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作， 还提供了对集合对象设置不可变、对集合对象实现同步控制等方法 Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集 合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全 问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/*reverse(List)：反转 List 中元素的顺序shuffle(List)：对 List 集合元素进行随机排序sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素Object min(Collection)Object min(Collection，Comparator)int frequency(Collection，Object)：返回指定集合中指定元素的出现次数void copy(List dest,List src)：将src中的内容复制到dest中boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值*/ @Test public void test1()&#123; List list = new ArrayList(); list.add(123); list.add(43); list.add(765); list.add(765); list.add(765); list.add(-97); list.add(0); System.out.println(list);// Collections.reverse(list);// Collections.shuffle(list);// Collections.sort(list);// Collections.swap(list,1,2); int frequency = Collections.frequency(list, 123); System.out.println(list); System.out.println(frequency); &#125; @Test public void test2()&#123; List list = new ArrayList(); list.add(123); list.add(43); list.add(765); list.add(-97); list.add(0); //报异常：IndexOutOfBoundsException(&quot;Source does not fit in dest&quot;)// List dest = new ArrayList();// Collections.copy(dest,list); //正确的： List dest = Arrays.asList(new Object[list.size()]); System.out.println(dest.size());//list.size(); Collections.copy(dest,list); System.out.println(dest); /* Collections 类中提供了多个 synchronizedXxx() 方法， 该方法可使将指定集合包装成线程同步的集合，从而可以解决 多线程并发访问集合时的线程安全问题 */ //返回的list1即为线程安全的List List list1 = Collections.synchronizedList(list); &#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"注解","date":"2021-04-26T13:51:20.000Z","path":"2021/04/26/注解/","text":"注解的概述 从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是Annotation(注解) Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。 Annotation 可以像修饰符一样被使用, 可用于修饰包,类, 构造器, 方法, 成员变量, 参数, 局部变量的声明, 这些信息被保存在 Annotation 的 “name=value” 对中。 在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。 未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，现在的Struts2有一部分也是基于注解的了，注解是一种趋势，一定程度上可以说：框架 = 注解 + 反射 + 设计模式。 常见的Annotation示例 示例一：生成文档相关的注解 示例二：在编译时进行格式检查(JDK内置的三个基本注解) @Override: 限定重写父类方法, 该注解只能用于方法 @Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择 @SuppressWarnings: 抑制编译器警告 示例三：跟踪代码依赖性，实现替代配置文件功能 自定义 Annotation自定义方法：参照@SuppressWarnings定义 注解声明为：@interface 内部定义成员，通常使用value表示 可以指定成员的默认值，使用default定义 如果自定义注解没有成员，表明是一个标识作用。 123public @interface MyAnnotation &#123; String value() default &quot;hello&quot;;&#125; 注意 如果注解有成员，在使用注解时，需要指明成员的值。 自定义注解必须配上注解的信息处理流程(使用反射)才有意义。 自定义注解通过都会指明两个元注解：Retention、Target。 jdk 提供的4种元注解什么是元注解 元注解：对现有的注解进行解释说明的注解。 4种元注解 @Retention：只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 的生命周期, @Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用@Rentention 时必须为该 value 成员变量指定值: SOURCE:在源文件中有效（即源文件保留），编译器直接丢弃这种策略的注释。 CLASS:在class文件中有效（即class保留） ， 当运行 Java 程序时, JVM 不会保留注解。 这是默认值。 RUNTIME:在运行时有效（即运行时保留），当运行 Java 程序时, JVM 会保留注释。程序可以通过反射获取该注释。 @Target: 用于修饰 Annotation 定义, 用于指定被修饰的 Annotation 能用于修饰哪些程序元素。 @Documented: 用于指定被该元 Annotation 修饰的 Annotation 类将被javadoc 工具提取成文档。默认情况下，javadoc是不包括注解的。 @Inherited: 被它修饰的 Annotation 将具有继承性。如果某个类使用了被@Inherited 修饰的 Annotation, 则其子类将自动具有该注解。 通过反射获取注解信息 到反射内容时系统讲解!!! jdk 8 中注解的新特性可重复注解 在MyAnnotation(自定义的注解)上声明@Repeatable，成员值为MyAnnotations.class MyAnnotation的Target和Retention等元注解与MyAnnotations相同。 类型注解 ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明）。 ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"枚举类","date":"2021-04-26T12:20:46.000Z","path":"2021/04/26/枚举类/","text":"枚举类的使用 枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类。 当需要定义一组常量时，强烈建议使用枚举类。 如果枚举类中只有一个对象，则可以作为单例模式的实现方式。 枚举类的定义方式一：jdk5.0之前，自定义枚举类1234567891011121314151617181920212223242526272829303132333435363738394041424344public class SeasonTest &#123; public static void main(String[] args) &#123; Season spring = Season.SPRING; System.out.println(spring); &#125;&#125;//自定义枚举类class Season&#123; //1.声明Season对象的属性:private final修饰 private final String seasonName; private final String seasonDesc; //2.私有化类的构造器,并给对象属性赋值 private Season(String seasonName,String seasonDesc)&#123; this.seasonName = seasonName; this.seasonDesc = seasonDesc; &#125; //3.提供当前枚举类的多个对象：public static final的 public static final Season SPRING = new Season(&quot;春天&quot;,&quot;春暖花开&quot;); public static final Season SUMMER = new Season(&quot;夏天&quot;,&quot;夏日炎炎&quot;); public static final Season AUTUMN = new Season(&quot;秋天&quot;,&quot;秋高气爽&quot;); public static final Season WINTER = new Season(&quot;冬天&quot;,&quot;冰天雪地&quot;); //4.其他诉求1：获取枚举类对象的属性 public String getSeasonName() &#123; return seasonName; &#125; public String getSeasonDesc() &#123; return seasonDesc; &#125; //4.其他诉求2：提供toString() @Override public String toString() &#123; return &quot;Season&#123;&quot; + &quot;seasonName=&#x27;&quot; + seasonName + &#x27;\\&#x27;&#x27; + &quot;, seasonDesc=&#x27;&quot; + seasonDesc + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 方式二：jdk5.0，可以使用enum关键字定义枚举类说明 定义的枚举类默认继承于java.lang.Enum类。 123456789101112131415161718enum SeasonEnum &#123; SPRING(&quot;春天&quot;,&quot;春风又绿江南岸&quot;), SUMMER(&quot;夏天&quot;,&quot;映日荷花别样红&quot;), AUTUMN(&quot;秋天&quot;,&quot;秋水共长天一色&quot;), WINTER(&quot;冬天&quot;,&quot;窗含西岭千秋雪&quot;); private final String seasonName; private final String seasonDesc; private SeasonEnum(String seasonName, String seasonDesc) &#123; this.seasonName = seasonName; this.seasonDesc = seasonDesc; &#125; public String getSeasonName() &#123; return seasonName; &#125; public String getSeasonDesc() &#123; return seasonDesc; &#125;&#125; Enum类的主要方法 values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。 valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。 toString()：返回当前枚举类对象常量的名称。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class Demo &#123; public static void main(String[] args) &#123; Season summer = Season.SUMMER; //toString():返回枚举类对象的名称 System.out.println(summer.toString()); System.out.println(&quot;****************&quot;); //values():返回所有的枚举类对象构成的数组 Season[] values = Season.values(); for(int i = 0;i &lt; values.length;i++)&#123; System.out.println(values[i]); &#125; System.out.println(&quot;****************&quot;); //valueOf(String objName):返回枚举类中对象名是objName的对象。 Season winter = Season1.valueOf(&quot;WINTER&quot;); //如果没有objName的枚举类对象，则抛异常：IllegalArgumentException// Season winter = Season1.valueOf(&quot;WINTER1&quot;); System.out.println(winter); &#125;&#125;//使用enum关键字枚举类enum Season &#123; //1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束 SPRING(&quot;春天&quot;,&quot;春暖花开&quot;), SUMMER(&quot;夏天&quot;,&quot;夏日炎炎&quot;), AUTUMN(&quot;秋天&quot;,&quot;秋高气爽&quot;), WINTER(&quot;冬天&quot;,&quot;冰天雪地&quot;); //2.声明Season对象的属性:private final修饰 private final String seasonName; private final String seasonDesc; //2.私有化类的构造器,并给对象属性赋值 private Season(String seasonName,String seasonDesc)&#123; this.seasonName = seasonName; this.seasonDesc = seasonDesc; &#125; //4.其他诉求1：获取枚举类对象的属性 public String getSeasonName() &#123; return seasonName; &#125; public String getSeasonDesc() &#123; return seasonDesc; &#125; //4.其他诉求1：提供toString() @Override public String toString() &#123; return &quot;Season&#123;&quot; + &quot;seasonName=&#x27;&quot; + seasonName + &#x27;\\&#x27;&#x27; + &quot;, seasonDesc=&#x27;&quot; + seasonDesc + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125;/*Season&#123;seasonName=&#x27;夏天&#x27;, seasonDesc=&#x27;夏日炎炎&#x27;&#125;****************Season&#123;seasonName=&#x27;春天&#x27;, seasonDesc=&#x27;春暖花开&#x27;&#125;Season&#123;seasonName=&#x27;夏天&#x27;, seasonDesc=&#x27;夏日炎炎&#x27;&#125;Season&#123;seasonName=&#x27;秋天&#x27;, seasonDesc=&#x27;秋高气爽&#x27;&#125;Season&#123;seasonName=&#x27;冬天&#x27;, seasonDesc=&#x27;冰天雪地&#x27;&#125;****************Season&#123;seasonName=&#x27;冬天&#x27;, seasonDesc=&#x27;冰天雪地&#x27;&#125;*/ 实现接口的枚举类 情况一：实现接口，在enum类中实现抽象方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Demo &#123; public static void main(String[] args) &#123; Season1 winter = Season1.valueOf(&quot;WINTER&quot;); System.out.println(winter); winter.show(); &#125;&#125;interface Info&#123; void show();&#125;//使用enum关键字枚举类enum Season1 implements Info&#123; //1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束 SPRING(&quot;春天&quot;,&quot;春暖花开&quot;), SUMMER(&quot;夏天&quot;,&quot;夏日炎炎&quot;), AUTUMN(&quot;秋天&quot;,&quot;秋高气爽&quot;), WINTER(&quot;冬天&quot;,&quot;冰天雪地&quot;); //2.声明Season对象的属性:private final修饰 private final String seasonName; private final String seasonDesc; //2.私有化类的构造器,并给对象属性赋值 private Season1(String seasonName,String seasonDesc)&#123; this.seasonName = seasonName; this.seasonDesc = seasonDesc; &#125; //4.其他诉求1：获取枚举类对象的属性 public String getSeasonName() &#123; return seasonName; &#125; public String getSeasonDesc() &#123; return seasonDesc; &#125; //重写接口中的方法 @Override public void show() &#123; System.out.println(&quot;这是一个季节&quot;); &#125;&#125; 情况二：让枚举类的对象分别实现接口中的抽象方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class Demo &#123; public static void main(String[] args) &#123; Season1[] values = Season1.values(); for(int i = 0;i &lt; values.length;i++)&#123; System.out.println(values[i]); values[i].show(); &#125; &#125;&#125;interface Info&#123; void show();&#125;//使用enum关键字枚举类enum Season1 implements Info&#123; //1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束 SPRING(&quot;春天&quot;,&quot;春暖花开&quot;)&#123; @Override public void show() &#123; System.out.println(&quot;春天在哪里？&quot;); &#125; &#125;, SUMMER(&quot;夏天&quot;,&quot;夏日炎炎&quot;)&#123; @Override public void show() &#123; System.out.println(&quot;宁夏&quot;); &#125; &#125;, AUTUMN(&quot;秋天&quot;,&quot;秋高气爽&quot;)&#123; @Override public void show() &#123; System.out.println(&quot;秋天不回来&quot;); &#125; &#125;, WINTER(&quot;冬天&quot;,&quot;冰天雪地&quot;)&#123; @Override public void show() &#123; System.out.println(&quot;大约在冬季&quot;); &#125; &#125;; //2.声明Season对象的属性:private final修饰 private final String seasonName; private final String seasonDesc; //2.私有化类的构造器,并给对象属性赋值 private Season1(String seasonName,String seasonDesc)&#123; this.seasonName = seasonName; this.seasonDesc = seasonDesc; &#125; //4.其他诉求1：获取枚举类对象的属性 public String getSeasonName() &#123; return seasonName; &#125; public String getSeasonDesc() &#123; return seasonDesc; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java常用类","date":"2021-04-21T07:47:54.000Z","path":"2021/04/21/Java常用类/","text":"字符串相关的类 String类及常用方法String的使用String：字符串，使用一对“ ”引起来表示。 String声明为final的，不可被继承。 String实现了Serializable接口：表示字符串是支持序列化的。 ​ 实现了Comparable接口：表示String可以比较大小。 String内部定义了final char[] value用于存储字符串数据。 String：代表不可变的字符序列。简称：不可变性。 体现： 当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。 字符串常量池中不会存储相同内容的字符串的。 String的实例化方式 方式一：通过字面量定义的方式 此时的数据声明在方法区的字符串常量池中。 方式二：通过new + 构造器的方式 此时的数据保存的地址值，是数据在堆空间中开辟空间以后对应的地址值。 123456789101112131415161718192021222324252627public void test()&#123; //通过字面量定义的方式：此时的s1和s2的数据javaEE声明在方法区中的字符串常量池中。 String s1 = &quot;javaEE&quot;; String s2 = &quot;javaEE&quot;; //通过new + 构造器的方式:此时的s3和s4保存的地址值，是数据在堆空间中开辟空间以后对应的地址值。 String s3 = new String(&quot;javaEE&quot;); String s4 = new String(&quot;javaEE&quot;); System.out.println(s1 == s2);//true System.out.println(s1 == s3);//false System.out.println(s1 == s4);//false System.out.println(s3 == s4);//false System.out.println(&quot;**********下面的要特别注意！！！*************&quot;); // Person类下面有定义 Person p1 = new Person(&quot;Tom&quot;,12); Person p2 = new Person(&quot;Tom&quot;,12); System.out.println(p1.name.equals(p2.name));//true // 此时p1和p2的name存储的地址值都是一样的，都是指向方法区里面的Tom System.out.println(p1.name == p2.name);//true // 如果p1.name发生修改，那么方法区会新生成一个，存储Jerry。之后p1.name存储Jerry方法区的地址，p2.name不变。 p1.name = &quot;Jerry&quot;; System.out.println(p2.name);//Tom&#125; 1234567891011121314// Person类如下：public class Person &#123; String name; int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public Person() &#123; &#125;&#125; 结论 常量与常量的拼接结果在常量池，且常量池中不会存在相同内容的常量。 只要其中一个是变量，结果就在堆中。 如果拼接的结果调用intern()方法，返回值就在常量池中。 123456789101112131415161718192021222324public void test3()&#123; String s1 = &quot;javaEE&quot;; String s2 = &quot;hadoop&quot;; String s3 = &quot;javaEEhadoop&quot;; String s4 = &quot;javaEE&quot; + &quot;hadoop&quot;; String s5 = s1 + &quot;hadoop&quot;; String s6 = &quot;javaEE&quot; + s2; String s7 = s1 + s2; // 结论1 System.out.println(s3 == s4);//true // 结论2 System.out.println(s3 == s5);//false System.out.println(s3 == s6);//false System.out.println(s3 == s7);//false System.out.println(s5 == s6);//false System.out.println(s5 == s7);//false System.out.println(s6 == s7);//false // 结论3 // 调用intern()的时候，返回值一定是在常量池当中 String s8 = s6.intern();//返回值得到的s8使用的常量值中已经存在的“javaEEhadoop” System.out.println(s3 == s8);//true&#125; 常用方法1234567891011121314151617181920212223242526272829303132int length()：返回字符串的长度： return value.lengthchar charAt(int index)： 返回某索引处的字符return value[index]boolean isEmpty()：判断是否是空字符串：return value.length == 0String toLowerCase()：使用默认语言环境，将 String 中的所有字符转换为小写String toUpperCase()：使用默认语言环境，将 String 中的所有字符转换为大写String trim()：返回字符串的副本，忽略前导空白和尾部空白boolean equals(Object obj)：比较字符串的内容是否相同boolean equalsIgnoreCase(String anotherString)：与equals方法类似，忽略大小写String concat(String str)：将指定字符串连接到此字符串的结尾。 等价于用“+”int compareTo(String anotherString)：比较两个字符串的大小String substring(int beginIndex)：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。String substring(int beginIndex, int endIndex) ：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。 boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始boolean contains(CharSequence s)：当且仅当此字符串包含指定的 char 值序列时，返回 trueint indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始int lastIndexOf(String str)：返回指定子字符串在此字符串中最右边出现处的索引int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索 替换：String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。String replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。String replaceAll(String regex, String replacement)：使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。String replaceFirst(String regex, String replacement)：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。匹配:boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式。切片：String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。 String与基本数据类型、包装类之间的转换 String –&gt; 基本数据类型、包装类：调用包装类的静态方法：Xxx.parseXxx(str)。 基本数据类型、包装类 –&gt; String：调用String重载的valueOf(xxx) 1234567891011121314public class Demo&#123; public static void main(String[] args)&#123; String s = &quot;1234&quot;; float num = Flaot.parseInt(s);//将字符串转换为float型 System.out.println(num); String s2 = String.valueOf(num);//将float型转换为字符串 &#125;&#125;//======================//1234.0////1234.0//====================== String与字符数组char[]转换 String –&gt; char[]:调用String的toCharArray() char[] –&gt; String:调用String的构造器 1234567891011121314public class Demo&#123; public static void main(String[] args)&#123; String s1 = &quot;Hello World&quot;; char[] char1 = s1.toCharArray(); for (int i = 0; i &lt; char1.length; i++) &#123; System.out.print(char1[i]); &#125; System.out.println(&quot;===================&quot;); String s2 = new String(char1); System.out.println(s2); &#125;&#125; String与字节数组byte[]转换 编码（字符串 –&gt;字节 (看得懂 —&gt;看不懂的二进制数据)）：String –&gt; byte[]:调用String的getBytes() 解码（编码的逆过程，字节 –&gt; 字符串 （看不懂的二进制数据 —&gt; 看得懂））：byte[] –&gt; String:调用String的构造器 注意：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。 123456789101112131415161718192021222324252627282930313233343536import java.io.UnsupportedEncodingException;import java.util.Arrays;public class Demo &#123; public static void main(String[] args) &#123; String str1 = &quot;abc123中国&quot;; byte[] bytes = str1.getBytes();//使用默认的字符集，进行编码。 System.out.println(Arrays.toString(bytes)); byte[] gbks = new byte[0];//使用gbk字符集进行编码。 try &#123; gbks = str1.getBytes(&quot;gbk&quot;); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; System.out.println(Arrays.toString(gbks)); System.out.println(&quot;******************&quot;); String str2 = new String(bytes);//使用默认的字符集，进行解码。 System.out.println(str2); String str3 = new String(gbks); System.out.println(str3);//出现乱码。原因：编码集和解码集不一致！ String str4 = null; try &#123; str4 = new String(gbks, &quot;gbk&quot;); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; System.out.println(str4);//没有出现乱码。原因：编码集和解码集一致！ &#125;&#125; 面试题String s = new String(“abc”);方式创建对象，在内存中创建了几个对象？ 答：两个：一个是堆空间中new结构，另一个是char[] 对应的常量池中的数据：”abc”。 StringBuffer、StringBuilderString、StringBuffer、StringBuilder三者的异同？ String: 不可变的字符序列； 底层使用char[]存储 StringBuffer: 可变的字符序列； 线程安全的，效率低； 底层使用char[]存储 StringBuilder: 可变的字符序列； jdk5.0新增的，线程不安全的，效率高； 底层使用char[]存储 源码分析12345678910111213141516171819 //空参的时候，顶层长度为0String str = new String();//char[] value = new char[0]; //此时顶层长度为3String str1 = new String(&quot;abc&quot;);//char[] value = new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;; //底层创建了一个长度是16的数组。StringBuffer sb1 = new StringBuffer();//char[] value = new char[16];System.out.println(sb1.length());//0; 底层虽然创建了一个长度为16的数组，但是事实上此时长度依然为0sb1.append(&#x27;a&#x27;);//value[0] = &#x27;a&#x27;;sb1.append(&#x27;b&#x27;);//value[1] = &#x27;b&#x27;;//此时除了abc长度为3外，额外又添加了16长度StringBuffer sb2 = new StringBuffer(&quot;abc&quot;);//char[] value = new char[&quot;abc&quot;.length() + 16];System.out.println(sb2.length());//3; 此时实际长度为3//扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。//默认情况下，扩容为原来容量的2倍 + 2，同时将原有数组中的元素复制到新的数组中。//指导意义：开发中建议大家使用：StringBuffer(int capacity) 或 StringBuilder(int capacity) StringBuffer、StringBuilder的常用方法1234567891011121314151617181920212223//这里用StringBuffer为例，StringBuilder一样。StringBuffer append(xxx)：提供了很多的append()方法，用于进行字符串拼接StringBuffer delete(int start,int end)：删除指定位置的内容，左闭右开[start,end)。StringBuffer replace(int start, int end, String str)：把[start,end)位置替换为str。StringBuffer insert(int offset, xxx)：在指定位置插入xxxStringBuffer reverse() ：把当前字符序列逆转public int indexOf(String str)：和String一样public String substring(int start,int end):返回一个从start开始到end索引结束的左闭右开区间的子字符串public int length()public char charAt(int n )：和String一样public void setCharAt(int n ,char ch)：将n处的字符改成ch。 /* 总结：增：append(xxx)删：delete(int start,int end)改：setCharAt(int n ,char ch) / replace(int start, int end, String str)查：charAt(int n )插：insert(int offset, xxx)长度：length();遍历：for() + charAt() / toString()*/ String、StringBuffer、StringBuilder三者的效率 从高到低排列：StringBuilder &gt; StringBuffer &gt; String 1234567891011121314151617181920212223242526272829303132//测试代码@Testpublic void test3()&#123; //初始设置 long startTime = 0L; long endTime = 0L; String text = &quot;&quot;; StringBuffer buffer = new StringBuffer(&quot;&quot;); StringBuilder builder = new StringBuilder(&quot;&quot;); //开始对比 startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 20000; i++) &#123; buffer.append(String.valueOf(i)); &#125; endTime = System.currentTimeMillis(); System.out.println(&quot;StringBuffer的执行时间：&quot; + (endTime - startTime)); startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 20000; i++) &#123; builder.append(String.valueOf(i)); &#125; endTime = System.currentTimeMillis(); System.out.println(&quot;StringBuilder的执行时间：&quot; + (endTime - startTime)); startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 20000; i++) &#123; text = text + i; &#125; endTime = System.currentTimeMillis(); System.out.println(&quot;String的执行时间：&quot; + (endTime - startTime));&#125; JDk8之前的日期时间APISystem静态方法12345678910System类中的currentTimeMillis()public class Demo01 &#123; public static void main(String[] args) &#123; long time = System.currentTimeMillis(); //返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。 //称为时间戳 System.out.println(time); &#125;&#125; Date类java.util.Date两个构造器的使用 构造器一：Date()：创建一个对应当前时间的Date对象 构造器二：创建指定毫秒数的Date对象 12345678910111213141516import java.util.Date;public class Demo&#123; public static void main(String[] args)&#123; //构造器一：Date()：创建一个对应当前时间的Date对象 Date date1 = new Date(); System.out.println(date1.toString());//Sat Apr 24 11:00:02 CST 2021 System.out.println(date1.getTime());//1619233202553（时间戳） //构造器二：创建指定毫秒数的Date对象 Date date2 = new Date(1619233202553L); System.out.println(date2.toString());//Sat Apr 24 11:00:02 CST 2021 &#125;&#125; 两个方法的使用 toString():显示当前的年、月、日、时、分、秒 getTime():获取当前Date对象对应的毫秒数。（时间戳） java.sql.Date123456789import java.sql.Date;public class Demo01 &#123; public static void main(String[] args) &#123; Date date = new Date(1619233202553L); System.out.println(date);//2021-04-24 &#125;&#125; java.util.Date对象转换为java.sql.Date对象 情况一 123Date date1 = new java.sql.Date(1619233202553L);//强制转换java.sql.Date date2 = (java.sql.Date) date1; 情况二 12Date date1 = new Date();java.sql.Date date2 = new java.sql.Date(date1.getTime());//将date1中的数拿过来用作参数 Calender类实例化以及常用方法 方式一：创建其子类（GregorianCalendar）的对象 方式二：调用其静态方法getInstance() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.text.ParseException;import java.util.Calendar;import java.util.Date;public class Demo &#123; public static void main(String[] args) throws ParseException &#123; //1. 实例化 //方式一：创建其子类（GregorianCalendar）的对象 //方式二：调用其静态方法getInstance() Calendar calendar = Calendar.getInstance(); //2. 常用方法 //get() int day = calendar.get(Calendar.DAY_OF_MONTH);//当前是这个月的第几天 System.out.println(&quot;今天是这个月的第&quot;+day+&quot;天&quot;); int year_day = calendar.get(Calendar.DAY_OF_YEAR);//当前是这一年的第几天 System.out.println(&quot;今天是这一年的第&quot;+calendar.get(Calendar.DAY_OF_YEAR)+&quot;天&quot;); //set() calendar.set(Calendar.DAY_OF_MONTH,15);//没有返回值，将calender这个对象本身改了 day = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(&quot;修改完后为这个月的第&quot;+day+&quot;天&quot;); //add() calendar.add(Calendar.DAY_OF_MONTH,3);//在现有的天数上面加amount天，之前为15，加3后为18 day = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(&quot;加3天后此时为这个月的第&quot;+day+&quot;天&quot;); //getTime():日历类---&gt; Date Date date = calendar.getTime(); System.out.println(date);//修改后的数据，此时为18号 //setTime():Date---&gt; 日历类 Date date1 = new Date(); calendar.setTime(date1);//将当前日期传递给calender day = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(day);//此时输出当前为这个月的第几天 &#125;&#125;/*今天是这个月的第25天今天是这一年的第115天修改完后为这个月的第15天加3天后此时为这个月的第18天Sun Apr 18 19:31:12 CST 202125*/ 注意事项 获取月份时：一月是0，二月是1，三月是2，…以此类推，十二月是11。 获取星期时：周日是1，周一是2，…，周六是7。 SimpleDateFormat类SimpleDateForma的使用 SimpleDateFormat对日期Date类的格式化和解析 两个操作 格式化：日期 —&gt;字符串 格式化的逆过程，字符串 —&gt; 日期 实例化123456789101112131415161718192021222324252627282930313233343536import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class Demo &#123; public static void main(String[] args) throws ParseException &#123; //实例化SimpleDateFormat:使用默认的构造器 SimpleDateFormat s1 = new SimpleDateFormat(); //格式化：日期 ---&gt;字符串 Date date = new Date(); String format = s1.format(date); System.out.println(format); //System.out.println(date); //解析：格式化的逆过程，字符串 ---&gt; 日期 String str = &quot;2021/4/25 下午6:31&quot;;//格式必须正确 Date parse = s1.parse(str);//解析会抛异常 System.out.println(parse); //*************按照指定的方式格式化和解析：调用带参的构造器***************** System.out.println(&quot;***************按照指定的方式格式化和解析：调用带参的构造器**************&quot;); SimpleDateFormat s2 = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);//年-月-日 时-分-秒 //格式化 String format1 = s2.format(date); System.out.println(format1); //解析 Date parse1 = s2.parse(format1);//将format1进行解析 System.out.println(parse1); System.out.println(&quot;************************&quot;); //解析:要求字符串必须是符合SimpleDateFormat识别的格式(通过构造器参数体现), //否则，抛异常 Date parse2 = s2.parse(&quot;2008-02-13 14:20:25&quot;);//自定义时间进行解析 System.out.println(parse2); &#125;&#125; 练习 字符串”2020-09-08”转换为java.sql.Date 12345678910111213141516import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class Demo &#123; public static void main(String[] args) throws ParseException &#123; String birth = &quot;2020-09-08&quot;; SimpleDateFormat s1 = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date date = s1.parse(birth); java.sql.Date birthDate = new java.sql.Date(date.getTime());//之前学过 System.out.println(birthDate); &#125;&#125; “三天打渔两天晒网” 1990-01-01 xxxx-xx-xx 打渔？晒网？ 1234567/*总天数 % 5 == 1,2,3 : 打渔 总天数 % 5 == 4,0 : 晒网 总天数的计算？ 方式一：( date2.getTime() - date1.getTime()) / (1000 * 60 * 60 * 24) + 1//这里好像不用考虑整除，因为此时好像一定除得尽。+1是为啥？ 方式二：1990-01-01 --&gt; 2019-12-31 + 2020-01-01 --&gt;2020-09-08//年+日*/ JDK8中新日期时间API背景 JDK1.0中包含了一个java.util.Date类，但是它的大多数方法已经在JDK1.1引入Calender类之后被舍弃了。而Calender并不比Date好多少。它们面临的问题是： 可变性：像日期和时间这样的类应该是不可变的。 偏移性：Date中的年份是从1900开始的，而月份都从0开始。 格式化：格式化只对Date有效，Calender则不行。 此外，它们也不是线程安全的；不能处理闰秒等。 123//偏移量Date date = new Date(2020 - 1900,9 - 1,8);//需要将偏移量减去System.out.println(date);//Tue Sep 08 00:00:00 GMT+08:00 2020 LocalDate、LocalTime、LocalDateTime LocaDate代表IOS格式（yyyy-MM-dd）的日期，可以存储生日、纪念日等日期。 LocalTime表示一个时间，而不是日期 LocalDateTime是用来表示日期和时间的，这是一个最常用的类之一。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;public class Demo &#123; public static void main(String[] args) &#123; /* LocalDate、LocalTime、LocalDateTime 的使用 说明： 1.LocalDateTime相较于LocalDate、LocalTime，使用频率要高 2.类似于Calendar */ //now():获取当前的日期、时间、日期+时间 LocalDate localDate = LocalDate.now();//获取当前的一个日期 LocalTime localTime = LocalTime.now();//获取当前的一个时间 LocalDateTime localDateTime = LocalDateTime.now();//获取当前的日期和时间 System.out.println(localDate);//2021-04-25 System.out.println(localTime);//20:01:39.028804800 System.out.println(localDateTime);//2021-04-25T20:01:39.028804800 //of():设置指定的年、月、日、时、分、秒。没有偏移量 LocalDateTime localDateTime1 = LocalDateTime.of(2021, 12, 13, 5, 12, 51); System.out.println(localDateTime1);//2021-12-13T05:12:51 //getXxx()：获取相关的属性 System.out.println(localDateTime.getDayOfMonth());//这个月的第几天，25 System.out.println(localDateTime.getDayOfWeek());//这一周的第几天，SUNDAY System.out.println(localDateTime.getMonth());//这个月，APRIL System.out.println(localDateTime.getMonthValue());//显示月数，4 System.out.println(localDateTime.getMinute());//分钟,9 //体现不可变性 //withXxx():设置相关的属性 LocalDate localDate1 = localDate.withDayOfMonth(22);//有返回值 System.out.println(localDate);//2021-04-25 System.out.println(localDate1);//2021-04-22 LocalDateTime localDateTime2 = localDateTime.withHour(4); System.out.println(localDateTime);//2021-04-25T20:14:08.642735500 System.out.println(localDateTime2);//2021-04-25T04:14:08.642735500，改成4点了 System.out.println(&quot;**********************&quot;); //不可变性 LocalDateTime localDateTime3 = localDateTime.plusMonths(3); System.out.println(localDateTime);//2021-04-25T20:15:43.408037800 System.out.println(localDateTime3);//2021-07-25T20:15:43.408037800 System.out.println(&quot;**********************&quot;); LocalDateTime localDateTime4 = localDateTime.minusDays(6); System.out.println(localDateTime);//2021-04-25T20:15:43.408037800 System.out.println(localDateTime4);//2021-04-19T20:15:43.408037800 &#125;&#125; Instant 类似于java.util.Date类 1234567891011121314151617181920212223242526import java.time.Instant;import java.time.OffsetDateTime;import java.time.ZoneOffset;public class Demo &#123; public static void main(String[] args) &#123; //now():获取本初子午线对应的标准时间 Instant instant = Instant.now(); System.out.println(instant);//2021-04-25T12:26:02.622597100Z,和北京时间来看，慢了8个小时，是本初子午线的时间。 // //添加时间的偏移量 OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(8)); System.out.println(offsetDateTime);//2021-04-25T20:26:02.622597100+08:00 //toEpochMilli():获取自1970年1月1日0时0分0秒（UTC）开始的毫秒数 ---&gt; Date类的getTime() long toEpochMilli = instant.toEpochMilli(); System.out.println(toEpochMilli);//1619353731188 //ofEpochMilli():通过给定的毫秒数，获取Instant实例 --&gt;Date(long millis) Instant instant1 = Instant.ofEpochMilli(1619353731188L); System.out.println(instant1);//2021-04-25T12:28:51.188Z &#125;&#125; DateTimeFormatter DateTimeFormatter:格式化或解析日期、时间类似于SimpleDateFormat 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.time.LocalDate;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;import java.time.format.FormatStyle;import java.time.temporal.TemporalAccessor;public class Demo &#123; public static void main(String[] args) &#123; //方式一：预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME; //格式化:日期--&gt;字符串 LocalDateTime localDateTime = LocalDateTime.now(); String str1 = formatter.format(localDateTime); System.out.println(localDateTime);//2021-04-25T20:37:38.048992200 System.out.println(str1);//2021-04-25T20:37:38.0489922 //解析：字符串 --&gt;日期 TemporalAccessor parse = formatter.parse(&quot;2021-04-25T20:37:38.0489922&quot;); System.out.println(parse);//&#123;&#125;,ISO resolved to 2021-04-25T20:37:38.048992200 //方式二： //本地化相关的格式。如：ofLocalizedDateTime() //这三个只是格式上面不太一样：FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT :适用于LocalDateTime DateTimeFormatter formatter1 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT); //格式化 String str2 = formatter1.format(localDateTime); System.out.println(str2);//2021/4/25 下午8:43 //本地化相关的格式。如：ofLocalizedDate() //FormatStyle.FULL / FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT : 适用于LocalDate DateTimeFormatter formatter2 = DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM); //格式化 String str3 = formatter2.format(LocalDate.now()); System.out.println(str3);//2021年4月25日 //重点： 方式三：自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”) DateTimeFormatter formatter3 = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd hh:mm:ss&quot;); //格式化 String str4 = formatter3.format(LocalDateTime.now()); System.out.println(str4);//2021-04-25 08:50:49 //解析 TemporalAccessor accessor = formatter3.parse(&quot;2021-04-25 08:50:49&quot;); System.out.println(accessor);//&#123;HourOfAmPm=8, MicroOfSecond=0, SecondOfMinute=49, MilliOfSecond=0, NanoOfSecond=0, MinuteOfHour=50&#125;,ISO resolved to 2021-04-25 &#125;&#125; 其他类 Zoneld：该类中包含了所有的时区信息，一个时区的ID，如Europe/Paris。 ZonedDate Time：一个在ISO-8601日历系统时区的日期时间 Clock：使用时区提供对当前即时、日期和时间的访问的时钟。 Duration：用于计算两个“时间”间隔。 Period：用于计算两个“日期”间隔。 TemporalAdjuster：时间矫正器。 TemporalAdjusters：该类通过静态方法（firstDayOfXxx()/lastDayOfXxx()/nextXxx()）提供了大量常用TemporalAdjuster的实现。 等等 Java比较器说明 Java中的对象，正常情况下，只能进行比较：== 或 != 。不能使用 &gt; 或 &lt; 的但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。如何实现？使用两个接口中的任何一个：Comparable 或 Comparator Comparable接口使用举例：自然排序 像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式。 像String、包装类重写compareTo()方法以后，进行了从小到大的排列 重写compareTo(obj)的规则： 如果当前对象this大于形参对象obj，则返回正整数 如果当前对象this小于形参对象obj，则返回负整数 如果当前对象this等于形参对象obj，则返回零 12345String[] arr = new String[]&#123;&quot;AA&quot;,&quot;CC&quot;,&quot;KK&quot;,&quot;MM&quot;,&quot;GG&quot;,&quot;JJ&quot;,&quot;DD&quot;&#125;;Arrays.sort(arr);System.out.println(Arrays.toString(arr)); 对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * 商品类 * @author shkstart * @create 2019 下午 4:52 */public class Goods implements Comparable&#123; private String name; private double price; public Goods() &#123; &#125; public Goods(String name, double price) &#123; this.name = name; this.price = price; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; @Override public String toString() &#123; return &quot;Goods&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, price=&quot; + price + &#x27;&#125;&#x27;; &#125; //指明商品比较大小的方式:按照价格从低到高排序,再按照产品名称从高到低排序 @Override public int compareTo(Object o) &#123;// System.out.println(&quot;**************&quot;); if(o instanceof Goods)&#123; Goods goods = (Goods)o; //方式一： if(this.price &gt; goods.price)&#123; return 1; &#125;else if(this.price &lt; goods.price)&#123; return -1; &#125;else&#123;// return 0; return -this.name.compareTo(goods.name);//-指按照产品名称从高到低排序 &#125; //方式二：// return Double.compare(this.price,goods.price); &#125;// return 0; throw new RuntimeException(&quot;传入的数据类型不一致！&quot;); &#125;&#125;//这里没写全，只是一个@Test@Testpublic void test2()&#123; Goods[] arr = new Goods[5]; arr[0] = new Goods(&quot;lenovoMouse&quot;,34); arr[1] = new Goods(&quot;dellMouse&quot;,43); arr[2] = new Goods(&quot;xiaomiMouse&quot;,12); arr[3] = new Goods(&quot;huaweiMouse&quot;,65); arr[4] = new Goods(&quot;microsoftMouse&quot;,43); Arrays.sort(arr); System.out.println(Arrays.toString(arr));&#125; Comparator接口使用举例：定制排序 背景：当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序。 重写compare(Object o1,Object o2)方法，比较o1和o2的大小： 如果方法返回正整数，则表示o1大于o2； 如果返回0，表示相等； 返回负整数，表示o1小于o2。 12345678910111213141516171819@Test public void test()&#123; String[] arr = new String[]&#123;&quot;AA&quot;,&quot;CC&quot;,&quot;KK&quot;,&quot;MM&quot;,&quot;GG&quot;,&quot;JJ&quot;,&quot;DD&quot;&#125;; Arrays.sort(arr,new Comparator()&#123; //按照字符串从大到小的顺序排列 @Override public int compare(Object o1, Object o2) &#123; if(o1 instanceof String &amp;&amp; o2 instanceof String)&#123; String s1 = (String) o1; String s2 = (String) o2; return -s1.compareTo(s2);//从大到小排 &#125;// return 0; throw new RuntimeException(&quot;输入的数据类型不一致&quot;); &#125; &#125;); System.out.println(Arrays.toString(arr)); &#125; 定制 1234567891011121314151617181920212223242526272829@Testpublic void test()&#123; Goods[] arr = new Goods[6]; arr[0] = new Goods(&quot;lenovoMouse&quot;,34); arr[1] = new Goods(&quot;dellMouse&quot;,43); arr[2] = new Goods(&quot;xiaomiMouse&quot;,12); arr[3] = new Goods(&quot;huaweiMouse&quot;,65); arr[4] = new Goods(&quot;huaweiMouse&quot;,224); arr[5] = new Goods(&quot;microsoftMouse&quot;,43); Arrays.sort(arr, new Comparator() &#123; //指明商品比较大小的方式:按照产品名称从低到高排序,再按照价格从高到低排序 @Override public int compare(Object o1, Object o2) &#123; if(o1 instanceof Goods &amp;&amp; o2 instanceof Goods)&#123; Goods g1 = (Goods)o1; Goods g2 = (Goods)o2; if(g1.getName().equals(g2.getName()))&#123; return -Double.compare(g1.getPrice(),g2.getPrice());//名字一样时候，按照价格排 &#125;else&#123; return g1.getName().compareTo(g2.getName()); &#125; &#125; throw new RuntimeException(&quot;输入的数据类型不一致&quot;); &#125; &#125;); System.out.println(Arrays.toString(arr));&#125; Comparable接口与Comparator的使用的对比 Comparable接口的方式一旦指定，保证Comparable接口实现类的对象在任何位置都可以比较大小。Comparator接口属于临时性的比较。 System类说明 System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。 由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。 成员变量 System类内部包含in、out和err三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。 成员方法 native long currentTimeMillis()：该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。 void exit(int status)：该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。 void gc()：该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。 String getProperty(String key)：该方法的作用是获得系统中属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示： 属性名 属性说明 java.version Java运行时环境版本 java.home Java安装目录 os.name 操作系统的名称 os.version 操作系统的版本 user.name 用户的账户名称 user.home 用户的主目录 user.dir 用户的当前工作目录 123456789101112131415161718192021222324@Testpublic void test() &#123; String javaVersion = System.getProperty(&quot;java.version&quot;); System.out.println(&quot;java的version:&quot; + javaVersion); String javaHome = System.getProperty(&quot;java.home&quot;); System.out.println(&quot;java的home:&quot; + javaHome); String osName = System.getProperty(&quot;os.name&quot;); System.out.println(&quot;os的name:&quot; + osName); String osVersion = System.getProperty(&quot;os.version&quot;); System.out.println(&quot;os的version:&quot; + osVersion); String userName = System.getProperty(&quot;user.name&quot;); System.out.println(&quot;user的name:&quot; + userName); String userHome = System.getProperty(&quot;user.home&quot;); System.out.println(&quot;user的home:&quot; + userHome); String userDir = System.getProperty(&quot;user.dir&quot;); System.out.println(&quot;user的dir:&quot; + userDir);&#125; Math类说明 java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型。 方法123456789101112abs 绝对值acos,asin,atan,cos,sin,tan 三角函数sqrt 平方根pow(double a,doble b) a的b次幂log 自然对数exp e为底指数max(double a,double b)min(double a,double b)random() 返回0.0到1.0的随机数long round(double a) double型数据a转换为long型（四舍五入）toDegrees(double angrad) 弧度—&gt;角度toRadians(double angdeg) 角度—&gt;弧度 BigInteger与BigDecimalBigInteger类说明 java.math包的BigInteger可以表示不可变的任意精度的整数。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。 构造器 BigInteger(String val)：根据字符串构建BigInteger对象 常用方法12345678public BigInteger abs()：返回此 BigInteger 的绝对值的 BigInteger。BigInteger add(BigInteger val) ：返回其值为 (this + val) 的 BigIntegerBigInteger subtract(BigInteger val) ：返回其值为 (this - val) 的 BigIntegerBigInteger multiply(BigInteger val) ：返回其值为 (this * val) 的 BigIntegerBigInteger divide(BigInteger val) ：返回其值为 (this / val) 的 BigInteger。整数相除只保留整数部分。BigInteger remainder(BigInteger val) ：返回其值为 (this % val) 的 BigInteger。BigInteger[] divideAndRemainder(BigInteger val)：返回包含 (this / val) 后跟(this % val) 的两个 BigInteger 的数组。BigInteger pow(int exponent) ：返回其值为 (thisexponent) 的 BigInteger。 BigDecimal类说明 一般的Float类和Double类可以用来做科学计算或工程计算，但在商业计算中，要求数字精度比较高，故用到java.math.BigDecimal类。BigDecimal类支持不可变的、任意精度的有符号十进制定点数。 构造器 public BigDecimal(double val)public BigDecimal(String val) 常用方法1234public BigDecimal add(BigDecimal augend)public BigDecimal subtract(BigDecimal subtrahend)public BigDecimal multiply(BigDecimal multiplicand)public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"多线程知识总结","date":"2021-04-19T12:01:32.000Z","path":"2021/04/19/死锁/","text":"死锁问题 死锁的理解 不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。 出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续。我们使用同步时，要避免出现死锁。 演示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//演示线程的死锁问题：public class ThreadTest &#123; public static void main(String[] args) &#123; StringBuffer s1 = new StringBuffer(); StringBuffer s2 = new StringBuffer(); new Thread()&#123; @Override public void run() &#123; synchronized (s1)&#123; s1.append(&quot;a&quot;); s2.append(&quot;1&quot;); //加了sleep后出现死锁的概率会大大增加。 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (s2)&#123; s1.append(&quot;b&quot;); s2.append(&quot;2&quot;); System.out.println(s1); System.out.println(s2); &#125;s &#125; &#125; &#125;.start(); new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (s2)&#123; s1.append(&quot;c&quot;); s2.append(&quot;3&quot;); //加了sleep后出现死锁的概率会大大增加。 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (s1)&#123; s1.append(&quot;d&quot;); s2.append(&quot;4&quot;); System.out.println(s1); System.out.println(s2); &#125; &#125; &#125; &#125;).start(); &#125;&#125;此时很大概率会出现程序会出现死锁，无法继续执行的问题。 解决方法 专门的算法、原则。 尽量减少同步资源的定义。 尽量避免嵌套同步。 Lock（锁）定义 解决线程安全问题的方式三（JDK5.0新增） 演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.concurrent.locks.ReentrantLock;class Window implements Runnable&#123; private int ticket = 100; //1.实例化ReentrantLock private ReentrantLock lock = new ReentrantLock(); @Override public void run() &#123; while (true)&#123; try &#123; //2.调用锁定方法：lock() lock.lock(); if(ticket &gt; 0)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;:售票，票号为：&quot;+ticket); ticket--; &#125;else&#123; break; &#125; &#125;finally &#123; //3.调用解锁的方法：unlock(); lock.unlock(); &#125; &#125; &#125;&#125;public class LockTest &#123; public static void main(String[] args) &#123; Window w = new Window(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; synchronize 与 Lock 的对比 Lock是显式锁（手动开启和关闭锁），synchronize是隐式锁，出了作用域自动释放。 Lock只有代码块锁，synchronize有代码块锁和方法锁。 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）。 优先使用顺序 Lock –&gt; 同步代码块（已经进入了方法体，分配了相应资源） –&gt; 同步方法（在方法体之外） 如何解决线程安全问题？有几种方式 synchronize(两种)：同步代码块和同步方法。Lock锁(一种) 线程的通信（主要涉及三种方法）三种方法 wait():一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。 notify():一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。 notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。 三种方法说明 wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中。 wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器。否则，会出现IllegalMonitorStateException异常。 wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。 sleep() 和 wait()的异同？相同点： 一旦执行方法，都可以使得当前的线程进入阻塞状态。不同点： 不同点：两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait()。 调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中。 关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。 题目使用两个线程打印 1-100。线程1, 线程2 交替打印。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Number implements Runnable&#123; private int number = 1; private Object obj = new Object(); @Override public void run() &#123; while(true)&#123; synchronized (obj) &#123; obj.notify(); if(number &lt;= 100)&#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + number); number++; try &#123; //使得调用如下wait()方法的线程进入阻塞状态 obj.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;else&#123; break; &#125; &#125; &#125; &#125;&#125;public class CommunicationTest &#123; public static void main(String[] args) &#123; Number number = new Number(); Thread t1 = new Thread(number); Thread t2 = new Thread(number); t1.setName(&quot;线程1&quot;); t2.setName(&quot;线程2&quot;); t1.start(); t2.start(); &#125;&#125; JDK5.0新增线程创建方式新增方式一：实现Callable接口创建过程 创建一个实现Callable的实现类 实现call方法，将此线程需要执行的操作声明在call()中 创建Callable接口实现类的对象 将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象 将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start() 获取Callable中call方法的返回值 Runnable 与 Callable 相比与使用Runnable相比，Callable功能更强大些 相比run()方法，可以有返回值 call()方法可以抛出异常，被外面的操作捕获，获取异常的信息 Callable是支持泛型的 需要借助Future Task类，比如获取返回结果Future接口 可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。 FutrueTask是Future接口的唯一的实现类 FutureTask同时实现了Runnable、Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。 新增方式二：使用线程池背景 经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。 思路 提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。 好处 提高响应速度（减少了创建新线程的时间） 降低资源消耗（重复利用线程池中线程，不需要每次都创建） 便于线程管理 使用线程池案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.ThreadPoolExecutor;class NumberThread implements Runnable&#123; @Override public void run() &#123; for(int i = 0;i &lt;= 100;i++)&#123; if(i % 2 == 0)&#123; System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i); &#125; &#125; &#125;&#125;class NumberThread1 implements Runnable&#123; @Override public void run() &#123; for(int i = 0;i &lt;= 100;i++)&#123; if(i % 2 != 0)&#123; System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i); &#125; &#125; &#125;&#125;public class ThreadPool &#123; public static void main(String[] args) &#123; //1. 提供指定线程数量的线程池 ExecutorService service = Executors.newFixedThreadPool(10); ThreadPoolExecutor service1 = (ThreadPoolExecutor) service; //设置线程池的属性// System.out.println(service.getClass());// service1.setCorePoolSize(15);// service1.setKeepAliveTime(); //2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象 service.execute(new NumberThread());//适合适用于Runnable service.execute(new NumberThread1());//适合适用于Runnable// service.submit(Callable callable);//适合使用于Callable //3.关闭连接池 service.shutdown(); &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"MySQL知识总结","date":"2021-04-03T07:32:22.000Z","path":"2021/04/03/MySQL知识总结/","text":"什么是数据库？SQL、DB、DBMS分别是什么？123SQL：结构化查询语句，是一门标准通用的语言。 DB：DataBase，数据库，实际上在硬盘上以文件的形式存在。DBMS：DataBase Management System，数据库管理系统。 标准的SQL适用于所有的数据库产品。SQL属于高级语言。 SQL执行的过程12345SQL语句在执行的时候，先编译（编译由DBMS完成）后执行。DBMS负责执行sql语句，通过执行sql语句来操作DB当中的数据。DBMS -&gt; (执行) -&gt; SQL -&gt; (操作) -&gt;DB 表(table)什么是表？1表：table是数据库的基本组成单元，所有的数据都以表格的形式组织，目的是可续性强。 表的组成123表由行和列组成：行：称为数据/记录(data)列：称为字段(column) SQL语句分类 DQL(数据查询语言)：查询语句，凡是select语句都是SQL。DML(数据操作语言)：insert、delete、update，对表中的数据进行增删改DDL(数据定义语言)：create、drop、alter，对表结构的增删改TCL(事务(Transaction)控制语言)：commit提交事务，rollback回滚事务。DCL(数据控制语言)：grant授权，revoke撤销权限等。 MySQL的登录及简答查询登录MySQl dos命令：mysql -uroot -p密码 查看有哪些数据 show databases;注意：这不是SQL语句，而是MySQL命令 。 创建属于我们自己的数据库 create database 名字;我们这里创建firstsql,即 create database firstsql; 使用创建的数据库 use 数据库名字；注意：这也是MySQL命令。 查看当前使用的数据库中有哪些表 show tables;注意：这也是MySQL命令。 初始化数据 输入source，然后将数据表拖进来。注意：数据初始化完成之后，有三张表：dept、emp、salgrade。 1234567+--------------------+| Tables_in_firstsql |+--------------------+| dept || emp || salgrade |+--------------------+ 1234注意事项：1、SQL语言的文件被称为“SQL脚本”。2、当一个文件的扩展名是.sql，并且该文件中编写了大量的SQL语句，我们称这样的文件为SQL脚本。3、source可以执行SQL脚本，当SQL脚本中的数据太大的时候，无法直接打开，我们就可以使用source命令完成初始化。 删除数据库 drop database firstsql; 查看表结构 desc dept;desc emp;desc salgrade; 123456789101112131415161718192021222324252627282930313233343536373839404142434445mysql&gt; desc dept;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| DEPTNO | int | NO | PRI | NULL | || DNAME | varchar(14) | YES | | NULL | || LOC | varchar(13) | YES | | NULL | |+--------+-------------+------+-----+---------+-------+DEPTNO:部门编号DNAME:部门名称LOC:部门位置mysql&gt; desc emp;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| EMPNO | int | NO | PRI | NULL | || ENAME | varchar(10) | YES | | NULL | || JOB | varchar(9) | YES | | NULL | || MGR | int | YES | | NULL | || HIREDATE | date | YES | | NULL | || SAL | double(7,2) | YES | | NULL | || COMM | double(7,2) | YES | | NULL | || DEPTNO | int | YES | | NULL | |+----------+-------------+------+-----+---------+-------+EMPNO: 员工编号ENAME:员工姓名JOB:工作岗位 MGR:上级领导编号HIREDATE:入职日期SAL:月薪 COMM:补助/津贴 DEPTNO:部门编号 mysql&gt; desc salgrade;+-------+------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+------+------+-----+---------+-------+| GRADE | int | YES | | NULL | || LOSAL | int | YES | | NULL | || HISAL | int | YES | | NULL | |+-------+------+------+-----+---------+-------+GRADE:等级LOSAL:最低薪资HISAL:最高薪资 查看表中所有的数据 select * form 表名;注意在实际开发(写入Java程序时)当中不建议使用 *，因为效率比较低。 12345678910mysql&gt; select * from dept;+--------+------------+----------+| DEPTNO | DNAME | LOC |+--------+------------+----------+| 10 | ACCOUNTING | NEW YORK || 20 | RESEARCH | DALLAS || 30 | SALES | CHICAGO || 40 | OPERATIONS | BOSTON |+--------+------------+----------+这里我们只举一个dept表的例子，可以查看dept表当中的全部数据。 常用的MySQL命令查看当前使用的是哪一个数据库 select database(); 123456mysql&gt; select database();+------------+| database() |+------------+| firstsql |+------------+ 查看MySQL的版本 select version(); 123456mysql&gt; select version();+-----------+| version() |+-----------+| 8.0.23 |+-----------+ 结束一条语句 \\c 12345mysql&gt; select -&gt; * -&gt; \\cmysql&gt;输入\\c后直接结束这一条语句 退出MySQL exit 12mysql&gt; exitBye 查看建表的语句 show create table emp; 简单的查询语句(DQL)语法格式1234select 字段名1，字段名2，...from 表名; 123注意事项：1、任何一条SQL语句都以“ ; ”结尾。2、SQL语句不区分大小写。 字段可以参与数学运算题目:请输出员工的年薪 select ename, sal * 12 from emp; 123456789101112131415161718+--------+----------+| ename | sal*12 |+--------+----------+| SMITH | 9600.00 || ALLEN | 19200.00 || WARD | 15000.00 || JONES | 35700.00 || MARTIN | 15000.00 || BLAKE | 34200.00 || CLARK | 29400.00 || SCOTT | 36000.00 || KING | 60000.00 || TURNER | 18000.00 || ADAMS | 13200.00 || JAMES | 11400.00 || FORD | 36000.00 || MILLER | 15600.00 |+--------+----------+ 给查询结果的列(sal*12)重命名 select ename, sal * 12 as yearsal from, emp;将sal*12重命名为yearsalas关键字也可以省略不写select ename, sal * 12 yearsal from, emp; 1234567891011121314151617181920212223242526272829303132333435363738394041写as:mysql&gt; select ename,sal*12 as yearsal from emp;+--------+----------+| ename | yearsal |+--------+----------+| SMITH | 9600.00 || ALLEN | 19200.00 || WARD | 15000.00 || JONES | 35700.00 || MARTIN | 15000.00 || BLAKE | 34200.00 || CLARK | 29400.00 || SCOTT | 36000.00 || KING | 60000.00 || TURNER | 18000.00 || ADAMS | 13200.00 || JAMES | 11400.00 || FORD | 36000.00 || MILLER | 15600.00 |+--------+----------+不写as:mysql&gt; select ename,sal*12 yearsal from emp;+--------+----------+| ename | yearsal |+--------+----------+| SMITH | 9600.00 || ALLEN | 19200.00 || WARD | 15000.00 || JONES | 35700.00 || MARTIN | 15000.00 || BLAKE | 34200.00 || CLARK | 29400.00 || SCOTT | 36000.00 || KING | 60000.00 || TURNER | 18000.00 || ADAMS | 13200.00 || JAMES | 11400.00 || FORD | 36000.00 || MILLER | 15600.00 |+--------+----------+ 当别名当中有中文的时候，要注意： 正确写法：select ename, sal * 12 as ‘年薪’ from emp;错误写法：select ename, sal * 12 as 年薪 from emp; 123456789101112131415161718+--------+----------+| ename | 年薪 |+--------+----------+| SMITH | 9600.00 || ALLEN | 19200.00 || WARD | 15000.00 || JONES | 35700.00 || MARTIN | 15000.00 || BLAKE | 34200.00 || CLARK | 29400.00 || SCOTT | 36000.00 || KING | 60000.00 || TURNER | 18000.00 || ADAMS | 13200.00 || JAMES | 11400.00 || FORD | 36000.00 || MILLER | 15600.00 |+--------+----------+ 条件查询语法格式12345678 select 字段1，字段2，... from 表名 where 条件;执行顺序：from --&gt; where --&gt; select 题目：查询工资等于5000的员工姓名 select ename, sal from emp where sal = 5000; 12345+-------+---------+| ename | sal |+-------+---------+| KING | 5000.00 |+-------+---------+ 题目：查询SMITH的工资 select ename, sal from emp where ename = ‘SMITH’;注意：字符串要用’ ‘括起来 12345+-------+--------+| ename | sal |+-------+--------+| SMITH | 800.00 |+-------+--------+ 题目：查询工资不为3000的员工 select ename, sal from emp where sal &lt;&gt; 3000;select ename, sal from emp where sal != 3000;注意：不等于有两种表达形式：&lt;&gt; 和 != 12345678910111213141516171819202122232425262728293031323334353637全部员工的工资：+--------+---------+| ename | sal |+--------+---------+| SMITH | 800.00 || ALLEN | 1600.00 || WARD | 1250.00 || JONES | 2975.00 || MARTIN | 1250.00 || BLAKE | 2850.00 || CLARK | 2450.00 || SCOTT | 3000.00 || KING | 5000.00 || TURNER | 1500.00 || ADAMS | 1100.00 || JAMES | 950.00 || FORD | 3000.00 || MILLER | 1300.00 |+--------+---------+工资不等于3000的员工：+--------+---------+| ename | sal |+--------+---------+| SMITH | 800.00 || ALLEN | 1600.00 || WARD | 1250.00 || JONES | 2975.00 || MARTIN | 1250.00 || BLAKE | 2850.00 || CLARK | 2450.00 || KING | 5000.00 || TURNER | 1500.00 || ADAMS | 1100.00 || JAMES | 950.00 || MILLER | 1300.00 |+--------+---------+ between…and…题目：求工资在1500到3000之间的员工 select ename,sal from emp where sal between 1500 and 3000;注意：between…and…是从左到右执行的，因此不能写between 3000 and 1500,此时无数据。 123456789101112+--------+---------+| ename | sal |+--------+---------+| ALLEN | 1600.00 || JONES | 2975.00 || BLAKE | 2850.00 || CLARK | 2450.00 || SCOTT | 3000.00 || TURNER | 1500.00 || FORD | 3000.00 |+--------+---------+可以看出，当between...and...中是数字的时候，范围是左闭右闭的。 题目：求出姓名在A和C之间的员工 select ename from emp where ename between ‘A’ and ‘C’; 1234567891011121314151617181920212223242526272829姓名在A和C之间的员工:+-------+| ename |+-------+| ALLEN || BLAKE || ADAMS |+-------+所有员工：+--------+| ename |+--------+| ADAMS || ALLEN || BLAKE || CLARK || FORD || JAMES || JONES || KING || MARTIN || MILLER || SCOTT || SMITH || TURNER || WARD |+--------+不难看出，between...and...用于字符串的排序的时候，是左臂闭右开的。 is NULL题目：找出哪些人有津贴，哪些人没有津贴。 select ename,comm from emp where comm is NULL;select ename,comm from emp where comm is not NULL;错误写法：select ename,comm from emp where comm = NULL;select ename,comm from emp where comm != NULL;注意事项：在数据库中NULL不是一个值，而是代表什么也没有，为空。空不是一个值，所以不能用等号衡量 12345678910111213141516171819202122232425262728293031323334353637383940414243无津贴的：+--------+------+| ename | comm |+--------+------+| SMITH | NULL || JONES | NULL || BLAKE | NULL || CLARK | NULL || SCOTT | NULL || KING | NULL || ADAMS | NULL || JAMES | NULL || FORD | NULL || MILLER | NULL |+--------+------+有津贴的：+--------+---------+| ename | comm |+--------+---------+| ALLEN | 300.00 || WARD | 500.00 || MARTIN | 1400.00 || TURNER | 0.00 |+--------+---------+全部的：+--------+---------+| ename | comm |+--------+---------+| SMITH | NULL || ALLEN | 300.00 || WARD | 500.00 || JONES | NULL || MARTIN | 1400.00 || BLAKE | NULL || CLARK | NULL || SCOTT | NULL || KING | NULL || TURNER | 0.00 || ADAMS | NULL || JAMES | NULL || FORD | NULL || MILLER | NULL |+--------+---------+ and 与 or题目：找出工作岗位是MANAGER和SALESMAN的员工 select ename,job from emp where job = ‘MANAGER’ or job = ‘SALESMAN’; 1234567891011+--------+----------+| ename | job |+--------+----------+| ALLEN | SALESMAN || WARD | SALESMAN || JONES | MANAGER || MARTIN | SALESMAN || BLAKE | MANAGER || CLARK | MANAGER || TURNER | SALESMAN |+--------+----------+ 题目：找出薪资大于1000并且部门编号是20或者30的员工 select ename,sal,deptno from emp where sal &gt; 1000 and (deptno = 20 or deptno = 30);注意事项：and 的优先级要比 or 高，所以本题当中的()不可以省略，如果省略则错误。 12345678910111213+--------+---------+--------+| ename | sal | deptno |+--------+---------+--------+| ALLEN | 1600.00 | 30 || WARD | 1250.00 | 30 || JONES | 2975.00 | 20 || MARTIN | 1250.00 | 30 || BLAKE | 2850.00 | 30 || SCOTT | 3000.00 | 20 || TURNER | 1500.00 | 30 || ADAMS | 1100.00 | 20 || FORD | 3000.00 | 20 |+--------+---------+--------+ in 与 not in题目：找出工作岗位是找出工作岗位是MANAGER和SALESMAN的员工 select ename,job from emp where job = ‘MANAGER’ or job = ‘SALESMAN’;这是用 or 来写select ename,job from emp where job in(‘MANAGER’,’SALESMAN’);这里用 in 来写不难看出，in 和 or 的功能是一样的，只是写法上面有所不同。 1234567891011121314151617181920212223242526mysql&gt; mysql&gt; select ename,job from emp where job = &#x27;MANAGER&#x27; or job = &#x27;SALESMAN&#x27;;+--------+----------+| ename | job |+--------+----------+| ALLEN | SALESMAN || WARD | SALESMAN || JONES | MANAGER || MARTIN | SALESMAN || BLAKE | MANAGER || CLARK | MANAGER || TURNER | SALESMAN |+--------+----------+mysql&gt; select ename,job from emp where job in(&#x27;MANAGER&#x27;,&#x27;SALESMAN&#x27;);+--------+----------+| ename | job |+--------+----------+| ALLEN | SALESMAN || WARD | SALESMAN || JONES | MANAGER || MARTIN | SALESMAN || BLAKE | MANAGER || CLARK | MANAGER || TURNER | SALESMAN |+--------+----------+ 题目：找出工作岗位不是MANAGER和SALESMAN的员工 select ename,job from emp where job not in(‘MANAGER’,’SALESMAN’); 1234567891011+--------+-----------+| ename | job |+--------+-----------+| SMITH | CLERK || SCOTT | ANALYST || KING | PRESIDENT || ADAMS | CLERK || JAMES | CLERK || FORD | ANALYST || MILLER | CLERK |+--------+-----------+ 模糊查询like题目：找出名字中含有O的员工 select ename from emp where ename like ‘%O%’; 1234567+-------+| ename |+-------+| JONES || SCOTT || FORD |+-------+ 题目：找出名字第二字母是A的员工 select ename from emp where ename like ‘_A%’; 1234567+--------+| ename |+--------+| WARD || MARTIN || JAMES |+--------+ 题目：找出名字中有下划线_的 select ename from emp where ename like ‘%_%’; 1本数据库当中无带有下划线的名字，本题不是只是一个例子，所以这里不展示结果。 总结掌握两个特殊的符号：% 和 _% 代表任意多个字符，_ 代表任意一个字符当我们刚好需要寻找 % 和 _ 的时候，可以用转义字符 \\% \\_来表示。 数据排序格式1234567891011121314151617181920升序(默认升序，不写asc也是升序)：select 字段1，字段2，...from 表名where 条件order by 字段1，字段2，...asc;降序：select 字段1，字段2，...from 表名where 条件order by 字段1，字段2，...desc; 题目：按照工资升序找出员工名和薪资 select ename,sal from emp order by sal;select ename,sal from emp order by sal asc;默认排序就是升序，因此 asc 不写也可以。 123456789101112131415161718+--------+---------+| ename | sal |+--------+---------+| SMITH | 800.00 || JAMES | 950.00 || ADAMS | 1100.00 || WARD | 1250.00 || MARTIN | 1250.00 || MILLER | 1300.00 || TURNER | 1500.00 || ALLEN | 1600.00 || CLARK | 2450.00 || BLAKE | 2850.00 || JONES | 2975.00 || SCOTT | 3000.00 || FORD | 3000.00 || KING | 5000.00 |+--------+---------+ 题目：按照工资降序找出员工名和薪资 select ename,sal from emp order by sal desc; 123456789101112131415161718+--------+---------+| ename | sal |+--------+---------+| KING | 5000.00 || SCOTT | 3000.00 || FORD | 3000.00 || JONES | 2975.00 || BLAKE | 2850.00 || CLARK | 2450.00 || ALLEN | 1600.00 || TURNER | 1500.00 || MILLER | 1300.00 || WARD | 1250.00 || MARTIN | 1250.00 || ADAMS | 1100.00 || JAMES | 950.00 || SMITH | 800.00 |+--------+---------+ 题目：按照工资的降序排列，工资相同是按名字的升序排序 select ename,sal from emp order by sal desc,ename asc; 123456789101112131415161718+--------+---------+| ename | sal |+--------+---------+| KING | 5000.00 || FORD | 3000.00 || SCOTT | 3000.00 || JONES | 2975.00 || BLAKE | 2850.00 || CLARK | 2450.00 || ALLEN | 1600.00 || TURNER | 1500.00 || MILLER | 1300.00 || MARTIN | 1250.00 || WARD | 1250.00 || ADAMS | 1100.00 || JAMES | 950.00 || SMITH | 800.00 |+--------+---------+ 注意事项：有多个字段同时排序的时候，按前后顺序执行，前面出现一样的情况时，才会执行后面的。越靠前的字段越能起到主导作用，只有当前面的字段无法完成排序的时候，才会用后面的字段。 补充：排序也可以这么写 >select ename,sal from emp order by 2; 此时的含义是ename是第一个，sal是第二个，此时按第二个sal进行排序。 这种方法的健壮性很差，一般不推荐使用。 题目：找出工作岗位是SALESMAN的员工，并且按照薪资降序排列。 select ename,job,sal from emp where job = ‘SALESMAN’ order by sal desc; 12345678+--------+----------+---------+| ename | job | sal |+--------+----------+---------+| ALLEN | SALESMAN | 1600.00 || TURNER | SALESMAN | 1500.00 || WARD | SALESMAN | 1250.00 || MARTIN | SALESMAN | 1250.00 |+--------+----------+---------+ 分组函数 分组函数一共有五个：count：计数sum：求和avg：平均值max：最大值min：最小值 多行处理函数与单行处理函数 分组函数又叫多行处理函数，特点是：输入多行，但最终输出的结果为一行。所有的分组函数都是对“某一组”数据进行操作的。单行处理函数：输入一行，输出一行。 题目：找出员工工资总和 >select sum(sal) from emp; 12345+----------+| sum(sal) |+----------+| 29025.00 |+----------+ 题目：找出最高工资 select max(sal) from emp; 12345+----------+| max(sal) |+----------+| 5000.00 |+----------+ 题目：找出总人数 select count(*) from emp;select count(ename) from emp; 12345678910111213select count(*) from emp; +----------+| count(*) |+----------+| 14 |+----------+select count(ename) from emp;+--------------+| count(ename) |+--------------+| 14 |+--------------+ 题目：同时求出总人数，工资总数、平均数、最大值、最小值 select count(*),sum(sal),avg(sal),max(sal),min(sal) from emp; 12345+----------+----------+-------------+----------+----------+| count(*) | sum(sal) | avg(sal) | max(sal) | min(sal) |+----------+----------+-------------+----------+----------+| 14 | 29025.00 | 2073.214286 | 5000.00 | 800.00 |+----------+----------+-------------+----------+----------+ ifnull()空处理函数 所有数据库只要表达式运算有NULL，那么最后的运算结果都为NULL。我们为了解决这个问题，提出了ifnull方法。 1234 格式 ifnull（可能为NULL的数据，被当做什么来处理）例如：ifnull（comm，0）意思就是如果comm中有NULL的话，我们把它当做0来处理 题目：计算每个员工的年薪(加上津贴) select ename,(sal+ifnull(comm,0))*12 as yearsal from emp;这个时候如果comm当做有NULL的话，就当做0来运算。 123456789101112131415161718192021222324252627282930313233343536373839所有员工的津贴如下：+--------+---------+| ename | comm |+--------+---------+| SMITH | NULL || ALLEN | 300.00 || WARD | 500.00 || JONES | NULL || MARTIN | 1400.00 || BLAKE | NULL || CLARK | NULL || SCOTT | NULL || KING | NULL || TURNER | 0.00 || ADAMS | NULL || JAMES | NULL || FORD | NULL || MILLER | NULL |+--------+---------+每个员工的年薪(加上津贴)+--------+----------+| ename | yearsal |+--------+----------+| SMITH | 9600.00 || ALLEN | 22800.00 || WARD | 21000.00 || JONES | 35700.00 || MARTIN | 31800.00 || BLAKE | 34200.00 || CLARK | 29400.00 || SCOTT | 36000.00 || KING | 60000.00 || TURNER | 18000.00 || ADAMS | 13200.00 || JAMES | 11400.00 || FORD | 36000.00 || MILLER | 15600.00 |+--------+----------+ 分组函数会自动忽略到NULL 题目：计算所有员工津贴的总和 select sum(comm) from emp;这里分组函数自动将comm中的NULL忽略掉了。 12345+-----------+| sum(comm) |+-----------+| 2200.00 |+-----------+ 分组函数的执行顺序(这一块需要结合后面的group by理解) 分组函数必须在分完组后才能执行。如果SQL语句中没有group by 语句的话，整个表的数据自成为一组。而group by 语句必须在 where 后面执行，所以分组函数不可以使用在where 子句当中。 题目：找出工资高于平均工资的员工 错误写法：select ename,sal from emp where sal &gt; avg(sal);此时分组函数出现在了where中，因此改语句错误，原因是无效的使用了分组函数。正确写法：select ename,sal from emp where sal &gt; (select avg(sal) from emp); 嵌套一个SQL语句。 12345678910+-------+---------+| ename | sal |+-------+---------+| JONES | 2975.00 || BLAKE | 2850.00 || CLARK | 2450.00 || SCOTT | 3000.00 || KING | 5000.00 || FORD | 3000.00 |+-------+---------+ count(*) 与 count(具体的某个字段) 的区别 count(*)不是统计某个字段中的数据的个数，而是统计总记录条数。（和某个字段无关）count(某个具体的字段)：表示统计该字段中不为NULL的数据总数量。 group by 与 having group by：按照某个字段或者某些字段进行分组。having：是对分组之后的数据进行再次过滤分组函数一般会和group by 联合使用，这也是分组函数为什么叫这个名字的原因。 题目：找出每个工作岗位的最高薪资 select max(sal),job from emp group by job;将emp当中的数据根据job分组后在求出每组当中的最大薪资。 123456789+----------+-----------+| max(sal) | job |+----------+-----------+| 1300.00 | CLERK || 1600.00 | SALESMAN || 2975.00 | MANAGER || 3000.00 | ANALYST || 5000.00 | PRESIDENT |+----------+-----------+ 多个字段联合起来一起分组题目：找出每个部门不用岗位的最高薪资 select deptno,job,max(sal) from emp group by deptno,job order by deptno asc,job asc;这里我们还将结果根据deptno 和 job 进行了升序排序。 1234567891011121314+--------+-----------+----------+| deptno | job | max(sal) |+--------+-----------+----------+| 10 | CLERK | 1300.00 || 10 | MANAGER | 2450.00 || 10 | PRESIDENT | 5000.00 || 20 | ANALYST | 3000.00 || 20 | CLERK | 1100.00 || 20 | MANAGER | 2975.00 || 30 | CLERK | 950.00 || 30 | MANAGER | 2850.00 || 30 | SALESMAN | 1600.00 |+--------+-----------+----------+可以看出，group by 还可以同时多个进行分组的。 having题目：找出每个部门的最高薪资，要求显示最大薪资大于2900的数据。 select deptno,max(sal) from emp group by deptno having max(sal) &gt;2900;select deptno,max(sal) from emo where sal &gt; 2900 group by deptno;这两条语句都可以求出，但是我们用having的效率要比where的效率低，一般我们都推荐尽量使用where。 123456+--------+----------+| deptno | max(sal) |+--------+----------+| 20 | 3000.00 || 10 | 5000.00 |+--------+----------+ 题目：找出每个部门的平均薪资，要求显示平均薪资大于2000的。 select deptno,avg(sal) from emp group by deptno having avg(sal) &gt; 2000;注意：此时的平均薪资是通过分组函数进行求得的，我们无法直接获得这个值，所以此时不能用where来写，因为分组函数不能出现在where中。 123456+--------+-------------+| deptno | avg(sal) |+--------+-------------+| 20 | 2175.000000 || 10 | 2916.666667 |+--------+-------------+ 完整的SQL语句的顺序12345678910111213 执行顺序select 5 ...from 1 ...where 2 ..,group by 3 ...having 4 ...order by 6 ... 关于查询结果集的去重 distinct 关键字，去除重复记录。注意：distinct 关键字只能出现在所有字段的最前面。 题目：查询所有的员工岗位 select distinct job from emp; 1234567891011121314151617181920212223242526272829303132select distinct job from emp;+-----------+| job |+-----------+| CLERK || SALESMAN || MANAGER || ANALYST || PRESIDENT |+-----------+select job from emp;+-----------+| job |+-----------+| CLERK || SALESMAN || SALESMAN || MANAGER || SALESMAN || MANAGER || MANAGER || ANALYST || PRESIDENT || SALESMAN || CLERK || CLERK || ANALYST || CLERK |+-----------+可以看出，通过distinct关键字实现了去重。 错误写法：select ename, distinct job from emp;distinct 关键字只能出现在所有字段的最前面。表示给后面所有的字段进行去重。 题目：查询每个部门的岗位。 select distinct deptno, job from emp order by deptno; 12345678910111213+--------+-----------+| deptno | job |+--------+-----------+| 10 | CLERK || 10 | MANAGER || 10 | PRESIDENT || 20 | ANALYST || 20 | CLERK || 20 | MANAGER || 30 | CLERK || 30 | MANAGER || 30 | SALESMAN |+--------+-----------+ 题目：统计岗位的数量。 select count(distinct job) from emp; 12345+---------------------+| count(distinct job) |+---------------------+| 5 |+---------------------+ 连接查询什么是连接查询？ 在实际开发中，大部分的情况下都不是从单表中查询数据，一般都是从多张表联合查询取出最终的结果。在实际开发中，一般一个业务都会对应多张表，比如学生和班级，起码有两张表。如果存储到一张表中，数据会存在大量的重复，导致数据的冗余。 连接查询的分类 根据语句出现的年代划分：SQL92(一些老的DBA(DataBase Administrator数据库管理员)可能还在使用)。SQL99(比较新的语法)根据表的连接方式划分：内连接：等值连接、非等值连接、自连接外连接：左外连接(左连接)、右外连接(右连接)全连接(很少用) 笛卡尔积现象 在表的连接查询方面有一种现象被称为：笛卡尔积现象。笛卡尔积现象：当两张表进行连接查询的时候，没有任何条件进行限制。最终的查询条数是两张表记录条数的乘积。 题目:找出每一个员工的部门名称，要求显示员工名和部门名。 select ename, dname from emp, dept; 1234567891011121314151617181920212223242526272829303132333435EMP表：+--------+--------+| ename | deptno |+--------+--------+| SMITH | 20 || ALLEN | 30 || WARD | 30 || JONES | 20 || MARTIN | 30 || BLAKE | 30 || CLARK | 10 || SCOTT | 20 || KING | 10 || TURNER | 30 || ADAMS | 20 || JAMES | 30 || FORD | 20 || MILLER | 10 |+--------+--------+DEPT表：+--------+------------+----------+| deptno | dname | loc |+--------+------------+----------+| 10 | ACCOUNTING | NEW YORK || 20 | RESEARCH | DALLAS || 30 | SALES | CHICAGO || 40 | OPERATIONS | BOSTON |+--------+------------+----------+select ename, dname from emp, dept; 56 rows in set (0.31 sec)执行上述语句的时候，会发现一共有14x4=56条结果，这个现象就叫做笛卡尔积现象。 关于表的别名：select e.ename, d.dname from emp e, dept d;好处：执行效率高、可读性好。 如何避免笛卡尔积现象：加条件进行过滤。注意：避免笛卡尔积现象不会减少记录的匹配次数，次数还是56次，只不过显示的是有效记录。 12345678910111213141516171819202122232425262728 select e.ename, d.dname from emp e, dept d where e.deptno = d.deptno;+--------+------------+| ename | dname |+--------+------------+| SMITH | RESEARCH || ALLEN | SALES || WARD | SALES || JONES | RESEARCH || MARTIN | SALES || BLAKE | SALES || CLARK | ACCOUNTING || SCOTT | RESEARCH || KING | ACCOUNTING || TURNER | SALES || ADAMS | RESEARCH || JAMES | SALES || FORD | RESEARCH || MILLER | ACCOUNTING |+--------+------------+14 rows in set (0.00 sec)这是SQL92，以后不用。 内连接等值连接 最大特点：条件是等量关系。 123456789格式： ... A join B on 连接条件 where ... 题目：查询每个员工的部门名称，要求显示员工名和部门名。 1234567SQL92: select e.ename, d.dname from emp e, dept d where e.deptno = d.deptno; 12345678910111213SQL99: SQL99语法结果更清晰一点，表的连接条件和后面的where条件分离了。 select e.ename, d.dname from emp e (inner) join dept d on e.deptno = d.deptno;inner可以省略，带着inner的目的是好读一点。 非等值连接 最大的特点：连接条件中的关系是非等量关系。 题目：找出每个员工的工资等级，要求显示员工名、工资、工资等级。 12345678select e.ename, e.sal, s.gradefrom emp e(inner) join salgrade son e.sal between s.losal and s.hisal; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051EMP表：+--------+---------+| ename | sal |+--------+---------+| SMITH | 800.00 || ALLEN | 1600.00 || WARD | 1250.00 || JONES | 2975.00 || MARTIN | 1250.00 || BLAKE | 2850.00 || CLARK | 2450.00 || SCOTT | 3000.00 || KING | 5000.00 || TURNER | 1500.00 || ADAMS | 1100.00 || JAMES | 950.00 || FORD | 3000.00 || MILLER | 1300.00 |+--------+---------+SALGRADE表：+-------+-------+-------+| grade | losal | hisal |+-------+-------+-------+| 1 | 700 | 1200 || 2 | 1201 | 1400 || 3 | 1401 | 2000 || 4 | 2001 | 3000 || 5 | 3001 | 9999 |+-------+-------+-------+题解：+--------+---------+-------+| ename | sal | grade |+--------+---------+-------+| SMITH | 800.00 | 1 || ALLEN | 1600.00 | 3 || WARD | 1250.00 | 2 || JONES | 2975.00 | 4 || MARTIN | 1250.00 | 2 || BLAKE | 2850.00 | 4 || CLARK | 2450.00 | 4 || SCOTT | 3000.00 | 4 || KING | 5000.00 | 5 || TURNER | 1500.00 | 3 || ADAMS | 1100.00 | 1 || JAMES | 950.00 | 1 || FORD | 3000.00 | 4 || MILLER | 1300.00 | 2 |+--------+---------+-------+ 自连接 最大的特点：一张表看做两张表，自己连接自己。 题目：找出每个员工的上级领导，要求显示员工名称和对应的领导名。 12345678select a.ename, b.enamefrom emp ajoin emp bon a.mgr = b.empno; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758EMP a表：+--------+------+| ename | mgr |+--------+------+| SMITH | 7902 || ALLEN | 7698 || WARD | 7698 || JONES | 7839 || MARTIN | 7698 || BLAKE | 7839 || CLARK | 7839 || SCOTT | 7566 || KING | NULL || TURNER | 7698 || ADAMS | 7788 || JAMES | 7698 || FORD | 7566 || MILLER | 7782 |+--------+------+EMP b表：+--------+-------+| ename | empno |+--------+-------+| SMITH | 7369 || ALLEN | 7499 || WARD | 7521 || JONES | 7566 || MARTIN | 7654 || BLAKE | 7698 || CLARK | 7782 || SCOTT | 7788 || KING | 7839 || TURNER | 7844 || ADAMS | 7876 || JAMES | 7900 || FORD | 7902 || MILLER | 7934 |+--------+-------+题解:+--------+-------+| ename | ename |+--------+-------+| SMITH | FORD || ALLEN | BLAKE || WARD | BLAKE || JONES | KING || MARTIN | BLAKE || BLAKE | KING || CLARK | KING || SCOTT | JONES || TURNER | BLAKE || ADAMS | SCOTT || JAMES | BLAKE || FORD | JONES || MILLER | CLARK |+--------+-------+ 外连接什么是外连接？与内连接有什么区别？ 内连接：假设A和B表进行连接，使用内连接的话，凡是A表和B表能够匹配上的记录查询出来，这就是内连接。A、B两张表没有主副之分，是平等的。外连接：假设A和B表进行连接，使用外连接的话，A、B两张表中有一张表是主表，一张表是副表，主要查询主表中的数据，捎带这查询副表，当副表中的数据没有和主表中的数据匹配上，副表会自动模拟出NULL与之匹配。外连接的分类：左外连接(左连接)：表示左边的这张表是主表。右外连接(右连接)：表示有边的这张表是主表。左连接有右连接的写法，右连接也有对应的左连接的写法。 题目：找出每个员工的上级领导(所以员工必须全部找出(包括KING))。 123456789101112131415161718192021左(外)连接： select a.ename &#x27;员工&#x27;, b.ename &#x27;领导&#x27; from emp a left (outer) join emp b on a.mgr = b.empno;右(外)连接： select a.ename &#x27;员工&#x27;, b.ename &#x27;领导&#x27; from emp b right (outer) join emp a on a.mgr = b.empno;outer可省略！ 12345678910111213141516171819题解：+--------+-------+| 员工 | 领导 |+--------+-------+| SMITH | FORD || ALLEN | BLAKE || WARD | BLAKE || JONES | KING || MARTIN | BLAKE || BLAKE | KING || CLARK | KING || SCOTT | JONES || KING | NULL || TURNER | BLAKE || ADAMS | SCOTT || JAMES | BLAKE || FORD | JONES || MILLER | CLARK |+--------+-------+ 外连接的主要特点是：主表的数据无条件的全部查询出来。 题目：找出哪个部门没有员工。 123456789101112131415161718192021222324左连接： select d.* from dept d left join emp e on e.deptno = d.deptno where e.empno is NULL;右连接： select d.* from emp e right join dept d on e.deptno = d.deptno where e.empno is NULL; 1234567891011121314151617181920212223242526272829303132333435d表(主表)：+--------+------------+----------+| DEPTNO | DNAME | LOC |+--------+------------+----------+| 10 | ACCOUNTING | NEW YORK || 20 | RESEARCH | DALLAS || 30 | SALES | CHICAGO || 40 | OPERATIONS | BOSTON |+--------+------------+----------+e表(副表)：+--------+--------+| ename | deptno |+--------+--------+| SMITH | 20 || ALLEN | 30 || WARD | 30 || JONES | 20 || MARTIN | 30 || BLAKE | 30 || CLARK | 10 || SCOTT | 20 || KING | 10 || TURNER | 30 || ADAMS | 20 || JAMES | 30 || FORD | 20 || MILLER | 10 |+--------+--------+题解：+--------+------------+--------+| DEPTNO | DNAME | LOC |+--------+------------+--------+| 40 | OPERATIONS | BOSTON |+--------+------------+--------+ 三张表怎么连接查询12345678910... Ajoin Bon ...join Con ... 表示A先和B进行表连接，连接之后，A继续和C进行表连接。 题目：找出每一个员工的部门名称以及工资等级。 12345678910111213select e.ename, d.dname, s.gradefrom emp ejoin dept don e.deptno = d.deptnojoin salgrade son e.sal between s.losal and s.hisal; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758EMP e表：+-------+--------+---------+--------+| empno | ename | sal | deptno |+-------+--------+---------+--------+| 7369 | SMITH | 800.00 | 20 || 7499 | ALLEN | 1600.00 | 30 || 7521 | WARD | 1250.00 | 30 || 7566 | JONES | 2975.00 | 20 || 7654 | MARTIN | 1250.00 | 30 || 7698 | BLAKE | 2850.00 | 30 || 7782 | CLARK | 2450.00 | 10 || 7788 | SCOTT | 3000.00 | 20 || 7839 | KING | 5000.00 | 10 || 7844 | TURNER | 1500.00 | 30 || 7876 | ADAMS | 1100.00 | 20 || 7900 | JAMES | 950.00 | 30 || 7902 | FORD | 3000.00 | 20 || 7934 | MILLER | 1300.00 | 10 |+-------+--------+---------+--------+DEPT d表：+--------+------------+----------+| DEPTNO | DNAME | LOC |+--------+------------+----------+| 10 | ACCOUNTING | NEW YORK || 20 | RESEARCH | DALLAS || 30 | SALES | CHICAGO || 40 | OPERATIONS | BOSTON |+--------+------------+----------+SALGRADE s表：+-------+-------+-------+| GRADE | LOSAL | HISAL |+-------+-------+-------+| 1 | 700 | 1200 || 2 | 1201 | 1400 || 3 | 1401 | 2000 || 4 | 2001 | 3000 || 5 | 3001 | 9999 |+-------+-------+-------+题解：+--------+------------+-------+| ename | dname | grade |+--------+------------+-------+| SMITH | RESEARCH | 1 || ALLEN | SALES | 3 || WARD | SALES | 2 || JONES | RESEARCH | 4 || MARTIN | SALES | 2 || BLAKE | SALES | 4 || CLARK | ACCOUNTING | 4 || SCOTT | RESEARCH | 4 || KING | ACCOUNTING | 5 || TURNER | SALES | 3 || ADAMS | RESEARCH | 1 || JAMES | SALES | 1 || FORD | RESEARCH | 4 || MILLER | ACCOUNTING | 2 |+--------+------------+-------+ 题目：找出每一个员工的部门名称，工资等级以及上级领导。 12345678910111213141516select e.ename, d.dname, s.gradefrom emp ejoin dept don e.deptno = d.deptnojoin salgrade son e.sal between s.losal and s.hisalleft join emp eeon e.mgr = ee.empno; 12345678910111213141516171819题解：+--------+------------+-------+| ename | dname | grade |+--------+------------+-------+| SMITH | RESEARCH | 1 || ALLEN | SALES | 3 || WARD | SALES | 2 || JONES | RESEARCH | 4 || MARTIN | SALES | 2 || BLAKE | SALES | 4 || CLARK | ACCOUNTING | 4 || SCOTT | RESEARCH | 4 || KING | ACCOUNTING | 5 || TURNER | SALES | 3 || ADAMS | RESEARCH | 1 || JAMES | SALES | 1 || FORD | RESEARCH | 4 || MILLER | ACCOUNTING | 2 |+--------+------------+-------+ 子查询什么是子查询？ select语句中嵌套select语句，被嵌套的select语句是子查询。 子查询出现的位置？123456select ...(select语句)...from ...(select语句)...where ...(select语句)... where语句中使用子查询题目：找出高于平均薪资的员工信息。 123456select ename, salfrom empwhere sal &gt; (select avg(sal) from emp); 123456789101112+-------+---------+| ename | sal |+-------+---------+| JONES | 2975.00 || BLAKE | 2850.00 || CLARK | 2450.00 || SCOTT | 3000.00 || KING | 5000.00 || FORD | 3000.00 |+-------+---------+这里只查了名字和薪资，其他的没有查询。 from后面嵌套子查询题目：找出每个部门平均薪水的薪资等级。 1234567891011121314151617181920212223242526272829303132333435第一步：找出每个部门平均薪水 select deptno, avg(sal) as avgsal from emp group by deptno;+--------+-------------+| deptno | avgsal |+--------+-------------+| 20 | 2175.000000 || 30 | 1566.666667 || 10 | 2916.666667 |+--------+-------------+第二步：将第一步查询结果当做临时表t,让t表和SALGRADE s表连接，条件是t.avgsal between s.losal and s.hisal select t.*, s.grade from (select deptno, avg(sal) as avgsal from emp group by deptno) t join salgrade s on t.avgsal between s.losal and s.hisal;+--------+-------------+-------+| deptno | avgsal | grade |+--------+-------------+-------+| 20 | 2175.000000 | 4 || 30 | 1566.666667 | 3 || 10 | 2916.666667 | 4 |+--------+-------------+-------+ 题目：找出每个部门平均的薪水等级 123456789101112131415161718192021222324252627282930313233343536373839404142434445第一步：找出每个员工的薪水等级 select e.ename, e.sal, e.deptno, s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal;+--------+---------+--------+-------+| ename | sal | deptno | grade |+--------+---------+--------+-------+| SMITH | 800.00 | 20 | 1 || ALLEN | 1600.00 | 30 | 3 || WARD | 1250.00 | 30 | 2 || JONES | 2975.00 | 20 | 4 || MARTIN | 1250.00 | 30 | 2 || BLAKE | 2850.00 | 30 | 4 || CLARK | 2450.00 | 10 | 4 || SCOTT | 3000.00 | 20 | 4 || KING | 5000.00 | 10 | 5 || TURNER | 1500.00 | 30 | 3 || ADAMS | 1100.00 | 20 | 1 || JAMES | 950.00 | 30 | 1 || FORD | 3000.00 | 20 | 4 || MILLER | 1300.00 | 10 | 2 |+--------+---------+--------+-------+第二步：将第一步的结果继续按deptno分组，求grade的平均值 select e.deptno, avg(s.grade) from emp e join salgrade s on e.sal between s.losal and s.hisal group by e.deptno;+--------+--------------+| deptno | avg(s.grade) |+--------+--------------+| 20 | 2.8000 || 30 | 2.5000 || 10 | 3.6667 |+--------+--------------+ select后面嵌套子查询题目：找出每个员工所在的部门名称。要求显示员工名和部门名。 123456789select e.ename, (select d.dname from dept d where e.deptno = d.deptno) as dnamefrom emp e; 123456789101112131415161718+--------+------------+| ename | dname |+--------+------------+| SMITH | RESEARCH || ALLEN | SALES || WARD | SALES || JONES | RESEARCH || MARTIN | SALES || BLAKE | SALES || CLARK | ACCOUNTING || SCOTT | RESEARCH || KING | ACCOUNTING || TURNER | SALES || ADAMS | RESEARCH || JAMES | SALES || FORD | RESEARCH || MILLER | ACCOUNTING |+--------+------------+ union(将查询结果集相加) union：将两种不相干的表的数据拼接在一起显示。 题目：找出工作岗位是SALESMAN和MANAGER的员工。 1234567891011121314151617181920212223242526272829303132333435363738394041424344用or来写： select ename, job from emp where job = &#x27;SALESMAN&#x27; or job = &#x27;MANAGER&#x27;;用in来写： select ename, job from emp where job in(&#x27;SALESMAN&#x27;,&#x27;MANAGER&#x27;);用union来写： select ename, job from emp where job = &#x27;SALESMAN&#x27; union select ename, job from emp where job = &#x27;MANAGER&#x27;;+--------+----------+| ename | job |+--------+----------+| ALLEN | SALESMAN || WARD | SALESMAN || JONES | MANAGER || MARTIN | SALESMAN || BLAKE | MANAGER || CLARK | MANAGER || TURNER | SALESMAN |+--------+----------+ limit limit是MYSQL特有的，其他数据库没有。（Oracle中有一个相同的机制，叫做rownum） 作用：取结果的部分数据 limit是SQL语句最后执行的一个环节。 12345格式： limit startIndex, lengthstartIndex：起始位置（从0开始，0表示第一条数据）length：取几个 题目：取出工资前5名的员工。（思路：降序取前5个） 1234567891011121314151617181920212223242526272829方法一： select ename, sal from emp order by sal desc limit 0, 5;方法二： select ename, sal from emp order by sal desc limit 5; 如果前面不写则起始位置默认从0开始。+-------+---------+| ename | sal |+-------+---------+| KING | 5000.00 || SCOTT | 3000.00 || FORD | 3000.00 || JONES | 2975.00 || BLAKE | 2850.00 |+-------+---------+ 题目：找出工资排名在第4到第9的员工。 12345678910111213141516171819 select ename, sal from emp order by sal desc limit 3, 6;+--------+---------+| ename | sal |+--------+---------+| JONES | 2975.00 || BLAKE | 2850.00 || CLARK | 2450.00 || ALLEN | 1600.00 || TURNER | 1500.00 || MILLER | 1300.00 |+--------+---------+ 通用的标准分页SQL 每页显示pagesize条记录 第pageNo页：（pageNo - 1） * pagesize, pagesize pagesize:每页显示多少条记录pageNo:第几页 创建表123456格式： create table 表名( 字段名1 数据类型 字段名2 数据类型 ... ); 关于MYSQL当中字段的类型 数据类型 描述 int 整型，相当于Java中的int bigint 整型，相当于Java中的long float 相当于Java中的float、double char 定点字符串，相当于Java中的String varchar 可变字符串，相当于StringBuffer/StringBuilder date 日期类型，相当于Java中的java.sql.Date BLOB 二进制对象(Binary Large Object)，存储图片、视频等流媒体信息。相当于Java中的Object CLOB 字符大对象(Character Large Object)，存储较大文本，比如可以存储4G的字符串 char和varchar怎么选择？ char： 在实际的开发中，某个字段的数据长度不发生改变是定长的，如性别、生日等用char。 varchar： 根据实际的大小动态分配大小。当一个字段的数据长度不确定的时候用varchar，例如：简介、姓名等。 创建学生表 表名在数据库中一般建议以t或者tbl开始。 1234567891011创建学生表： 学生信息一般包括：学号、姓名、性别、班级编号、生日... create table t_student( no bigint, name varchar(255), sex char(1), classno varchar(255), birth char(10) ); 插入数据（insert语句)12格式： insert into 表名(字段1，字段2，...) values(值1，值2，...) 要求： 字段的数量和值的数量相同，并且数据类型要对应相同。 注意：当一个insert语句执行成功之后，表格当中必然会多一行记录。即使多的这行记录当中某些字段是NULL，后期也没有办法在执行insert语句插入数据了，只能使用update进行更新。 全部插入1234567insert into t_student(no,name,sex,classno,birth) values(1,&#39;张三&#39;,&#39;1&#39;,&#39;高三1班&#39;,&#39;2000-12-2&#39;);+------+------+------+---------+-----------+| no | name | sex | classno | birth |+------+------+------+---------+-----------+| 1 | 张三 | 1 | 高三1班 | 2000-12-2 |+------+------+------+---------+-----------+ 插入一部分12345678910insert into t_student(name) values(&#39;王五&#39;);+------+------+------+---------+-----------+| no | name | sex | classno | birth |+------+------+------+---------+-----------+| 1 | 张三 | 1 | 高三1班 | 2000-12-2 || NULL | 王五 | NULL | NULL | NULL |+------+------+------+---------+-----------+除name字段外，剩下的所有字段自动插入NULL。 字段省略1234567insert into t_student values(2,&#39;jack&#39;,&#39;0&#39;,&#39;高三2班&#39;,&#39;2001-2-3&#39;);+------+------+------+---------+----------+| no | name | sex | classno | birth |+------+------+------+---------+----------+| 2 | jack | 0 | 高三2班 | 2001-2-3 |+------+------+------+---------+----------+如果字段省略的话，表示全部都要插入，后面不能少写。 建表的时候加入默认值123456789101112131415161718 create table t_student( no bigint, name varchar(255), sex char(1) default 1, classno varchar(255), birth char(10) );sex默认为1此时同上面插入语句：insert into t_student(name) values(&#39;王五&#39;);会发现sex中有默认值为1+------+------+------+---------+-------+| no | name | sex | classno | birth |+------+------+------+---------+-------+| NULL | 王五 | 1 | NULL | NULL |+------+------+------+---------+-------+ 一次插入多行数据12345678910insert into t_student(no,name,sex,classno,birth) values(3,&#39;rose&#39;,&#39;1&#39;,&#39;高三2班&#39;,&#39;2001-3-4&#39;),(4,&#39;Mary&#39;,&#39;0&#39;,&#39;高三3班&#39;,&#39;2000-5-6&#39;);+------+------+------+----------+----------+| no | name | sex | classno | birth |+------+------+------+----------+----------+| NULL | 王五 | 1 | NULL | NULL || 2 | jack | 0 | 高三2班 | 2001-2-3 || 3 | rose | 1 | 高三2班 | 2001-3-4 || 4 | Mary | 0 | 高三3班 | 2000-5-6 |+------+------+------+----------+----------+ 删表123drop table if exists t_student;如果该表存在则删除。 表的复制1234格式： create table 表名 as select语句；将查询结果当做表创建处理。 123456789101112131415161718192021create table emp1 as select ename,empno from emp;mysql&gt; select * from emp1;+--------+-------+| ename | empno |+--------+-------+| SMITH | 7369 || ALLEN | 7499 || WARD | 7521 || JONES | 7566 || MARTIN | 7654 || BLAKE | 7698 || CLARK | 7782 || SCOTT | 7788 || KING | 7839 || TURNER | 7844 || ADAMS | 7876 || JAMES | 7900 || FORD | 7902 || MILLER | 7934 |+--------+-------+ 将查询结果插入到一张表中12345678910111213141516171819202122232425262728293031323334353637emp2表：+-------+-------+| ename | empno |+-------+-------+| Mary | 8888 || Jack | 9999 |+-------+-------+emp1表：+--------+-------+| ename | empno |+--------+-------+| SMITH | 7369 || ALLEN | 7499 || WARD | 7521 || JONES | 7566 || MARTIN | 7654 || BLAKE | 7698 || CLARK | 7782 || SCOTT | 7788 || KING | 7839 || TURNER | 7844 || ADAMS | 7876 || JAMES | 7900 || FORD | 7902 || MILLER | 7934 |+--------+-------+将emp1表中的SIMTH开头的人插入到emp2中：insert into emp2 select ename,empno from emp1 where ename &#x3D; &#39;SMITH&#39;;+-------+-------+| ename | empno |+-------+-------+| Mary | 8888 || Jack | 9999 || SMITH | 7369 |+-------+-------+ 修改数据12格式：update 表名 set 字段名1 &#x3D; 值,，字段名2 &#x3D; 值2,... where 条件; 注意：如果没有条件则全部更新。 题目：将emp2中的Mary的员工号改成8899。 123456789update emp2 set empno &#x3D; 8899 where empno &#x3D; 8888;+-------+-------+| ename | empno |+-------+-------+| Mary | 8899 || Jack | 9999 || SMITH | 7369 |+-------+-------+ 题目：将emp2中的员工号全部修改为1111。 1234567891011 update emp2 set empno &#x3D; 1111;+-------+-------+| ename | empno |+-------+-------+| Mary | 1111 || Jack | 1111 || SMITH | 1111 |+-------+-------+不加条件全部更新。 删除表中的数据12格式：delete from 表名 where 条件; 注意：没有条件则全部删除。 题目：删除emp2表中Jack的数据。 12345678delete from emp2 where ename &#x3D; &#39;Jack&#39;;+-------+-------+| ename | empno |+-------+-------+| Mary | 1111 || SMITH | 1111 |+-------+-------+ 题目：删除emp2中的全部数据。 1234delete from emp2;mysql&gt; select * from emp2;Empty set (0.00 sec) 怎么删除大表中的数据123truncate table 表名;表被截断，不可回滚，永久丢失。 删除表12drop table 表名; &#x2F;&#x2F;通用drop table if exists 表名; &#x2F;&#x2F;Oracle不支持这种写法。 表结构的修改 表结构的修改，使用工具完成即可。因为在实际开发中表一旦设计好之后，对表的结构的修改是很少的，修改表结构就是对之前的设计进行了否定，即使需要修改表结构，我们也可以直接使用工具操作。 修改表结构的语句不会出现在Java代码当中，出现在Java代码当中的SQL语句包括：insert、delete、update、select。（这些都是表中的数据操作。）增删改查有一个术语：CRUD操作（增create、检查retrieve、修改update、删除delete） 约束(Constraint)什么是约束？ 在创建表的时候，可以给表的字段添加相应的约束，添加约束的目的是为了保证表中的数据的合法性、有效性、完整性。 常见的约束 非空约束(not null)：约束的字段不能为NULL 唯一约束(unique)：约束的字段不能重复 主键约束(primary key)：约束的字段既不能为NULL，也不能重复，简称PK。 外键约束(foreign key)：简称FK。 检查约束(check)：Oracle数据库有check约束，但是MYSQL没有。目前MYSQL不支持该约束。 非空约束（not null） 非空约束只有列级，没有表级。 123456drop table if exists t_user;create table t_user( id int, username varchar(255) not null, &#x2F;&#x2F;不为空，必须插入数据。 password varchar(255)); 唯一性约束（unique） 唯一约束修饰的字段具有唯一性，不能重复，但可以为NULL。 12345678910111213给一个字段添加unique约束： drop table if exists t_user; create table t_user( id int, username varchar(255) unique &#x2F;&#x2F;列级约束 );此时在插入数据时如下： insert into t_user values(1, &#39;zs&#39;); insert into t_user values(2, &#39;zs&#39;); &#x2F;&#x2F;报错，因为username重复了。 insert into t_user values(2); insert into t_user values(3); &#x2F;&#x2F;username可以为空。 1234567891011121314151617181920212223242526给两个字段添加约束：此时代表着两个字段联合起来不能一样。 drop table if exists t_user; create table t_user( id int, usercode varchar(255), username varchar(255), unique(usercode, username) &#x2F;&#x2F;多个字段联合起来添加一个约束 &#x2F;&#x2F;表级约束 );此时插入数据如下： insert into t_user values(1, ‘001’, &#39;zs&#39;); insert into t_user values(2, ‘002’, &#39;ls&#39;); insert into t_user values(3, ‘001’, &#39;ls&#39;); &#x2F;&#x2F;可以插入 insert into t_user values(4, ‘003’, &#39;ls&#39;); &#x2F;&#x2F;也可以插入 insert into t_user values(5, ‘001’, &#39;zs&#39;); &#x2F;&#x2F;插入错误，此时联合起来一样，不能插入。如果是如下这么插入的话，和上面的“联合起来不一样”不同，这里表示每一个都不能一样。 drop table if exists t_user; create table t_user( id int, usercode varchar(255) unique, username varchar(255) unique ); 主键约束（primary key） 主键约束是列级约束 添加方法：primary key关键字 注意：一张表的主键约束只能有一个 1234567891011121314151617181920给一张表添加主键约束： drop table if exists t_user; create table t_user( id int primary key, &#x2F;&#x2F;列级约束 username varchar(255), email varchar(255) );插入数据如下： insert into t_user(id,username,email) values(1,&#39;zs&#39;,&#39;zs@163.com&#39;); insert into t_user(id,username,email) values(2,&#39;ls&#39;,&#39;ls@163.com&#39;); insert into t_user(id,username,email) values(3,&#39;ww&#39;,&#39;ww@163.com&#39;);错误的插入方法： &#x2F;&#x2F;此时出错，因为id是PK。 insert into t_user(id,username,email) values(1,&#39;Jk&#39;,&#39;Jk@163.com&#39;); &#x2F;&#x2F;此时出错，因为id没有初始值。 insert into t_user(username,email) values(&#39;Rose&#39;,&#39;Rose@163.com&#39;); 根据上面测试得出，id是主键（添加了主键约束）。主键字段中的数据不能为NULL，也不能重复。 主键的特点：不能为NULL，不能重复。 主键相关的术语： 主键约束：primary key 主键字段：id字段添加primary key后，id叫做主键字段 主键值：id字段中的每一值都是主键值 主键的作用： 表的三范式中有要求第一范式要求任何一张表都应该有主键。主键值是这行记录在这张表中的唯一标识（就像一个人的身份证号码）。 主键的分类根据主键字段数量来划分： 单一主键（推荐的，常用的） 复合主键（多个字段联合起来添加一个主键约束）。—不推荐用，因为复合主键违背了三范式。 根据主键性质来划分： 自然主键:主键值是一个和业务没有任何关系的自然数。（这种方式是推荐的） 业务主键：主键值和系统业务挂钩。例如：银行卡号码、身份证号做主键（不推荐使用） 最好不要拿着和业务挂钩的字段作为主键，因为以后的业务一旦发生改变的时候，主键值可能也需要随着发生变化，但有的时候没有办法变化，因为变化可能导致主键值重复。 1234567891011121314使用表级约束方式定义主键： drop table if exists t_user; create table t_user( id int, username varchar(255), primary key(id) );插入数据如下： insert into t_user(id,username) values(1,&#39;zs&#39;); insert into t_user(id,username) values(2,&#39;ls&#39;); insert into t_user(id,username) values(3,&#39;ww&#39;); insert into t_user(id,username) values(4,&#39;jack&#39;); insert into t_user(id,username) values(4,&#39;rose&#39;); &#x2F;&#x2F;此行错误 MYSQL提供主键值自增（！！！）12345678910111213141516171819202122232425auto_increment:id字段自动维护一个自增的数字，从1开始，默认自增。 drop table if exists t_user; create table t_user( id int primary key auto_increment, username varchar(255) ); insert into t_user(username) values (&#39;a&#39;); insert into t_user(username) values (&#39;b&#39;); insert into t_user(username) values (&#39;c&#39;); insert into t_user(username) values (&#39;d&#39;); insert into t_user(username) values (&#39;e&#39;); +----+----------+ | id | username | +----+----------+ | 1 | a | | 2 | b | | 3 | c | | 4 | d | | 5 | e | +----+----------+补充：Oracle中也提供了一个自增机制，叫做序列（sequence）对象。 外键约束外键约束的相关术语 外键约束：foreign key 外键字段：添加有外键约束的字段 外键值：外键字段中的每一个值 业务背景设计一个数据表库，用来维护学生和班级的信息。 使用一张表存储所有的数据缺点：冗余（不推荐） 使用两张表：班级表t_class和学生表t_student t_class表：|cno(PK)|cname||:–:|:–:||101|1班||102|2班| t_student表：|sno(PK)|sname|classno(FK)||:–:|:–:|:–:||1|zs|101||2|ls|102||3|ww|101||4|jack|101||5|rose|102| 建表语句 顺序要求：删除数据的时候，先删除子表，再删除父表。添加数据的时候，先添加父表，再添加子表。创建表的时候，先创建父表，再创建子表。删除表的时候，先删除子表，再删除父表。 1234567891011121314151617181920212223242526272829303132333435363738394041424344t_student中的classno字段引用t_class表中的cno字段，此时t_student表叫做子表，t_class表叫做父表。 drop table if exists t_student; drop table if exists t_class; create table t_class( cno int primary key, cname varchar(255) ); create table t_student( sno int primary key, sname varchar(255), classno int, foreign key(classno) references t_class(cno) ); insert into t_class values(101,&#39;高一一班&#39;); insert into t_class values(102,&#39;高一二班&#39;); insert into t_student values(1,&#39;zs&#39;,101); insert into t_student values(2,&#39;ls&#39;,102); insert into t_student values(3,&#39;ww&#39;,101); insert into t_student values(4,&#39;jack&#39;,101); insert into t_student values(5,&#39;rose&#39;,102); &#x2F;&#x2F;错误插入，因为t_class中的cno没有103这个数据，所以t_student中的classno不能插入103。 insert into t_student values(6,&#39;hh&#39;,&#39;103&#39;); mysql&gt; select * from t_class; +-----+----------+ | cno | cname | +-----+----------+ | 101 | 高一一班 | | 102 | 高一二班 | +-----+----------+ mysql&gt; select * from t_student; +-----+-------+---------+ |sno | sname | classno | +-----+-------+---------+ | 1 | zs | 101 | | 2 | ls | 102 | | 3 | ww | 101 | | 4 | jack | 101 | | 5 | rose | 102 | +-----+-------+---------+ 外键字段可以为NULL嘛？ 可以为NULL。 外键字段引用其他表中的某个字段的时候，被引用的字段必须是主键嘛？ 被引用的字段不一定是主键，但至少具有unique约束。 存储引擎（了解）123456完整的建表语句： create table &#96;t_x&#96;( &#96;id&#96; int ) ENGINE &#x3D; InnoDB DEFAULT CHARSET &#x3D; utf8;注意：在MYSQL中，凡是标识符是可以用飘号&#96;&#96;括起来。（最好别用，不通用） 建表的时候可以指定存储引擎，也可以指定字符集。 MYSQL默认使用的存储引擎是InnoDB方式。 默认采用的字符集是UTF8。 什么是存储引擎？ 存储引擎这个名字只有在MYSQL中存在。（Oracle中有对应的机制，但不叫存储引擎。Oracle中没有特殊的名字，就是“表的存储方式”。） MYSQL支持很多存储引擎，每一个存储引擎都对应了一种不同的存储方式，每一个存储引擎都有自己的优缺点，需要在合适的时机选择合适的存储引擎。 查看当前MYSQL支持的存储引擎？1show engines \\G; 常见的存储引擎？MYISAM存储引擎 不支持事务，是MYSQL最常用的存储引擎，但这种引擎不是默认的。 特征：用三个文件表示每个表 格式文件：存储表结构的定义(.frm) 数据文件：存储表行的内容(.MYD) 索引文件：存储表上索引(.MYI) 优点：可被压缩，节省存储空间。并且可以转化为只读表，提高检索效率。 缺点： 不支持事务。 InnoDB存储引擎 优点：支持事务，这种存储引擎数据的安全得到保障。 表的结构存储在.frm文件中。 数据存储在table space这样的表空间中(逻辑概念)，无法被压缩，无法转化成只读。 这种InnoDB引擎在MYSQL数据库崩溃之后提供自动恢复机制。 InnoDB支持级联删除和级联更新。 MEMORY存储引擎（以前叫HEAP存储引擎） 缺点：不支持事务。数据容易丢失，因为所有数据和索引都是存储在内存当中。 优点：查询速度快。 事务（Transaction）什么是事务？ 一个事务是一个完整的业务逻辑单元，不可再分。 比如：银行账户转账，从A账户向B账户转账10000，需要执行两条updata语句：updata t_act set balance = balance - 10000 where actno = ‘act-001’;updata t_act set balance = balance + 10000 where actno = ‘act-002’;以上两条DML语句必须同时成功，或者同时失败，不允许出现一条成功一条失败。 要想保证以上两条DML语句同时成功或同时失败，那么就需要使用数据库的“事务机制”。 假设所有的业务都能使用一条DML语句解决，那么就不需要事务机制，但实际情况不是这样，通常一个事需要多条DML语句共同联合完成。 与事务相关的语句 只有DML语句：insert、delete、update因为这三个语句都是和数据库当中的“数据”相关的。事务的存在是为了保证数据的完整性、安全性。 事务的四大特性：ACID A：原子性：事务是最小的工作单元，不可再分。 B：一致性：事务必须保证多条DML语句同时成功或者同时失败。 C：隔离性：事务A与事务B之间具有隔离。 D：持久性：持久性说的是最终数据必须持久化到硬盘文件中，事务才算成功的结束。 关于事务之间的隔离性 事务隔离性存在隔离级别，理论上隔离级别包括四个 第一级别：读未提交（read uncommitted）：对方事务还没有提交，当前事务可以读取到对方未提交的数据。读未提交存在脏读（Dirty Read）现象，表示读到了脏的数据。 第二级别：读已提交（read committed）：对方事务提交后的数据，我方可以读到。这个隔离级别解决了脏读现象。读已提交存在的问题是：不可重复读。 第三级别：可重复读（repeatable read）：这种隔离级别解决了不可重复读问题。不可重复读存在的问题是：读到的数据都是幻象（幻读）。 第四级别：序列化读/串行化读（serializable）：解决了所有问题。存在的问题：效率低、事务需要排队。 数据库的默认级别 Oracle数据库默认的隔离级别是：读已提交MYSQL数据库默认的隔离级别是：可重复读 关闭事务的自动提交 MYSQL事务默认情况下是自动提交的，只要执行任意一条DML语句则提交一次。 关闭方法：start transaction; 设置事务的隔离级别 set global transaction isolation level read uncommitted; 查看全局隔离级别 set @@global transaction_isolation; 索引什么是索引？有什么用？ 索引就相当于一本书的目录，通过目录可以快速的找到对应的资源。 在数据库方面，查询一张表的时候有两种检索方式：全表扫描、根据索引检索（效率很高） 添加索引是给某一个字段或者某些字段添加索引。 主键和具有unique约束的字段自动会添加索引。根据主键查询效率交稿，尽量根据主键索引。 索引为什么可以提高检索效率呢？ 索引虽然可以提高检索效率，但是不能随意的添加索引，因为索引也是数据库当中的对象，也需要数据库不断的维护，是有维护成本的。比如，表中的数据经常被修改这样不适合添加索引，因为数据一旦修改，索引需要重新排序，进行维护。 举例123 select ename,sal from emp where ename &#x3D; &#39;SMITH&#39;;当ename字段上没有添加索引的时候，以上SQL语句会进行全表扫描，扫描ename字段中所有的值。当ename字段上添加索引的时候，以上SQl语句会根据索引扫描，快速定位。 查看SQL语句的执行计划：加上explain…（MYSQL特有）123456 explain select ename,sal from emp where sal &#x3D; 5000; 从该语句中可以看出此时扫描了14次。给薪资sal字段添加索引： create index emp_sal_index on emp(sal);此时在通过explain语句查看发现只扫描了一次。 创建、删除索引对象？12345创建索引对象： create index 索引名称 on 表名(字段名);删除索引对象： drop index 索引名称 on 表名; 索引底层数据结构 索引底层采用的数据结构是：B+ Tree 通过B Tree缩小扫描范围，底层索引进行了排序、分区，索引会携带数据在表中的“物理地址”。最终通过索引检索到数据之后，获取到关联的物理结构，通过物理地址定位表中的数据，效率是最高的。 123 select ename from emp where ename &#x3D; &#39;SMITH&#39;;通过索引转化成： select ename from emp where 物理地址 &#x3D; XXX; 什么时候考虑给字段添加索引？ 数据量庞大。（根据客户的需求，根据线上的环境） 该字段很少的DML操作。（因为字段进行修改操作，索引需要维护） 该字段经常出现在where子句中。（经常根据哪个字段查询） 索引的分类？ 单一索引：给单个字段添加索引 复合索引：给多个字段联合起来添加1个索引 主键索引：主键上会自动添加索引 唯一索引：有unique约束的字段会自动添加索引 索引什么时候失效？12 select ename from emp where ename like &#39;%A%&#39;;模糊查询时，第一个通配符使用的是%，这时候索引是失效的。 视图（view）什么是视图？ 站在不同的角度去看待数据（同一张表的数据通过不同的角度去看待） 怎么创建、删除视图？ 注意：只要DQL语句才能以视图对象的方式创建出来。 对视图进行增删改查，会影响到原表数据。 可以对视图进行CRUD操作。 1234创建视图： create view myview as select empno,ename from emp;删除视图： drop view myview; 面向视图操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687mysql&gt; select * from emp_bak;+-------+--------+-----------+------+------------+---------+---------+--------+| EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | DEPTNO |+-------+--------+-----------+------+------------+---------+---------+--------+| 7369 | SMITH | CLERK | 7902 | 1980-12-17 | 800.00 | NULL | 20 || 7499 | ALLEN | SALESMAN | 7698 | 1981-02-20 | 1600.00 | 300.00 | 30 || 7521 | WARD | SALESMAN | 7698 | 1981-02-22 | 1250.00 | 500.00 | 30 || 7566 | JONES | MANAGER | 7839 | 1981-04-02 | 2975.00 | NULL | 20 || 7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 | 30 || 7698 | BLAKE | MANAGER | 7839 | 1981-05-01 | 2850.00 | NULL | 30 || 7782 | CLARK | MANAGER | 7839 | 1981-06-09 | 2450.00 | NULL | 10 || 7788 | SCOTT | ANALYST | 7566 | 1987-04-19 | 3000.00 | NULL | 20 || 7839 | KING | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL | 10 || 7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 | 0.00 | 30 || 7876 | ADAMS | CLERK | 7788 | 1987-05-23 | 1100.00 | NULL | 20 || 7900 | JAMES | CLERK | 7698 | 1981-12-03 | 950.00 | NULL | 30 || 7902 | FORD | ANALYST | 7566 | 1981-12-03 | 3000.00 | NULL | 20 || 7934 | MILLER | CLERK | 7782 | 1982-01-23 | 1300.00 | NULL | 10 |+-------+--------+-----------+------+------------+---------+---------+--------+create view myview as select empno,ename,sal from emp_bak;mysql&gt; select * from myview;+-------+--------+---------+| empno | ename | sal |+-------+--------+---------+| 7369 | SMITH | 800.00 || 7499 | ALLEN | 1600.00 || 7521 | WARD | 1250.00 || 7566 | JONES | 2975.00 || 7654 | MARTIN | 1250.00 || 7698 | BLAKE | 2850.00 || 7782 | CLARK | 2450.00 || 7788 | SCOTT | 3000.00 || 7839 | KING | 5000.00 || 7844 | TURNER | 1500.00 || 7876 | ADAMS | 1100.00 || 7900 | JAMES | 950.00 || 7902 | FORD | 3000.00 || 7934 | MILLER | 1300.00 |+-------+--------+---------+通过视图修改原表数据：update myview set ename &#x3D; &#39;hehe&#39;,sal &#x3D; 1 where empno &#x3D; 7369;mysql&gt; select * from myview;+-------+--------+---------+| empno | ename | sal |+-------+--------+---------+| 7369 | hehe | 1.00 || 7499 | ALLEN | 1600.00 || 7521 | WARD | 1250.00 || 7566 | JONES | 2975.00 || 7654 | MARTIN | 1250.00 || 7698 | BLAKE | 2850.00 || 7782 | CLARK | 2450.00 || 7788 | SCOTT | 3000.00 || 7839 | KING | 5000.00 || 7844 | TURNER | 1500.00 || 7876 | ADAMS | 1100.00 || 7900 | JAMES | 950.00 || 7902 | FORD | 3000.00 || 7934 | MILLER | 1300.00 |+-------+--------+---------+此时查询原表emp_bak发现数据变了。mysql&gt; select * from emp_bak;+-------+--------+-----------+------+------------+---------+---------+--------+| EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | DEPTNO |+-------+--------+-----------+------+------------+---------+---------+--------+| 7369 | hehe | CLERK | 7902 | 1980-12-17 | 1.00 | NULL | 20 || 7499 | ALLEN | SALESMAN | 7698 | 1981-02-20 | 1600.00 | 300.00 | 30 || 7521 | WARD | SALESMAN | 7698 | 1981-02-22 | 1250.00 | 500.00 | 30 || 7566 | JONES | MANAGER | 7839 | 1981-04-02 | 2975.00 | NULL | 20 || 7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 | 30 || 7698 | BLAKE | MANAGER | 7839 | 1981-05-01 | 2850.00 | NULL | 30 || 7782 | CLARK | MANAGER | 7839 | 1981-06-09 | 2450.00 | NULL | 10 || 7788 | SCOTT | ANALYST | 7566 | 1987-04-19 | 3000.00 | NULL | 20 || 7839 | KING | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL | 10 || 7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 | 0.00 | 30 || 7876 | ADAMS | CLERK | 7788 | 1987-05-23 | 1100.00 | NULL | 20 || 7900 | JAMES | CLERK | 7698 | 1981-12-03 | 950.00 | NULL | 30 || 7902 | FORD | ANALYST | 7566 | 1981-12-03 | 3000.00 | NULL | 20 || 7934 | MILLER | CLERK | 7782 | 1982-01-23 | 1300.00 | NULL | 10 |+-------+--------+-----------+------+------------+---------+---------+--------+通过视图删除原表数据：delete from myview where empno &#x3D; 7369;这里和上面一样，不在做演示。 视图的作用？ 视图可以隐藏表的实现细节。保密级别较高的系统，数据库只对外提供相关的视图，Java程序员只对视图对象进行CRUD。 DBA命令将数据库当中的数据导出（导出整个库） 在Windows的dos命令窗口执行mysqldump firstsql &gt; D:\\firstsql.sql -uroot -p123456; 导出指定数据库中的指定表 mysqldump firstsql emp &gt; D:\\firstsql.sql -uroot -p123456; 导入数据123create datebase 名字;use 名字;source D:\\firstsql.sql; 数据库设计三范式什么是三范式 设计表的依据。按照这个三范式设计的表不会出现数据元素。 三范式有哪些？ 第一范式：任何一张表都应该有主键，并且每一个字段原子性不可再分。 第二范式：建立在第一范式的基础上，所有非主键字段完全依赖主键，不能产生部分依赖。多对多：三张表，关系表两个外键 第三范式：建立在第二范式的基础之上，所有非主键字段直接依赖主键，不能产生传递依赖。一对多：两张表，多的表加外键 提示：在实际的开发中，以满足客户需求为主，有的时候会拿冗余换执行速度。 一对一怎么设计？ 一对一设计有两种方案：主键共享、外键唯一。","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"}]},{"title":"基数排序","date":"2021-03-31T14:23:41.000Z","path":"2021/03/31/基数排序/","text":"概念1待补充 代码如下主方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import java.util.Scanner;public class Demo &#123; public static void main(String[] args) &#123; int number = 0;//数组B的下标 int k = 1;//看第k位，从（倒数）第一位开始看 int Max = 0;//数组当中最大的数有几位 int count = 0; Scanner sc = new Scanner(System.in); System.out.print(&quot;请输入要排序的数的数量：&quot;); count = sc.nextInt(); int[] arrayA = new int[count]; int[] arrayB = new int[arrayA.length]; System.out.print(&quot;请输入&quot;+count+&quot;个数：&quot;); for(int i = 0;i &lt; count;i++)&#123; arrayA[i] = sc.nextInt(); &#125; //int[] arrayC = new int[arrayA.length]; //求最高位数 for(int i = 0; i &lt;arrayA.length;i++)&#123; int temp = getMax(arrayA[i]); if(temp &gt;= Max)&#123; Max = temp; &#125; &#125; //System.out.println(Max);//最高位数 //打印输出原始数组 System.out.print(&quot;原始素组为:&quot;); for (int i = 0; i &lt; arrayA.length; i++) &#123; System.out.print(arrayA[i]+&quot; &quot;); &#125; System.out.println(); //基数排序 while(k != Max+1)&#123; int p = 0;//判断循环是否结束 for(int i = 0;i &lt;=9 ;i++)&#123;//0~9是第几位的范围 for(int j = 0;j &lt;arrayA.length;j++)&#123; if(getNum(arrayA[j],k) == i)&#123; arrayB[number] = arrayA[j]; number++;//数组B的下标要单独定义，每次赋值后都需要移动到下一个下标 if(number == arrayA.length)&#123; break;//如果数组B已经满了，则提前结束循环 &#125; &#125; &#125; if(number == arrayA.length)&#123;//数组B存满后 number = 0;//重置数组B的下标 //System.out.println(&quot;k:&quot;+k); k++;//看的位数进行移动 /* //将原本的A数组给数组C for (i = 0; i &lt; arrayA.length; i++) &#123; arrayC[i] = arrayA[i]; &#125; */ //将新的数组B重新赋值给arrayA for (i = 0; i &lt; arrayA.length; i++) &#123; arrayA[i] = arrayB[i]; &#125; //打印输出 System.out.print(&quot;第&quot;+(k-1)+&quot;轮输出：&quot;);//因为前面提前k++了，所以应该是k-1轮。 for (i = 0; i &lt; arrayA.length; i++) &#123; System.out.print(arrayA[i]+&quot; &quot;); &#125; System.out.println(); break;//数组B满了后这个循环也要提前结束 &#125; &#125; //错误，不能这么判断，否则若在还没排完前一样的时候会提前结束 //判断数组B、C是否一样，如果一样，则提前结束循环 / *for(int i = 0;i &lt;arrayA.length;i++)&#123; if(arrayA[i] == arrayC[i])&#123; p++;//1+1+1+1=arrayA.length &#125; &#125; if(p == arrayA.length)&#123; break; &#125; */ &#125; &#125; 方法1：给定一个数num，返回该数的倒数第k个数，例如 num = 231, k = 2,则返回 3123456789101112public static int getNum(int num, int k) &#123; int count = 0; while(k != 0) &#123; count = num % 10; num = num / 10; /* if(num == 0)&#123; break; &#125;*/ k--; &#125; return count;&#125; 方法2：得到一个数有几位123456789 public static int getMax(int array)&#123; int count = 0;//计数器 while (array != 0)&#123; array = array/10; count++; &#125; return count; &#125;&#125; 总结121、基数排序的原理比较简单，但是代码实现起来比较复杂。2、","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"Java学习记录","date":"2021-03-24T06:45:00.000Z","path":"2021/03/24/Java学习记录/","text":"算法设计与分析实验一第一题题目12345678910给定一个正整数，编写程序计算有多少对质数的和等于输入的这个正整数，并输出结果。输入值小于1000。如，输入为10, 程序应该输出结果为2。（共有两对质数的和为10，分别为(5, 5) , (3, 7)）。输入输入一个整数n( 3≤n&lt;1000)。输出输出对数。样例输入10样例输出2 举例说明123410 【3,7】、【5,5】 212 【1,11】、【5,7】 215 【2,13】 120 【1,19】、【3,17】、【7,13】 3 分析12341、写一个方法来判断一个数是不是素数2、从头开始遍历，判断每一个数是否满足条件 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package study01;import java.util.Scanner;public class demo01 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int num = sc.nextInt(); //键盘获取输入的num值 int count = 0; //定义一个count，用来记录最后有几个质数对 int a = 1;//定义两个数，它们的和为num int b = num - a; //循环从1开始到中间那个数，排除了 例如num=10，有【3,7】，【7,3】这样的重复 while( a!= (num/2 + 1) ) &#123; if (sushu ( a ) &amp;&amp; sushu ( b )) &#123; count ++; //如果a,b都是素数，则计数器加一 System.out.println(&quot;[&quot;+a+&quot;,&quot;+b+&quot;] &quot;); &#125; a++; //循环一次后a++,b--，进行下次循环,满足条件后跳出循环 b--; //System.out.println(a+&quot; &quot;+b); &#125; System.out.println(count); //输出结果 &#125; //素数：除了1和它本身外不能被其他数整除的数叫做素数。 //判断的方法是从2到num-1，遍历看能不能被整除，如果能被其中的一个整除，则不是素数，如果都不可以整除，那么就不是素数。 //用来判断一个数是否为素数，如果是素数则返回true，如果不是素数则返回false public static boolean sushu(int num) &#123; if (num == 2 ||num == 1) &#123; //如果num刚好为2，则判定直接为素数 return true; &#125; else &#123; for (int i = 2; i &lt; num; i++) &#123; if (num % i == 0) &#123; return false; &#125;else&#123; //这里特别注意一定要讲循环走完一圈才可以出去，否则判断一次后循环就会结束。 if(i==num-1)&#123; return true; //判定i==num-1时才是循环了一圈，所以结束循环 &#125;else continue; //否则跳过此次循环进行下一次循环 &#125; &#125; return false; &#125; &#125;&#125; 总结以及心得1231、循环判断数的时候，为了避免【7，3】、【3,7】这种相同的情况，因此只需要判断到一半的位置即可。2、判断一个数是否为素数的时候，只遍历除了1和这个数本身之外的其他数，能否被自己整除即可。如果可以被整除，那么就不是素数。如果不可以被整除，那么就是素数。注意2是一个特殊情况，需要单独考虑。 第二题题目1234567891011121314151617181920小明想给老师当助教从而得一些补助。老师会给小明一些作业让他去批改，并按批改的作业份数和批改正确率来确定小明的补助费。老师是这么规定的，批改一份作业小明会得到m元，如果该份作业批改完全正确那么会从中扣除k元复查费；如果批改中出现了错误会从中扣除x元当惩罚费用，此时这份作业不再扣除复查费。但是老师觉得小明勤工助学不容易，不想扣过多的费用，于是规定如果有一份作业批改错误扣了x元，那么可以抵消一份批改正确作业的复查费。举例，如果有两份作业，一份批改正确一份批改错误，那么错误的那份小明可以得到m-x元，正确的那份小明可以得到m元，不用扣复查费。最后，你能算出小明一共能得多少补助么?输入第一行四个整数n、m、x、k，n表示小明批改作业的总份数，m、x、k的含义如题面描述，1≤n≤100000，1≤m, x, k≤100，x, k≤m;第二行n个整数，每个整数只有两种可能，0表示该份作业批改错误，1表示该份作业批改正确。输出输出一个整数，表示小明最后一共得到的补助费。样例输入总份数n 批改正确得到的钱 m 惩罚费用x 复查费k4 5 2 11 1 1 0（三正确 一错误） 1 1 1 1 0 0 10-2+20-4样例输出16 24 举例说明121 1 1 1 0 0 24 分析12341、通过Scanner函数来进行数字的输入2、知道题目结果如何计算3、考虑错误题目大于正确题目的特殊情况 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344package study02;import java.util.Scanner;public class demo01 &#123; public static void main(String[] args) &#123; int n, m, x, k; int r = 0;//改正确的题目 int f = 0;//改错误的题目 //总份数n 批改正确得到的钱 m 惩罚费用x 复查费k System.out.print(&quot;请依次输入 总份数n 批改正确得到的钱 m 惩罚费用x 复查费k：&quot;); Scanner sc = new Scanner(System.in);//键盘输入n,m,x,k n = sc.nextInt(); m = sc.nextInt(); x = sc.nextInt(); k = sc.nextInt(); System.out.print(&quot;请输入作业更改情况（正确为1，错误为0,最多输入&quot;+n+&quot;个数）：&quot;); int array[] = new int[n];//定义一个数组，用来记录题目的错误，并统计正确与错误赋值给r,f for(int i = 0; i &lt; n; i++)&#123; array[i] = sc.nextInt(); //System.out.print(array[i]+&quot;\\t&quot;);//输出数组 if(array[i]==1)&#123; r++; &#125;else if(array[i]==0)&#123; f++; &#125;else&#123; System.out.println(&quot;输入错误！&quot;); break; &#125; &#125; //System.out.println(&quot;r=&quot;+r); //System.out.println(&quot;f=&quot;+f); int sum = 0;//总价格 if(r&gt;=f)&#123; //正确题数大于错误题数 sum = n*m - f*x - (r-f)*k; &#125;else&#123; //错误题数大于正确题数，此时（r-f)为负，不能用上面的计算方式，此时不需要考虑复查情况。 sum=n*m - f*x; &#125; System.out.println(&quot;小明得到的钱为&quot; + sum);//输出结果 &#125;&#125; 总结以及心得12341、此题并不难，只需要知道题目的计算方式即可2、通过这题要学会Scanner函数的使用方法，该函数可以通过多次获取做到多次输入给多个数据赋值 注意：如果定义的只有n个数据，那么输入超过n个数的时候，只会获取前n个数据并进行赋值。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]}]