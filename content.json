[{"title":"Java常用类","date":"2021-04-21T07:47:54.000Z","path":"2021/04/21/Java常用类/","text":"字符串相关的类 String类及常用方法String的使用String：字符串，使用一对“ ”引起来表示。 String声明为final的，不可被继承。 String实现了Serializable接口：表示字符串是支持序列化的。 ​ 实现了Comparable接口：表示String可以比较大小。 String内部定义了final char[] value用于存储字符串数据。 String：代表不可变的字符序列。简称：不可变性。 体现： 当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。 字符串常量池中不会存储相同内容的字符串的。 StringBuffer、StringBuilderJDk8之前的日期时间APISystem静态方法Date类Calender类SimpleDateFormat类JDK8中新日期时间APILocalDate、LocalTime、LocalDateTimeInstantDateTimeFormatter其他类Java比较器Comparable接口Comparator接口System类Math类BigInteger与BigDecimal","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"多线程知识总结","date":"2021-04-19T12:01:32.000Z","path":"2021/04/19/死锁/","text":"死锁问题 死锁的理解 不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。 出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续。我们使用同步时，要避免出现死锁。 演示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//演示线程的死锁问题：public class ThreadTest &#123; public static void main(String[] args) &#123; StringBuffer s1 = new StringBuffer(); StringBuffer s2 = new StringBuffer(); new Thread()&#123; @Override public void run() &#123; synchronized (s1)&#123; s1.append(&quot;a&quot;); s2.append(&quot;1&quot;); //加了sleep后出现死锁的概率会大大增加。 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (s2)&#123; s1.append(&quot;b&quot;); s2.append(&quot;2&quot;); System.out.println(s1); System.out.println(s2); &#125;s &#125; &#125; &#125;.start(); new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (s2)&#123; s1.append(&quot;c&quot;); s2.append(&quot;3&quot;); //加了sleep后出现死锁的概率会大大增加。 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (s1)&#123; s1.append(&quot;d&quot;); s2.append(&quot;4&quot;); System.out.println(s1); System.out.println(s2); &#125; &#125; &#125; &#125;).start(); &#125;&#125;此时很大概率会出现程序会出现死锁，无法继续执行的问题。 解决方法 专门的算法、原则。 尽量减少同步资源的定义。 尽量避免嵌套同步。 Lock（锁）定义 解决线程安全问题的方式三（JDK5.0新增） 演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.concurrent.locks.ReentrantLock;class Window implements Runnable&#123; private int ticket = 100; //1.实例化ReentrantLock private ReentrantLock lock = new ReentrantLock(); @Override public void run() &#123; while (true)&#123; try &#123; //2.调用锁定方法：lock() lock.lock(); if(ticket &gt; 0)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;:售票，票号为：&quot;+ticket); ticket--; &#125;else&#123; break; &#125; &#125;finally &#123; //3.调用解锁的方法：unlock(); lock.unlock(); &#125; &#125; &#125;&#125;public class LockTest &#123; public static void main(String[] args) &#123; Window w = new Window(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; synchronize 与 Lock 的对比 Lock是显式锁（手动开启和关闭锁），synchronize是隐式锁，出了作用域自动释放。 Lock只有代码块锁，synchronize有代码块锁和方法锁。 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）。 优先使用顺序 Lock –&gt; 同步代码块（已经进入了方法体，分配了相应资源） –&gt; 同步方法（在方法体之外） 如何解决线程安全问题？有几种方式 synchronize(两种)：同步代码块和同步方法。Lock锁(一种) 线程的通信（主要涉及三种方法）三种方法 wait():一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。 notify():一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。 notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。 三种方法说明 wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中。 wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器。否则，会出现IllegalMonitorStateException异常。 wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。 sleep() 和 wait()的异同？相同点： 一旦执行方法，都可以使得当前的线程进入阻塞状态。不同点： 不同点：两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait()。 调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中。 关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。 题目使用两个线程打印 1-100。线程1, 线程2 交替打印。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Number implements Runnable&#123; private int number = 1; private Object obj = new Object(); @Override public void run() &#123; while(true)&#123; synchronized (obj) &#123; obj.notify(); if(number &lt;= 100)&#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + number); number++; try &#123; //使得调用如下wait()方法的线程进入阻塞状态 obj.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;else&#123; break; &#125; &#125; &#125; &#125;&#125;public class CommunicationTest &#123; public static void main(String[] args) &#123; Number number = new Number(); Thread t1 = new Thread(number); Thread t2 = new Thread(number); t1.setName(&quot;线程1&quot;); t2.setName(&quot;线程2&quot;); t1.start(); t2.start(); &#125;&#125; JDK5.0新增线程创建方式新增方式一：实现Callable接口创建过程 创建一个实现Callable的实现类 实现call方法，将此线程需要执行的操作声明在call()中 创建Callable接口实现类的对象 将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象 将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start() 获取Callable中call方法的返回值 Runnable 与 Callable 相比与使用Runnable相比，Callable功能更强大些 相比run()方法，可以有返回值 call()方法可以抛出异常，被外面的操作捕获，获取异常的信息 Callable是支持泛型的 需要借助Future Task类，比如获取返回结果Future接口 可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。 FutrueTask是Future接口的唯一的实现类 FutureTask同时实现了Runnable、Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。 新增方式二：使用线程池背景 经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。 思路 提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。 好处 提高响应速度（减少了创建新线程的时间） 降低资源消耗（重复利用线程池中线程，不需要每次都创建） 便于线程管理 使用线程池案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.ThreadPoolExecutor;class NumberThread implements Runnable&#123; @Override public void run() &#123; for(int i = 0;i &lt;= 100;i++)&#123; if(i % 2 == 0)&#123; System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i); &#125; &#125; &#125;&#125;class NumberThread1 implements Runnable&#123; @Override public void run() &#123; for(int i = 0;i &lt;= 100;i++)&#123; if(i % 2 != 0)&#123; System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i); &#125; &#125; &#125;&#125;public class ThreadPool &#123; public static void main(String[] args) &#123; //1. 提供指定线程数量的线程池 ExecutorService service = Executors.newFixedThreadPool(10); ThreadPoolExecutor service1 = (ThreadPoolExecutor) service; //设置线程池的属性// System.out.println(service.getClass());// service1.setCorePoolSize(15);// service1.setKeepAliveTime(); //2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象 service.execute(new NumberThread());//适合适用于Runnable service.execute(new NumberThread1());//适合适用于Runnable// service.submit(Callable callable);//适合使用于Callable //3.关闭连接池 service.shutdown(); &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"MySQL知识总结","date":"2021-04-03T07:32:22.000Z","path":"2021/04/03/MySQL知识总结/","text":"什么是数据库？SQL、DB、DBMS分别是什么？123SQL：结构化查询语句，是一门标准通用的语言。 DB：DataBase，数据库，实际上在硬盘上以文件的形式存在。DBMS：DataBase Management System，数据库管理系统。 标准的SQL适用于所有的数据库产品。SQL属于高级语言。 SQL执行的过程12345SQL语句在执行的时候，先编译（编译由DBMS完成）后执行。DBMS负责执行sql语句，通过执行sql语句来操作DB当中的数据。DBMS -&gt; (执行) -&gt; SQL -&gt; (操作) -&gt;DB 表(table)什么是表？1表：table是数据库的基本组成单元，所有的数据都以表格的形式组织，目的是可续性强。 表的组成123表由行和列组成：行：称为数据/记录(data)列：称为字段(column) SQL语句分类 DQL(数据查询语言)：查询语句，凡是select语句都是SQL。DML(数据操作语言)：insert、delete、update，对表中的数据进行增删改DDL(数据定义语言)：create、drop、alter，对表结构的增删改TCL(事务(Transaction)控制语言)：commit提交事务，rollback回滚事务。DCL(数据控制语言)：grant授权，revoke撤销权限等。 MySQL的登录及简答查询登录MySQl dos命令：mysql -uroot -p密码 查看有哪些数据 show databases;注意：这不是SQL语句，而是MySQL命令 。 创建属于我们自己的数据库 create database 名字;我们这里创建firstsql,即 create database firstsql; 使用创建的数据库 use 数据库名字；注意：这也是MySQL命令。 查看当前使用的数据库中有哪些表 show tables;注意：这也是MySQL命令。 初始化数据 输入source，然后将数据表拖进来。注意：数据初始化完成之后，有三张表：dept、emp、salgrade。 1234567+--------------------+| Tables_in_firstsql |+--------------------+| dept || emp || salgrade |+--------------------+ 1234注意事项：1、SQL语言的文件被称为“SQL脚本”。2、当一个文件的扩展名是.sql，并且该文件中编写了大量的SQL语句，我们称这样的文件为SQL脚本。3、source可以执行SQL脚本，当SQL脚本中的数据太大的时候，无法直接打开，我们就可以使用source命令完成初始化。 删除数据库 drop database firstsql; 查看表结构 desc dept;desc emp;desc salgrade; 123456789101112131415161718192021222324252627282930313233343536373839404142434445mysql&gt; desc dept;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| DEPTNO | int | NO | PRI | NULL | || DNAME | varchar(14) | YES | | NULL | || LOC | varchar(13) | YES | | NULL | |+--------+-------------+------+-----+---------+-------+DEPTNO:部门编号DNAME:部门名称LOC:部门位置mysql&gt; desc emp;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| EMPNO | int | NO | PRI | NULL | || ENAME | varchar(10) | YES | | NULL | || JOB | varchar(9) | YES | | NULL | || MGR | int | YES | | NULL | || HIREDATE | date | YES | | NULL | || SAL | double(7,2) | YES | | NULL | || COMM | double(7,2) | YES | | NULL | || DEPTNO | int | YES | | NULL | |+----------+-------------+------+-----+---------+-------+EMPNO: 员工编号ENAME:员工姓名JOB:工作岗位 MGR:上级领导编号HIREDATE:入职日期SAL:月薪 COMM:补助/津贴 DEPTNO:部门编号 mysql&gt; desc salgrade;+-------+------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+------+------+-----+---------+-------+| GRADE | int | YES | | NULL | || LOSAL | int | YES | | NULL | || HISAL | int | YES | | NULL | |+-------+------+------+-----+---------+-------+GRADE:等级LOSAL:最低薪资HISAL:最高薪资 查看表中所有的数据 select * form 表名;注意在实际开发(写入Java程序时)当中不建议使用 *，因为效率比较低。 12345678910mysql&gt; select * from dept;+--------+------------+----------+| DEPTNO | DNAME | LOC |+--------+------------+----------+| 10 | ACCOUNTING | NEW YORK || 20 | RESEARCH | DALLAS || 30 | SALES | CHICAGO || 40 | OPERATIONS | BOSTON |+--------+------------+----------+这里我们只举一个dept表的例子，可以查看dept表当中的全部数据。 常用的MySQL命令查看当前使用的是哪一个数据库 select database(); 123456mysql&gt; select database();+------------+| database() |+------------+| firstsql |+------------+ 查看MySQL的版本 select version(); 123456mysql&gt; select version();+-----------+| version() |+-----------+| 8.0.23 |+-----------+ 结束一条语句 \\c 12345mysql&gt; select -&gt; * -&gt; \\cmysql&gt;输入\\c后直接结束这一条语句 退出MySQL exit 12mysql&gt; exitBye 查看建表的语句 show create table emp; 简单的查询语句(DQL)语法格式1234select 字段名1，字段名2，...from 表名; 123注意事项：1、任何一条SQL语句都以“ ; ”结尾。2、SQL语句不区分大小写。 字段可以参与数学运算题目:请输出员工的年薪 select ename, sal * 12 from emp; 123456789101112131415161718+--------+----------+| ename | sal*12 |+--------+----------+| SMITH | 9600.00 || ALLEN | 19200.00 || WARD | 15000.00 || JONES | 35700.00 || MARTIN | 15000.00 || BLAKE | 34200.00 || CLARK | 29400.00 || SCOTT | 36000.00 || KING | 60000.00 || TURNER | 18000.00 || ADAMS | 13200.00 || JAMES | 11400.00 || FORD | 36000.00 || MILLER | 15600.00 |+--------+----------+ 给查询结果的列(sal*12)重命名 select ename, sal * 12 as yearsal from, emp;将sal*12重命名为yearsalas关键字也可以省略不写select ename, sal * 12 yearsal from, emp; 1234567891011121314151617181920212223242526272829303132333435363738394041写as:mysql&gt; select ename,sal*12 as yearsal from emp;+--------+----------+| ename | yearsal |+--------+----------+| SMITH | 9600.00 || ALLEN | 19200.00 || WARD | 15000.00 || JONES | 35700.00 || MARTIN | 15000.00 || BLAKE | 34200.00 || CLARK | 29400.00 || SCOTT | 36000.00 || KING | 60000.00 || TURNER | 18000.00 || ADAMS | 13200.00 || JAMES | 11400.00 || FORD | 36000.00 || MILLER | 15600.00 |+--------+----------+不写as:mysql&gt; select ename,sal*12 yearsal from emp;+--------+----------+| ename | yearsal |+--------+----------+| SMITH | 9600.00 || ALLEN | 19200.00 || WARD | 15000.00 || JONES | 35700.00 || MARTIN | 15000.00 || BLAKE | 34200.00 || CLARK | 29400.00 || SCOTT | 36000.00 || KING | 60000.00 || TURNER | 18000.00 || ADAMS | 13200.00 || JAMES | 11400.00 || FORD | 36000.00 || MILLER | 15600.00 |+--------+----------+ 当别名当中有中文的时候，要注意： 正确写法：select ename, sal * 12 as ‘年薪’ from emp;错误写法：select ename, sal * 12 as 年薪 from emp; 123456789101112131415161718+--------+----------+| ename | 年薪 |+--------+----------+| SMITH | 9600.00 || ALLEN | 19200.00 || WARD | 15000.00 || JONES | 35700.00 || MARTIN | 15000.00 || BLAKE | 34200.00 || CLARK | 29400.00 || SCOTT | 36000.00 || KING | 60000.00 || TURNER | 18000.00 || ADAMS | 13200.00 || JAMES | 11400.00 || FORD | 36000.00 || MILLER | 15600.00 |+--------+----------+ 条件查询语法格式12345678 select 字段1，字段2，... from 表名 where 条件;执行顺序：from --&gt; where --&gt; select 题目：查询工资等于5000的员工姓名 select ename, sal from emp where sal = 5000; 12345+-------+---------+| ename | sal |+-------+---------+| KING | 5000.00 |+-------+---------+ 题目：查询SMITH的工资 select ename, sal from emp where ename = ‘SMITH’;注意：字符串要用’ ‘括起来 12345+-------+--------+| ename | sal |+-------+--------+| SMITH | 800.00 |+-------+--------+ 题目：查询工资不为3000的员工 select ename, sal from emp where sal &lt;&gt; 3000;select ename, sal from emp where sal != 3000;注意：不等于有两种表达形式：&lt;&gt; 和 != 12345678910111213141516171819202122232425262728293031323334353637全部员工的工资：+--------+---------+| ename | sal |+--------+---------+| SMITH | 800.00 || ALLEN | 1600.00 || WARD | 1250.00 || JONES | 2975.00 || MARTIN | 1250.00 || BLAKE | 2850.00 || CLARK | 2450.00 || SCOTT | 3000.00 || KING | 5000.00 || TURNER | 1500.00 || ADAMS | 1100.00 || JAMES | 950.00 || FORD | 3000.00 || MILLER | 1300.00 |+--------+---------+工资不等于3000的员工：+--------+---------+| ename | sal |+--------+---------+| SMITH | 800.00 || ALLEN | 1600.00 || WARD | 1250.00 || JONES | 2975.00 || MARTIN | 1250.00 || BLAKE | 2850.00 || CLARK | 2450.00 || KING | 5000.00 || TURNER | 1500.00 || ADAMS | 1100.00 || JAMES | 950.00 || MILLER | 1300.00 |+--------+---------+ between…and…题目：求工资在1500到3000之间的员工 select ename,sal from emp where sal between 1500 and 3000;注意：between…and…是从左到右执行的，因此不能写between 3000 and 1500,此时无数据。 123456789101112+--------+---------+| ename | sal |+--------+---------+| ALLEN | 1600.00 || JONES | 2975.00 || BLAKE | 2850.00 || CLARK | 2450.00 || SCOTT | 3000.00 || TURNER | 1500.00 || FORD | 3000.00 |+--------+---------+可以看出，当between...and...中是数字的时候，范围是左闭右闭的。 题目：求出姓名在A和C之间的员工 select ename from emp where ename between ‘A’ and ‘C’; 1234567891011121314151617181920212223242526272829姓名在A和C之间的员工:+-------+| ename |+-------+| ALLEN || BLAKE || ADAMS |+-------+所有员工：+--------+| ename |+--------+| ADAMS || ALLEN || BLAKE || CLARK || FORD || JAMES || JONES || KING || MARTIN || MILLER || SCOTT || SMITH || TURNER || WARD |+--------+不难看出，between...and...用于字符串的排序的时候，是左臂闭右开的。 is NULL题目：找出哪些人有津贴，哪些人没有津贴。 select ename,comm from emp where comm is NULL;select ename,comm from emp where comm is not NULL;错误写法：select ename,comm from emp where comm = NULL;select ename,comm from emp where comm != NULL;注意事项：在数据库中NULL不是一个值，而是代表什么也没有，为空。空不是一个值，所以不能用等号衡量 12345678910111213141516171819202122232425262728293031323334353637383940414243无津贴的：+--------+------+| ename | comm |+--------+------+| SMITH | NULL || JONES | NULL || BLAKE | NULL || CLARK | NULL || SCOTT | NULL || KING | NULL || ADAMS | NULL || JAMES | NULL || FORD | NULL || MILLER | NULL |+--------+------+有津贴的：+--------+---------+| ename | comm |+--------+---------+| ALLEN | 300.00 || WARD | 500.00 || MARTIN | 1400.00 || TURNER | 0.00 |+--------+---------+全部的：+--------+---------+| ename | comm |+--------+---------+| SMITH | NULL || ALLEN | 300.00 || WARD | 500.00 || JONES | NULL || MARTIN | 1400.00 || BLAKE | NULL || CLARK | NULL || SCOTT | NULL || KING | NULL || TURNER | 0.00 || ADAMS | NULL || JAMES | NULL || FORD | NULL || MILLER | NULL |+--------+---------+ and 与 or题目：找出工作岗位是MANAGER和SALESMAN的员工 select ename,job from emp where job = ‘MANAGER’ or job = ‘SALESMAN’; 1234567891011+--------+----------+| ename | job |+--------+----------+| ALLEN | SALESMAN || WARD | SALESMAN || JONES | MANAGER || MARTIN | SALESMAN || BLAKE | MANAGER || CLARK | MANAGER || TURNER | SALESMAN |+--------+----------+ 题目：找出薪资大于1000并且部门编号是20或者30的员工 select ename,sal,deptno from emp where sal &gt; 1000 and (deptno = 20 or deptno = 30);注意事项：and 的优先级要比 or 高，所以本题当中的()不可以省略，如果省略则错误。 12345678910111213+--------+---------+--------+| ename | sal | deptno |+--------+---------+--------+| ALLEN | 1600.00 | 30 || WARD | 1250.00 | 30 || JONES | 2975.00 | 20 || MARTIN | 1250.00 | 30 || BLAKE | 2850.00 | 30 || SCOTT | 3000.00 | 20 || TURNER | 1500.00 | 30 || ADAMS | 1100.00 | 20 || FORD | 3000.00 | 20 |+--------+---------+--------+ in 与 not in题目：找出工作岗位是找出工作岗位是MANAGER和SALESMAN的员工 select ename,job from emp where job = ‘MANAGER’ or job = ‘SALESMAN’;这是用 or 来写select ename,job from emp where job in(‘MANAGER’,’SALESMAN’);这里用 in 来写不难看出，in 和 or 的功能是一样的，只是写法上面有所不同。 1234567891011121314151617181920212223242526mysql&gt; mysql&gt; select ename,job from emp where job = &#x27;MANAGER&#x27; or job = &#x27;SALESMAN&#x27;;+--------+----------+| ename | job |+--------+----------+| ALLEN | SALESMAN || WARD | SALESMAN || JONES | MANAGER || MARTIN | SALESMAN || BLAKE | MANAGER || CLARK | MANAGER || TURNER | SALESMAN |+--------+----------+mysql&gt; select ename,job from emp where job in(&#x27;MANAGER&#x27;,&#x27;SALESMAN&#x27;);+--------+----------+| ename | job |+--------+----------+| ALLEN | SALESMAN || WARD | SALESMAN || JONES | MANAGER || MARTIN | SALESMAN || BLAKE | MANAGER || CLARK | MANAGER || TURNER | SALESMAN |+--------+----------+ 题目：找出工作岗位不是MANAGER和SALESMAN的员工 select ename,job from emp where job not in(‘MANAGER’,’SALESMAN’); 1234567891011+--------+-----------+| ename | job |+--------+-----------+| SMITH | CLERK || SCOTT | ANALYST || KING | PRESIDENT || ADAMS | CLERK || JAMES | CLERK || FORD | ANALYST || MILLER | CLERK |+--------+-----------+ 模糊查询like题目：找出名字中含有O的员工 select ename from emp where ename like ‘%O%’; 1234567+-------+| ename |+-------+| JONES || SCOTT || FORD |+-------+ 题目：找出名字第二字母是A的员工 select ename from emp where ename like ‘_A%’; 1234567+--------+| ename |+--------+| WARD || MARTIN || JAMES |+--------+ 题目：找出名字中有下划线_的 select ename from emp where ename like ‘%_%’; 1本数据库当中无带有下划线的名字，本题不是只是一个例子，所以这里不展示结果。 总结掌握两个特殊的符号：% 和 _% 代表任意多个字符，_ 代表任意一个字符当我们刚好需要寻找 % 和 _ 的时候，可以用转义字符 \\% \\_来表示。 数据排序格式1234567891011121314151617181920升序(默认升序，不写asc也是升序)：select 字段1，字段2，...from 表名where 条件order by 字段1，字段2，...asc;降序：select 字段1，字段2，...from 表名where 条件order by 字段1，字段2，...desc; 题目：按照工资升序找出员工名和薪资 select ename,sal from emp order by sal;select ename,sal from emp order by sal asc;默认排序就是升序，因此 asc 不写也可以。 123456789101112131415161718+--------+---------+| ename | sal |+--------+---------+| SMITH | 800.00 || JAMES | 950.00 || ADAMS | 1100.00 || WARD | 1250.00 || MARTIN | 1250.00 || MILLER | 1300.00 || TURNER | 1500.00 || ALLEN | 1600.00 || CLARK | 2450.00 || BLAKE | 2850.00 || JONES | 2975.00 || SCOTT | 3000.00 || FORD | 3000.00 || KING | 5000.00 |+--------+---------+ 题目：按照工资降序找出员工名和薪资 select ename,sal from emp order by sal desc; 123456789101112131415161718+--------+---------+| ename | sal |+--------+---------+| KING | 5000.00 || SCOTT | 3000.00 || FORD | 3000.00 || JONES | 2975.00 || BLAKE | 2850.00 || CLARK | 2450.00 || ALLEN | 1600.00 || TURNER | 1500.00 || MILLER | 1300.00 || WARD | 1250.00 || MARTIN | 1250.00 || ADAMS | 1100.00 || JAMES | 950.00 || SMITH | 800.00 |+--------+---------+ 题目：按照工资的降序排列，工资相同是按名字的升序排序 select ename,sal from emp order by sal desc,ename asc; 123456789101112131415161718+--------+---------+| ename | sal |+--------+---------+| KING | 5000.00 || FORD | 3000.00 || SCOTT | 3000.00 || JONES | 2975.00 || BLAKE | 2850.00 || CLARK | 2450.00 || ALLEN | 1600.00 || TURNER | 1500.00 || MILLER | 1300.00 || MARTIN | 1250.00 || WARD | 1250.00 || ADAMS | 1100.00 || JAMES | 950.00 || SMITH | 800.00 |+--------+---------+ 注意事项：有多个字段同时排序的时候，按前后顺序执行，前面出现一样的情况时，才会执行后面的。越靠前的字段越能起到主导作用，只有当前面的字段无法完成排序的时候，才会用后面的字段。 补充：排序也可以这么写 >select ename,sal from emp order by 2; 此时的含义是ename是第一个，sal是第二个，此时按第二个sal进行排序。 这种方法的健壮性很差，一般不推荐使用。 题目：找出工作岗位是SALESMAN的员工，并且按照薪资降序排列。 select ename,job,sal from emp where job = ‘SALESMAN’ order by sal desc; 12345678+--------+----------+---------+| ename | job | sal |+--------+----------+---------+| ALLEN | SALESMAN | 1600.00 || TURNER | SALESMAN | 1500.00 || WARD | SALESMAN | 1250.00 || MARTIN | SALESMAN | 1250.00 |+--------+----------+---------+ 分组函数 分组函数一共有五个：count：计数sum：求和avg：平均值max：最大值min：最小值 多行处理函数与单行处理函数 分组函数又叫多行处理函数，特点是：输入多行，但最终输出的结果为一行。所有的分组函数都是对“某一组”数据进行操作的。单行处理函数：输入一行，输出一行。 题目：找出员工工资总和 >select sum(sal) from emp; 12345+----------+| sum(sal) |+----------+| 29025.00 |+----------+ 题目：找出最高工资 select max(sal) from emp; 12345+----------+| max(sal) |+----------+| 5000.00 |+----------+ 题目：找出总人数 select count(*) from emp;select count(ename) from emp; 12345678910111213select count(*) from emp; +----------+| count(*) |+----------+| 14 |+----------+select count(ename) from emp;+--------------+| count(ename) |+--------------+| 14 |+--------------+ 题目：同时求出总人数，工资总数、平均数、最大值、最小值 select count(*),sum(sal),avg(sal),max(sal),min(sal) from emp; 12345+----------+----------+-------------+----------+----------+| count(*) | sum(sal) | avg(sal) | max(sal) | min(sal) |+----------+----------+-------------+----------+----------+| 14 | 29025.00 | 2073.214286 | 5000.00 | 800.00 |+----------+----------+-------------+----------+----------+ ifnull()空处理函数 所有数据库只要表达式运算有NULL，那么最后的运算结果都为NULL。我们为了解决这个问题，提出了ifnull方法。 1234 格式 ifnull（可能为NULL的数据，被当做什么来处理）例如：ifnull（comm，0）意思就是如果comm中有NULL的话，我们把它当做0来处理 题目：计算每个员工的年薪(加上津贴) select ename,(sal+ifnull(comm,0))*12 as yearsal from emp;这个时候如果comm当做有NULL的话，就当做0来运算。 123456789101112131415161718192021222324252627282930313233343536373839所有员工的津贴如下：+--------+---------+| ename | comm |+--------+---------+| SMITH | NULL || ALLEN | 300.00 || WARD | 500.00 || JONES | NULL || MARTIN | 1400.00 || BLAKE | NULL || CLARK | NULL || SCOTT | NULL || KING | NULL || TURNER | 0.00 || ADAMS | NULL || JAMES | NULL || FORD | NULL || MILLER | NULL |+--------+---------+每个员工的年薪(加上津贴)+--------+----------+| ename | yearsal |+--------+----------+| SMITH | 9600.00 || ALLEN | 22800.00 || WARD | 21000.00 || JONES | 35700.00 || MARTIN | 31800.00 || BLAKE | 34200.00 || CLARK | 29400.00 || SCOTT | 36000.00 || KING | 60000.00 || TURNER | 18000.00 || ADAMS | 13200.00 || JAMES | 11400.00 || FORD | 36000.00 || MILLER | 15600.00 |+--------+----------+ 分组函数会自动忽略到NULL 题目：计算所有员工津贴的总和 select sum(comm) from emp;这里分组函数自动将comm中的NULL忽略掉了。 12345+-----------+| sum(comm) |+-----------+| 2200.00 |+-----------+ 分组函数的执行顺序(这一块需要结合后面的group by理解) 分组函数必须在分完组后才能执行。如果SQL语句中没有group by 语句的话，整个表的数据自成为一组。而group by 语句必须在 where 后面执行，所以分组函数不可以使用在where 子句当中。 题目：找出工资高于平均工资的员工 错误写法：select ename,sal from emp where sal &gt; avg(sal);此时分组函数出现在了where中，因此改语句错误，原因是无效的使用了分组函数。正确写法：select ename,sal from emp where sal &gt; (select avg(sal) from emp); 嵌套一个SQL语句。 12345678910+-------+---------+| ename | sal |+-------+---------+| JONES | 2975.00 || BLAKE | 2850.00 || CLARK | 2450.00 || SCOTT | 3000.00 || KING | 5000.00 || FORD | 3000.00 |+-------+---------+ count(*) 与 count(具体的某个字段) 的区别 count(*)不是统计某个字段中的数据的个数，而是统计总记录条数。（和某个字段无关）count(某个具体的字段)：表示统计该字段中不为NULL的数据总数量。 group by 与 having group by：按照某个字段或者某些字段进行分组。having：是对分组之后的数据进行再次过滤分组函数一般会和group by 联合使用，这也是分组函数为什么叫这个名字的原因。 题目：找出每个工作岗位的最高薪资 select max(sal),job from emp group by job;将emp当中的数据根据job分组后在求出每组当中的最大薪资。 123456789+----------+-----------+| max(sal) | job |+----------+-----------+| 1300.00 | CLERK || 1600.00 | SALESMAN || 2975.00 | MANAGER || 3000.00 | ANALYST || 5000.00 | PRESIDENT |+----------+-----------+ 多个字段联合起来一起分组题目：找出每个部门不用岗位的最高薪资 select deptno,job,max(sal) from emp group by deptno,job order by deptno asc,job asc;这里我们还将结果根据deptno 和 job 进行了升序排序。 1234567891011121314+--------+-----------+----------+| deptno | job | max(sal) |+--------+-----------+----------+| 10 | CLERK | 1300.00 || 10 | MANAGER | 2450.00 || 10 | PRESIDENT | 5000.00 || 20 | ANALYST | 3000.00 || 20 | CLERK | 1100.00 || 20 | MANAGER | 2975.00 || 30 | CLERK | 950.00 || 30 | MANAGER | 2850.00 || 30 | SALESMAN | 1600.00 |+--------+-----------+----------+可以看出，group by 还可以同时多个进行分组的。 having题目：找出每个部门的最高薪资，要求显示最大薪资大于2900的数据。 select deptno,max(sal) from emp group by deptno having max(sal) &gt;2900;select deptno,max(sal) from emo where sal &gt; 2900 group by deptno;这两条语句都可以求出，但是我们用having的效率要比where的效率低，一般我们都推荐尽量使用where。 123456+--------+----------+| deptno | max(sal) |+--------+----------+| 20 | 3000.00 || 10 | 5000.00 |+--------+----------+ 题目：找出每个部门的平均薪资，要求显示平均薪资大于2000的。 select deptno,avg(sal) from emp group by deptno having avg(sal) &gt; 2000;注意：此时的平均薪资是通过分组函数进行求得的，我们无法直接获得这个值，所以此时不能用where来写，因为分组函数不能出现在where中。 123456+--------+-------------+| deptno | avg(sal) |+--------+-------------+| 20 | 2175.000000 || 10 | 2916.666667 |+--------+-------------+ 完整的SQL语句的顺序12345678910111213 执行顺序select 5 ...from 1 ...where 2 ..,group by 3 ...having 4 ...order by 6 ... 关于查询结果集的去重 distinct 关键字，去除重复记录。注意：distinct 关键字只能出现在所有字段的最前面。 题目：查询所有的员工岗位 select distinct job from emp; 1234567891011121314151617181920212223242526272829303132select distinct job from emp;+-----------+| job |+-----------+| CLERK || SALESMAN || MANAGER || ANALYST || PRESIDENT |+-----------+select job from emp;+-----------+| job |+-----------+| CLERK || SALESMAN || SALESMAN || MANAGER || SALESMAN || MANAGER || MANAGER || ANALYST || PRESIDENT || SALESMAN || CLERK || CLERK || ANALYST || CLERK |+-----------+可以看出，通过distinct关键字实现了去重。 错误写法：select ename, distinct job from emp;distinct 关键字只能出现在所有字段的最前面。表示给后面所有的字段进行去重。 题目：查询每个部门的岗位。 select distinct deptno, job from emp order by deptno; 12345678910111213+--------+-----------+| deptno | job |+--------+-----------+| 10 | CLERK || 10 | MANAGER || 10 | PRESIDENT || 20 | ANALYST || 20 | CLERK || 20 | MANAGER || 30 | CLERK || 30 | MANAGER || 30 | SALESMAN |+--------+-----------+ 题目：统计岗位的数量。 select count(distinct job) from emp; 12345+---------------------+| count(distinct job) |+---------------------+| 5 |+---------------------+ 连接查询什么是连接查询？ 在实际开发中，大部分的情况下都不是从单表中查询数据，一般都是从多张表联合查询取出最终的结果。在实际开发中，一般一个业务都会对应多张表，比如学生和班级，起码有两张表。如果存储到一张表中，数据会存在大量的重复，导致数据的冗余。 连接查询的分类 根据语句出现的年代划分：SQL92(一些老的DBA(DataBase Administrator数据库管理员)可能还在使用)。SQL99(比较新的语法)根据表的连接方式划分：内连接：等值连接、非等值连接、自连接外连接：左外连接(左连接)、右外连接(右连接)全连接(很少用) 笛卡尔积现象 在表的连接查询方面有一种现象被称为：笛卡尔积现象。笛卡尔积现象：当两张表进行连接查询的时候，没有任何条件进行限制。最终的查询条数是两张表记录条数的乘积。 题目:找出每一个员工的部门名称，要求显示员工名和部门名。 select ename, dname from emp, dept; 1234567891011121314151617181920212223242526272829303132333435EMP表：+--------+--------+| ename | deptno |+--------+--------+| SMITH | 20 || ALLEN | 30 || WARD | 30 || JONES | 20 || MARTIN | 30 || BLAKE | 30 || CLARK | 10 || SCOTT | 20 || KING | 10 || TURNER | 30 || ADAMS | 20 || JAMES | 30 || FORD | 20 || MILLER | 10 |+--------+--------+DEPT表：+--------+------------+----------+| deptno | dname | loc |+--------+------------+----------+| 10 | ACCOUNTING | NEW YORK || 20 | RESEARCH | DALLAS || 30 | SALES | CHICAGO || 40 | OPERATIONS | BOSTON |+--------+------------+----------+select ename, dname from emp, dept; 56 rows in set (0.31 sec)执行上述语句的时候，会发现一共有14x4=56条结果，这个现象就叫做笛卡尔积现象。 关于表的别名：select e.ename, d.dname from emp e, dept d;好处：执行效率高、可读性好。 如何避免笛卡尔积现象：加条件进行过滤。注意：避免笛卡尔积现象不会减少记录的匹配次数，次数还是56次，只不过显示的是有效记录。 12345678910111213141516171819202122232425262728 select e.ename, d.dname from emp e, dept d where e.deptno = d.deptno;+--------+------------+| ename | dname |+--------+------------+| SMITH | RESEARCH || ALLEN | SALES || WARD | SALES || JONES | RESEARCH || MARTIN | SALES || BLAKE | SALES || CLARK | ACCOUNTING || SCOTT | RESEARCH || KING | ACCOUNTING || TURNER | SALES || ADAMS | RESEARCH || JAMES | SALES || FORD | RESEARCH || MILLER | ACCOUNTING |+--------+------------+14 rows in set (0.00 sec)这是SQL92，以后不用。 内连接等值连接 最大特点：条件是等量关系。 123456789格式： ... A join B on 连接条件 where ... 题目：查询每个员工的部门名称，要求显示员工名和部门名。 1234567SQL92: select e.ename, d.dname from emp e, dept d where e.deptno = d.deptno; 12345678910111213SQL99: SQL99语法结果更清晰一点，表的连接条件和后面的where条件分离了。 select e.ename, d.dname from emp e (inner) join dept d on e.deptno = d.deptno;inner可以省略，带着inner的目的是好读一点。 非等值连接 最大的特点：连接条件中的关系是非等量关系。 题目：找出每个员工的工资等级，要求显示员工名、工资、工资等级。 12345678select e.ename, e.sal, s.gradefrom emp e(inner) join salgrade son e.sal between s.losal and s.hisal; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051EMP表：+--------+---------+| ename | sal |+--------+---------+| SMITH | 800.00 || ALLEN | 1600.00 || WARD | 1250.00 || JONES | 2975.00 || MARTIN | 1250.00 || BLAKE | 2850.00 || CLARK | 2450.00 || SCOTT | 3000.00 || KING | 5000.00 || TURNER | 1500.00 || ADAMS | 1100.00 || JAMES | 950.00 || FORD | 3000.00 || MILLER | 1300.00 |+--------+---------+SALGRADE表：+-------+-------+-------+| grade | losal | hisal |+-------+-------+-------+| 1 | 700 | 1200 || 2 | 1201 | 1400 || 3 | 1401 | 2000 || 4 | 2001 | 3000 || 5 | 3001 | 9999 |+-------+-------+-------+题解：+--------+---------+-------+| ename | sal | grade |+--------+---------+-------+| SMITH | 800.00 | 1 || ALLEN | 1600.00 | 3 || WARD | 1250.00 | 2 || JONES | 2975.00 | 4 || MARTIN | 1250.00 | 2 || BLAKE | 2850.00 | 4 || CLARK | 2450.00 | 4 || SCOTT | 3000.00 | 4 || KING | 5000.00 | 5 || TURNER | 1500.00 | 3 || ADAMS | 1100.00 | 1 || JAMES | 950.00 | 1 || FORD | 3000.00 | 4 || MILLER | 1300.00 | 2 |+--------+---------+-------+ 自连接 最大的特点：一张表看做两张表，自己连接自己。 题目：找出每个员工的上级领导，要求显示员工名称和对应的领导名。 12345678select a.ename, b.enamefrom emp ajoin emp bon a.mgr = b.empno; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758EMP a表：+--------+------+| ename | mgr |+--------+------+| SMITH | 7902 || ALLEN | 7698 || WARD | 7698 || JONES | 7839 || MARTIN | 7698 || BLAKE | 7839 || CLARK | 7839 || SCOTT | 7566 || KING | NULL || TURNER | 7698 || ADAMS | 7788 || JAMES | 7698 || FORD | 7566 || MILLER | 7782 |+--------+------+EMP b表：+--------+-------+| ename | empno |+--------+-------+| SMITH | 7369 || ALLEN | 7499 || WARD | 7521 || JONES | 7566 || MARTIN | 7654 || BLAKE | 7698 || CLARK | 7782 || SCOTT | 7788 || KING | 7839 || TURNER | 7844 || ADAMS | 7876 || JAMES | 7900 || FORD | 7902 || MILLER | 7934 |+--------+-------+题解:+--------+-------+| ename | ename |+--------+-------+| SMITH | FORD || ALLEN | BLAKE || WARD | BLAKE || JONES | KING || MARTIN | BLAKE || BLAKE | KING || CLARK | KING || SCOTT | JONES || TURNER | BLAKE || ADAMS | SCOTT || JAMES | BLAKE || FORD | JONES || MILLER | CLARK |+--------+-------+ 外连接什么是外连接？与内连接有什么区别？ 内连接：假设A和B表进行连接，使用内连接的话，凡是A表和B表能够匹配上的记录查询出来，这就是内连接。A、B两张表没有主副之分，是平等的。外连接：假设A和B表进行连接，使用外连接的话，A、B两张表中有一张表是主表，一张表是副表，主要查询主表中的数据，捎带这查询副表，当副表中的数据没有和主表中的数据匹配上，副表会自动模拟出NULL与之匹配。外连接的分类：左外连接(左连接)：表示左边的这张表是主表。右外连接(右连接)：表示有边的这张表是主表。左连接有右连接的写法，右连接也有对应的左连接的写法。 题目：找出每个员工的上级领导(所以员工必须全部找出(包括KING))。 123456789101112131415161718192021左(外)连接： select a.ename &#x27;员工&#x27;, b.ename &#x27;领导&#x27; from emp a left (outer) join emp b on a.mgr = b.empno;右(外)连接： select a.ename &#x27;员工&#x27;, b.ename &#x27;领导&#x27; from emp b right (outer) join emp a on a.mgr = b.empno;outer可省略！ 12345678910111213141516171819题解：+--------+-------+| 员工 | 领导 |+--------+-------+| SMITH | FORD || ALLEN | BLAKE || WARD | BLAKE || JONES | KING || MARTIN | BLAKE || BLAKE | KING || CLARK | KING || SCOTT | JONES || KING | NULL || TURNER | BLAKE || ADAMS | SCOTT || JAMES | BLAKE || FORD | JONES || MILLER | CLARK |+--------+-------+ 外连接的主要特点是：主表的数据无条件的全部查询出来。 题目：找出哪个部门没有员工。 123456789101112131415161718192021222324左连接： select d.* from dept d left join emp e on e.deptno = d.deptno where e.empno is NULL;右连接： select d.* from emp e right join dept d on e.deptno = d.deptno where e.empno is NULL; 1234567891011121314151617181920212223242526272829303132333435d表(主表)：+--------+------------+----------+| DEPTNO | DNAME | LOC |+--------+------------+----------+| 10 | ACCOUNTING | NEW YORK || 20 | RESEARCH | DALLAS || 30 | SALES | CHICAGO || 40 | OPERATIONS | BOSTON |+--------+------------+----------+e表(副表)：+--------+--------+| ename | deptno |+--------+--------+| SMITH | 20 || ALLEN | 30 || WARD | 30 || JONES | 20 || MARTIN | 30 || BLAKE | 30 || CLARK | 10 || SCOTT | 20 || KING | 10 || TURNER | 30 || ADAMS | 20 || JAMES | 30 || FORD | 20 || MILLER | 10 |+--------+--------+题解：+--------+------------+--------+| DEPTNO | DNAME | LOC |+--------+------------+--------+| 40 | OPERATIONS | BOSTON |+--------+------------+--------+ 三张表怎么连接查询12345678910... Ajoin Bon ...join Con ... 表示A先和B进行表连接，连接之后，A继续和C进行表连接。 题目：找出每一个员工的部门名称以及工资等级。 12345678910111213select e.ename, d.dname, s.gradefrom emp ejoin dept don e.deptno = d.deptnojoin salgrade son e.sal between s.losal and s.hisal; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758EMP e表：+-------+--------+---------+--------+| empno | ename | sal | deptno |+-------+--------+---------+--------+| 7369 | SMITH | 800.00 | 20 || 7499 | ALLEN | 1600.00 | 30 || 7521 | WARD | 1250.00 | 30 || 7566 | JONES | 2975.00 | 20 || 7654 | MARTIN | 1250.00 | 30 || 7698 | BLAKE | 2850.00 | 30 || 7782 | CLARK | 2450.00 | 10 || 7788 | SCOTT | 3000.00 | 20 || 7839 | KING | 5000.00 | 10 || 7844 | TURNER | 1500.00 | 30 || 7876 | ADAMS | 1100.00 | 20 || 7900 | JAMES | 950.00 | 30 || 7902 | FORD | 3000.00 | 20 || 7934 | MILLER | 1300.00 | 10 |+-------+--------+---------+--------+DEPT d表：+--------+------------+----------+| DEPTNO | DNAME | LOC |+--------+------------+----------+| 10 | ACCOUNTING | NEW YORK || 20 | RESEARCH | DALLAS || 30 | SALES | CHICAGO || 40 | OPERATIONS | BOSTON |+--------+------------+----------+SALGRADE s表：+-------+-------+-------+| GRADE | LOSAL | HISAL |+-------+-------+-------+| 1 | 700 | 1200 || 2 | 1201 | 1400 || 3 | 1401 | 2000 || 4 | 2001 | 3000 || 5 | 3001 | 9999 |+-------+-------+-------+题解：+--------+------------+-------+| ename | dname | grade |+--------+------------+-------+| SMITH | RESEARCH | 1 || ALLEN | SALES | 3 || WARD | SALES | 2 || JONES | RESEARCH | 4 || MARTIN | SALES | 2 || BLAKE | SALES | 4 || CLARK | ACCOUNTING | 4 || SCOTT | RESEARCH | 4 || KING | ACCOUNTING | 5 || TURNER | SALES | 3 || ADAMS | RESEARCH | 1 || JAMES | SALES | 1 || FORD | RESEARCH | 4 || MILLER | ACCOUNTING | 2 |+--------+------------+-------+ 题目：找出每一个员工的部门名称，工资等级以及上级领导。 12345678910111213141516select e.ename, d.dname, s.gradefrom emp ejoin dept don e.deptno = d.deptnojoin salgrade son e.sal between s.losal and s.hisalleft join emp eeon e.mgr = ee.empno; 12345678910111213141516171819题解：+--------+------------+-------+| ename | dname | grade |+--------+------------+-------+| SMITH | RESEARCH | 1 || ALLEN | SALES | 3 || WARD | SALES | 2 || JONES | RESEARCH | 4 || MARTIN | SALES | 2 || BLAKE | SALES | 4 || CLARK | ACCOUNTING | 4 || SCOTT | RESEARCH | 4 || KING | ACCOUNTING | 5 || TURNER | SALES | 3 || ADAMS | RESEARCH | 1 || JAMES | SALES | 1 || FORD | RESEARCH | 4 || MILLER | ACCOUNTING | 2 |+--------+------------+-------+ 子查询什么是子查询？ select语句中嵌套select语句，被嵌套的select语句是子查询。 子查询出现的位置？123456select ...(select语句)...from ...(select语句)...where ...(select语句)... where语句中使用子查询题目：找出高于平均薪资的员工信息。 123456select ename, salfrom empwhere sal &gt; (select avg(sal) from emp); 123456789101112+-------+---------+| ename | sal |+-------+---------+| JONES | 2975.00 || BLAKE | 2850.00 || CLARK | 2450.00 || SCOTT | 3000.00 || KING | 5000.00 || FORD | 3000.00 |+-------+---------+这里只查了名字和薪资，其他的没有查询。 from后面嵌套子查询题目：找出每个部门平均薪水的薪资等级。 1234567891011121314151617181920212223242526272829303132333435第一步：找出每个部门平均薪水 select deptno, avg(sal) as avgsal from emp group by deptno;+--------+-------------+| deptno | avgsal |+--------+-------------+| 20 | 2175.000000 || 30 | 1566.666667 || 10 | 2916.666667 |+--------+-------------+第二步：将第一步查询结果当做临时表t,让t表和SALGRADE s表连接，条件是t.avgsal between s.losal and s.hisal select t.*, s.grade from (select deptno, avg(sal) as avgsal from emp group by deptno) t join salgrade s on t.avgsal between s.losal and s.hisal;+--------+-------------+-------+| deptno | avgsal | grade |+--------+-------------+-------+| 20 | 2175.000000 | 4 || 30 | 1566.666667 | 3 || 10 | 2916.666667 | 4 |+--------+-------------+-------+ 题目：找出每个部门平均的薪水等级 123456789101112131415161718192021222324252627282930313233343536373839404142434445第一步：找出每个员工的薪水等级 select e.ename, e.sal, e.deptno, s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal;+--------+---------+--------+-------+| ename | sal | deptno | grade |+--------+---------+--------+-------+| SMITH | 800.00 | 20 | 1 || ALLEN | 1600.00 | 30 | 3 || WARD | 1250.00 | 30 | 2 || JONES | 2975.00 | 20 | 4 || MARTIN | 1250.00 | 30 | 2 || BLAKE | 2850.00 | 30 | 4 || CLARK | 2450.00 | 10 | 4 || SCOTT | 3000.00 | 20 | 4 || KING | 5000.00 | 10 | 5 || TURNER | 1500.00 | 30 | 3 || ADAMS | 1100.00 | 20 | 1 || JAMES | 950.00 | 30 | 1 || FORD | 3000.00 | 20 | 4 || MILLER | 1300.00 | 10 | 2 |+--------+---------+--------+-------+第二步：将第一步的结果继续按deptno分组，求grade的平均值 select e.deptno, avg(s.grade) from emp e join salgrade s on e.sal between s.losal and s.hisal group by e.deptno;+--------+--------------+| deptno | avg(s.grade) |+--------+--------------+| 20 | 2.8000 || 30 | 2.5000 || 10 | 3.6667 |+--------+--------------+ select后面嵌套子查询题目：找出每个员工所在的部门名称。要求显示员工名和部门名。 123456789select e.ename, (select d.dname from dept d where e.deptno = d.deptno) as dnamefrom emp e; 123456789101112131415161718+--------+------------+| ename | dname |+--------+------------+| SMITH | RESEARCH || ALLEN | SALES || WARD | SALES || JONES | RESEARCH || MARTIN | SALES || BLAKE | SALES || CLARK | ACCOUNTING || SCOTT | RESEARCH || KING | ACCOUNTING || TURNER | SALES || ADAMS | RESEARCH || JAMES | SALES || FORD | RESEARCH || MILLER | ACCOUNTING |+--------+------------+ union(将查询结果集相加) union：将两种不相干的表的数据拼接在一起显示。 题目：找出工作岗位是SALESMAN和MANAGER的员工。 1234567891011121314151617181920212223242526272829303132333435363738394041424344用or来写： select ename, job from emp where job = &#x27;SALESMAN&#x27; or job = &#x27;MANAGER&#x27;;用in来写： select ename, job from emp where job in(&#x27;SALESMAN&#x27;,&#x27;MANAGER&#x27;);用union来写： select ename, job from emp where job = &#x27;SALESMAN&#x27; union select ename, job from emp where job = &#x27;MANAGER&#x27;;+--------+----------+| ename | job |+--------+----------+| ALLEN | SALESMAN || WARD | SALESMAN || JONES | MANAGER || MARTIN | SALESMAN || BLAKE | MANAGER || CLARK | MANAGER || TURNER | SALESMAN |+--------+----------+ limit limit是MYSQL特有的，其他数据库没有。（Oracle中有一个相同的机制，叫做rownum） 作用：取结果的部分数据 limit是SQL语句最后执行的一个环节。 12345格式： limit startIndex, lengthstartIndex：起始位置（从0开始，0表示第一条数据）length：取几个 题目：取出工资前5名的员工。（思路：降序取前5个） 1234567891011121314151617181920212223242526272829方法一： select ename, sal from emp order by sal desc limit 0, 5;方法二： select ename, sal from emp order by sal desc limit 5; 如果前面不写则起始位置默认从0开始。+-------+---------+| ename | sal |+-------+---------+| KING | 5000.00 || SCOTT | 3000.00 || FORD | 3000.00 || JONES | 2975.00 || BLAKE | 2850.00 |+-------+---------+ 题目：找出工资排名在第4到第9的员工。 12345678910111213141516171819 select ename, sal from emp order by sal desc limit 3, 6;+--------+---------+| ename | sal |+--------+---------+| JONES | 2975.00 || BLAKE | 2850.00 || CLARK | 2450.00 || ALLEN | 1600.00 || TURNER | 1500.00 || MILLER | 1300.00 |+--------+---------+ 通用的标准分页SQL 每页显示pagesize条记录 第pageNo页：（pageNo - 1） * pagesize, pagesize pagesize:每页显示多少条记录pageNo:第几页 创建表123456格式： create table 表名( 字段名1 数据类型 字段名2 数据类型 ... ); 关于MYSQL当中字段的类型 数据类型 描述 int 整型，相当于Java中的int bigint 整型，相当于Java中的long float 相当于Java中的float、double char 定点字符串，相当于Java中的String varchar 可变字符串，相当于StringBuffer/StringBuilder date 日期类型，相当于Java中的java.sql.Date BLOB 二进制对象(Binary Large Object)，存储图片、视频等流媒体信息。相当于Java中的Object CLOB 字符大对象(Character Large Object)，存储较大文本，比如可以存储4G的字符串 char和varchar怎么选择？ char： 在实际的开发中，某个字段的数据长度不发生改变是定长的，如性别、生日等用char。 varchar： 根据实际的大小动态分配大小。当一个字段的数据长度不确定的时候用varchar，例如：简介、姓名等。 创建学生表 表名在数据库中一般建议以t或者tbl开始。 1234567891011创建学生表： 学生信息一般包括：学号、姓名、性别、班级编号、生日... create table t_student( no bigint, name varchar(255), sex char(1), classno varchar(255), birth char(10) ); 插入数据（insert语句)12格式： insert into 表名(字段1，字段2，...) values(值1，值2，...) 要求： 字段的数量和值的数量相同，并且数据类型要对应相同。 注意：当一个insert语句执行成功之后，表格当中必然会多一行记录。即使多的这行记录当中某些字段是NULL，后期也没有办法在执行insert语句插入数据了，只能使用update进行更新。 全部插入1234567insert into t_student(no,name,sex,classno,birth) values(1,&#39;张三&#39;,&#39;1&#39;,&#39;高三1班&#39;,&#39;2000-12-2&#39;);+------+------+------+---------+-----------+| no | name | sex | classno | birth |+------+------+------+---------+-----------+| 1 | 张三 | 1 | 高三1班 | 2000-12-2 |+------+------+------+---------+-----------+ 插入一部分12345678910insert into t_student(name) values(&#39;王五&#39;);+------+------+------+---------+-----------+| no | name | sex | classno | birth |+------+------+------+---------+-----------+| 1 | 张三 | 1 | 高三1班 | 2000-12-2 || NULL | 王五 | NULL | NULL | NULL |+------+------+------+---------+-----------+除name字段外，剩下的所有字段自动插入NULL。 字段省略1234567insert into t_student values(2,&#39;jack&#39;,&#39;0&#39;,&#39;高三2班&#39;,&#39;2001-2-3&#39;);+------+------+------+---------+----------+| no | name | sex | classno | birth |+------+------+------+---------+----------+| 2 | jack | 0 | 高三2班 | 2001-2-3 |+------+------+------+---------+----------+如果字段省略的话，表示全部都要插入，后面不能少写。 建表的时候加入默认值123456789101112131415161718 create table t_student( no bigint, name varchar(255), sex char(1) default 1, classno varchar(255), birth char(10) );sex默认为1此时同上面插入语句：insert into t_student(name) values(&#39;王五&#39;);会发现sex中有默认值为1+------+------+------+---------+-------+| no | name | sex | classno | birth |+------+------+------+---------+-------+| NULL | 王五 | 1 | NULL | NULL |+------+------+------+---------+-------+ 一次插入多行数据12345678910insert into t_student(no,name,sex,classno,birth) values(3,&#39;rose&#39;,&#39;1&#39;,&#39;高三2班&#39;,&#39;2001-3-4&#39;),(4,&#39;Mary&#39;,&#39;0&#39;,&#39;高三3班&#39;,&#39;2000-5-6&#39;);+------+------+------+----------+----------+| no | name | sex | classno | birth |+------+------+------+----------+----------+| NULL | 王五 | 1 | NULL | NULL || 2 | jack | 0 | 高三2班 | 2001-2-3 || 3 | rose | 1 | 高三2班 | 2001-3-4 || 4 | Mary | 0 | 高三3班 | 2000-5-6 |+------+------+------+----------+----------+ 删表123drop table if exists t_student;如果该表存在则删除。 表的复制1234格式： create table 表名 as select语句；将查询结果当做表创建处理。 123456789101112131415161718192021create table emp1 as select ename,empno from emp;mysql&gt; select * from emp1;+--------+-------+| ename | empno |+--------+-------+| SMITH | 7369 || ALLEN | 7499 || WARD | 7521 || JONES | 7566 || MARTIN | 7654 || BLAKE | 7698 || CLARK | 7782 || SCOTT | 7788 || KING | 7839 || TURNER | 7844 || ADAMS | 7876 || JAMES | 7900 || FORD | 7902 || MILLER | 7934 |+--------+-------+ 将查询结果插入到一张表中12345678910111213141516171819202122232425262728293031323334353637emp2表：+-------+-------+| ename | empno |+-------+-------+| Mary | 8888 || Jack | 9999 |+-------+-------+emp1表：+--------+-------+| ename | empno |+--------+-------+| SMITH | 7369 || ALLEN | 7499 || WARD | 7521 || JONES | 7566 || MARTIN | 7654 || BLAKE | 7698 || CLARK | 7782 || SCOTT | 7788 || KING | 7839 || TURNER | 7844 || ADAMS | 7876 || JAMES | 7900 || FORD | 7902 || MILLER | 7934 |+--------+-------+将emp1表中的SIMTH开头的人插入到emp2中：insert into emp2 select ename,empno from emp1 where ename &#x3D; &#39;SMITH&#39;;+-------+-------+| ename | empno |+-------+-------+| Mary | 8888 || Jack | 9999 || SMITH | 7369 |+-------+-------+ 修改数据12格式：update 表名 set 字段名1 &#x3D; 值,，字段名2 &#x3D; 值2,... where 条件; 注意：如果没有条件则全部更新。 题目：将emp2中的Mary的员工号改成8899。 123456789update emp2 set empno &#x3D; 8899 where empno &#x3D; 8888;+-------+-------+| ename | empno |+-------+-------+| Mary | 8899 || Jack | 9999 || SMITH | 7369 |+-------+-------+ 题目：将emp2中的员工号全部修改为1111。 1234567891011 update emp2 set empno &#x3D; 1111;+-------+-------+| ename | empno |+-------+-------+| Mary | 1111 || Jack | 1111 || SMITH | 1111 |+-------+-------+不加条件全部更新。 删除表中的数据12格式：delete from 表名 where 条件; 注意：没有条件则全部删除。 题目：删除emp2表中Jack的数据。 12345678delete from emp2 where ename &#x3D; &#39;Jack&#39;;+-------+-------+| ename | empno |+-------+-------+| Mary | 1111 || SMITH | 1111 |+-------+-------+ 题目：删除emp2中的全部数据。 1234delete from emp2;mysql&gt; select * from emp2;Empty set (0.00 sec) 怎么删除大表中的数据123truncate table 表名;表被截断，不可回滚，永久丢失。 删除表12drop table 表名; &#x2F;&#x2F;通用drop table if exists 表名; &#x2F;&#x2F;Oracle不支持这种写法。 表结构的修改 表结构的修改，使用工具完成即可。因为在实际开发中表一旦设计好之后，对表的结构的修改是很少的，修改表结构就是对之前的设计进行了否定，即使需要修改表结构，我们也可以直接使用工具操作。 修改表结构的语句不会出现在Java代码当中，出现在Java代码当中的SQL语句包括：insert、delete、update、select。（这些都是表中的数据操作。）增删改查有一个术语：CRUD操作（增create、检查retrieve、修改update、删除delete） 约束(Constraint)什么是约束？ 在创建表的时候，可以给表的字段添加相应的约束，添加约束的目的是为了保证表中的数据的合法性、有效性、完整性。 常见的约束 非空约束(not null)：约束的字段不能为NULL 唯一约束(unique)：约束的字段不能重复 主键约束(primary key)：约束的字段既不能为NULL，也不能重复，简称PK。 外键约束(foreign key)：简称FK。 检查约束(check)：Oracle数据库有check约束，但是MYSQL没有。目前MYSQL不支持该约束。 非空约束（not null） 非空约束只有列级，没有表级。 123456drop table if exists t_user;create table t_user( id int, username varchar(255) not null, &#x2F;&#x2F;不为空，必须插入数据。 password varchar(255)); 唯一性约束（unique） 唯一约束修饰的字段具有唯一性，不能重复，但可以为NULL。 12345678910111213给一个字段添加unique约束： drop table if exists t_user; create table t_user( id int, username varchar(255) unique &#x2F;&#x2F;列级约束 );此时在插入数据时如下： insert into t_user values(1, &#39;zs&#39;); insert into t_user values(2, &#39;zs&#39;); &#x2F;&#x2F;报错，因为username重复了。 insert into t_user values(2); insert into t_user values(3); &#x2F;&#x2F;username可以为空。 1234567891011121314151617181920212223242526给两个字段添加约束：此时代表着两个字段联合起来不能一样。 drop table if exists t_user; create table t_user( id int, usercode varchar(255), username varchar(255), unique(usercode, username) &#x2F;&#x2F;多个字段联合起来添加一个约束 &#x2F;&#x2F;表级约束 );此时插入数据如下： insert into t_user values(1, ‘001’, &#39;zs&#39;); insert into t_user values(2, ‘002’, &#39;ls&#39;); insert into t_user values(3, ‘001’, &#39;ls&#39;); &#x2F;&#x2F;可以插入 insert into t_user values(4, ‘003’, &#39;ls&#39;); &#x2F;&#x2F;也可以插入 insert into t_user values(5, ‘001’, &#39;zs&#39;); &#x2F;&#x2F;插入错误，此时联合起来一样，不能插入。如果是如下这么插入的话，和上面的“联合起来不一样”不同，这里表示每一个都不能一样。 drop table if exists t_user; create table t_user( id int, usercode varchar(255) unique, username varchar(255) unique ); 主键约束（primary key） 主键约束是列级约束 添加方法：primary key关键字 注意：一张表的主键约束只能有一个 1234567891011121314151617181920给一张表添加主键约束： drop table if exists t_user; create table t_user( id int primary key, &#x2F;&#x2F;列级约束 username varchar(255), email varchar(255) );插入数据如下： insert into t_user(id,username,email) values(1,&#39;zs&#39;,&#39;zs@163.com&#39;); insert into t_user(id,username,email) values(2,&#39;ls&#39;,&#39;ls@163.com&#39;); insert into t_user(id,username,email) values(3,&#39;ww&#39;,&#39;ww@163.com&#39;);错误的插入方法： &#x2F;&#x2F;此时出错，因为id是PK。 insert into t_user(id,username,email) values(1,&#39;Jk&#39;,&#39;Jk@163.com&#39;); &#x2F;&#x2F;此时出错，因为id没有初始值。 insert into t_user(username,email) values(&#39;Rose&#39;,&#39;Rose@163.com&#39;); 根据上面测试得出，id是主键（添加了主键约束）。主键字段中的数据不能为NULL，也不能重复。 主键的特点：不能为NULL，不能重复。 主键相关的术语： 主键约束：primary key 主键字段：id字段添加primary key后，id叫做主键字段 主键值：id字段中的每一值都是主键值 主键的作用： 表的三范式中有要求第一范式要求任何一张表都应该有主键。主键值是这行记录在这张表中的唯一标识（就像一个人的身份证号码）。 主键的分类根据主键字段数量来划分： 单一主键（推荐的，常用的） 复合主键（多个字段联合起来添加一个主键约束）。—不推荐用，因为复合主键违背了三范式。 根据主键性质来划分： 自然主键:主键值是一个和业务没有任何关系的自然数。（这种方式是推荐的） 业务主键：主键值和系统业务挂钩。例如：银行卡号码、身份证号做主键（不推荐使用） 最好不要拿着和业务挂钩的字段作为主键，因为以后的业务一旦发生改变的时候，主键值可能也需要随着发生变化，但有的时候没有办法变化，因为变化可能导致主键值重复。 1234567891011121314使用表级约束方式定义主键： drop table if exists t_user; create table t_user( id int, username varchar(255), primary key(id) );插入数据如下： insert into t_user(id,username) values(1,&#39;zs&#39;); insert into t_user(id,username) values(2,&#39;ls&#39;); insert into t_user(id,username) values(3,&#39;ww&#39;); insert into t_user(id,username) values(4,&#39;jack&#39;); insert into t_user(id,username) values(4,&#39;rose&#39;); &#x2F;&#x2F;此行错误 MYSQL提供主键值自增（！！！）12345678910111213141516171819202122232425auto_increment:id字段自动维护一个自增的数字，从1开始，默认自增。 drop table if exists t_user; create table t_user( id int primary key auto_increment, username varchar(255) ); insert into t_user(username) values (&#39;a&#39;); insert into t_user(username) values (&#39;b&#39;); insert into t_user(username) values (&#39;c&#39;); insert into t_user(username) values (&#39;d&#39;); insert into t_user(username) values (&#39;e&#39;); +----+----------+ | id | username | +----+----------+ | 1 | a | | 2 | b | | 3 | c | | 4 | d | | 5 | e | +----+----------+补充：Oracle中也提供了一个自增机制，叫做序列（sequence）对象。 外键约束外键约束的相关术语 外键约束：foreign key 外键字段：添加有外键约束的字段 外键值：外键字段中的每一个值 业务背景设计一个数据表库，用来维护学生和班级的信息。 使用一张表存储所有的数据缺点：冗余（不推荐） 使用两张表：班级表t_class和学生表t_student t_class表：|cno(PK)|cname||:–:|:–:||101|1班||102|2班| t_student表：|sno(PK)|sname|classno(FK)||:–:|:–:|:–:||1|zs|101||2|ls|102||3|ww|101||4|jack|101||5|rose|102| 建表语句 顺序要求：删除数据的时候，先删除子表，再删除父表。添加数据的时候，先添加父表，再添加子表。创建表的时候，先创建父表，再创建子表。删除表的时候，先删除子表，再删除父表。 1234567891011121314151617181920212223242526272829303132333435363738394041424344t_student中的classno字段引用t_class表中的cno字段，此时t_student表叫做子表，t_class表叫做父表。 drop table if exists t_student; drop table if exists t_class; create table t_class( cno int primary key, cname varchar(255) ); create table t_student( sno int primary key, sname varchar(255), classno int, foreign key(classno) references t_class(cno) ); insert into t_class values(101,&#39;高一一班&#39;); insert into t_class values(102,&#39;高一二班&#39;); insert into t_student values(1,&#39;zs&#39;,101); insert into t_student values(2,&#39;ls&#39;,102); insert into t_student values(3,&#39;ww&#39;,101); insert into t_student values(4,&#39;jack&#39;,101); insert into t_student values(5,&#39;rose&#39;,102); &#x2F;&#x2F;错误插入，因为t_class中的cno没有103这个数据，所以t_student中的classno不能插入103。 insert into t_student values(6,&#39;hh&#39;,&#39;103&#39;); mysql&gt; select * from t_class; +-----+----------+ | cno | cname | +-----+----------+ | 101 | 高一一班 | | 102 | 高一二班 | +-----+----------+ mysql&gt; select * from t_student; +-----+-------+---------+ |sno | sname | classno | +-----+-------+---------+ | 1 | zs | 101 | | 2 | ls | 102 | | 3 | ww | 101 | | 4 | jack | 101 | | 5 | rose | 102 | +-----+-------+---------+ 外键字段可以为NULL嘛？ 可以为NULL。 外键字段引用其他表中的某个字段的时候，被引用的字段必须是主键嘛？ 被引用的字段不一定是主键，但至少具有unique约束。 存储引擎（了解）123456完整的建表语句： create table &#96;t_x&#96;( &#96;id&#96; int ) ENGINE &#x3D; InnoDB DEFAULT CHARSET &#x3D; utf8;注意：在MYSQL中，凡是标识符是可以用飘号&#96;&#96;括起来。（最好别用，不通用） 建表的时候可以指定存储引擎，也可以指定字符集。 MYSQL默认使用的存储引擎是InnoDB方式。 默认采用的字符集是UTF8。 什么是存储引擎？ 存储引擎这个名字只有在MYSQL中存在。（Oracle中有对应的机制，但不叫存储引擎。Oracle中没有特殊的名字，就是“表的存储方式”。） MYSQL支持很多存储引擎，每一个存储引擎都对应了一种不同的存储方式，每一个存储引擎都有自己的优缺点，需要在合适的时机选择合适的存储引擎。 查看当前MYSQL支持的存储引擎？1show engines \\G; 常见的存储引擎？MYISAM存储引擎 不支持事务，是MYSQL最常用的存储引擎，但这种引擎不是默认的。 特征：用三个文件表示每个表 格式文件：存储表结构的定义(.frm) 数据文件：存储表行的内容(.MYD) 索引文件：存储表上索引(.MYI) 优点：可被压缩，节省存储空间。并且可以转化为只读表，提高检索效率。 缺点： 不支持事务。 InnoDB存储引擎 优点：支持事务，这种存储引擎数据的安全得到保障。 表的结构存储在.frm文件中。 数据存储在table space这样的表空间中(逻辑概念)，无法被压缩，无法转化成只读。 这种InnoDB引擎在MYSQL数据库崩溃之后提供自动恢复机制。 InnoDB支持级联删除和级联更新。 MEMORY存储引擎（以前叫HEAP存储引擎） 缺点：不支持事务。数据容易丢失，因为所有数据和索引都是存储在内存当中。 优点：查询速度快。 事务（Transaction）什么是事务？ 一个事务是一个完整的业务逻辑单元，不可再分。 比如：银行账户转账，从A账户向B账户转账10000，需要执行两条updata语句：updata t_act set balance = balance - 10000 where actno = ‘act-001’;updata t_act set balance = balance + 10000 where actno = ‘act-002’;以上两条DML语句必须同时成功，或者同时失败，不允许出现一条成功一条失败。 要想保证以上两条DML语句同时成功或同时失败，那么就需要使用数据库的“事务机制”。 假设所有的业务都能使用一条DML语句解决，那么就不需要事务机制，但实际情况不是这样，通常一个事需要多条DML语句共同联合完成。 与事务相关的语句 只有DML语句：insert、delete、update因为这三个语句都是和数据库当中的“数据”相关的。事务的存在是为了保证数据的完整性、安全性。 事务的四大特性：ACID A：原子性：事务是最小的工作单元，不可再分。 B：一致性：事务必须保证多条DML语句同时成功或者同时失败。 C：隔离性：事务A与事务B之间具有隔离。 D：持久性：持久性说的是最终数据必须持久化到硬盘文件中，事务才算成功的结束。 关于事务之间的隔离性 事务隔离性存在隔离级别，理论上隔离级别包括四个 第一级别：读未提交（read uncommitted）：对方事务还没有提交，当前事务可以读取到对方未提交的数据。读未提交存在脏读（Dirty Read）现象，表示读到了脏的数据。 第二级别：读已提交（read committed）：对方事务提交后的数据，我方可以读到。这个隔离级别解决了脏读现象。读已提交存在的问题是：不可重复读。 第三级别：可重复读（repeatable read）：这种隔离级别解决了不可重复读问题。不可重复读存在的问题是：读到的数据都是幻象（幻读）。 第四级别：序列化读/串行化读（serializable）：解决了所有问题。存在的问题：效率低、事务需要排队。 数据库的默认级别 Oracle数据库默认的隔离级别是：读已提交MYSQL数据库默认的隔离级别是：可重复读 关闭事务的自动提交 MYSQL事务默认情况下是自动提交的，只要执行任意一条DML语句则提交一次。 关闭方法：start transaction; 设置事务的隔离级别 set global transaction isolation level read uncommitted; 查看全局隔离级别 set @@global transaction_isolation; 索引什么是索引？有什么用？ 索引就相当于一本书的目录，通过目录可以快速的找到对应的资源。 在数据库方面，查询一张表的时候有两种检索方式：全表扫描、根据索引检索（效率很高） 添加索引是给某一个字段或者某些字段添加索引。 主键和具有unique约束的字段自动会添加索引。根据主键查询效率交稿，尽量根据主键索引。 索引为什么可以提高检索效率呢？ 索引虽然可以提高检索效率，但是不能随意的添加索引，因为索引也是数据库当中的对象，也需要数据库不断的维护，是有维护成本的。比如，表中的数据经常被修改这样不适合添加索引，因为数据一旦修改，索引需要重新排序，进行维护。 举例123 select ename,sal from emp where ename &#x3D; &#39;SMITH&#39;;当ename字段上没有添加索引的时候，以上SQL语句会进行全表扫描，扫描ename字段中所有的值。当ename字段上添加索引的时候，以上SQl语句会根据索引扫描，快速定位。 查看SQL语句的执行计划：加上explain…（MYSQL特有）123456 explain select ename,sal from emp where sal &#x3D; 5000; 从该语句中可以看出此时扫描了14次。给薪资sal字段添加索引： create index emp_sal_index on emp(sal);此时在通过explain语句查看发现只扫描了一次。 创建、删除索引对象？12345创建索引对象： create index 索引名称 on 表名(字段名);删除索引对象： drop index 索引名称 on 表名; 索引底层数据结构 索引底层采用的数据结构是：B+ Tree 通过B Tree缩小扫描范围，底层索引进行了排序、分区，索引会携带数据在表中的“物理地址”。最终通过索引检索到数据之后，获取到关联的物理结构，通过物理地址定位表中的数据，效率是最高的。 123 select ename from emp where ename &#x3D; &#39;SMITH&#39;;通过索引转化成： select ename from emp where 物理地址 &#x3D; XXX; 什么时候考虑给字段添加索引？ 数据量庞大。（根据客户的需求，根据线上的环境） 该字段很少的DML操作。（因为字段进行修改操作，索引需要维护） 该字段经常出现在where子句中。（经常根据哪个字段查询） 索引的分类？ 单一索引：给单个字段添加索引 复合索引：给多个字段联合起来添加1个索引 主键索引：主键上会自动添加索引 唯一索引：有unique约束的字段会自动添加索引 索引什么时候失效？12 select ename from emp where ename like &#39;%A%&#39;;模糊查询时，第一个通配符使用的是%，这时候索引是失效的。 视图（view）什么是视图？ 站在不同的角度去看待数据（同一张表的数据通过不同的角度去看待） 怎么创建、删除视图？ 注意：只要DQL语句才能以视图对象的方式创建出来。 对视图进行增删改查，会影响到原表数据。 可以对视图进行CRUD操作。 1234创建视图： create view myview as select empno,ename from emp;删除视图： drop view myview; 面向视图操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687mysql&gt; select * from emp_bak;+-------+--------+-----------+------+------------+---------+---------+--------+| EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | DEPTNO |+-------+--------+-----------+------+------------+---------+---------+--------+| 7369 | SMITH | CLERK | 7902 | 1980-12-17 | 800.00 | NULL | 20 || 7499 | ALLEN | SALESMAN | 7698 | 1981-02-20 | 1600.00 | 300.00 | 30 || 7521 | WARD | SALESMAN | 7698 | 1981-02-22 | 1250.00 | 500.00 | 30 || 7566 | JONES | MANAGER | 7839 | 1981-04-02 | 2975.00 | NULL | 20 || 7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 | 30 || 7698 | BLAKE | MANAGER | 7839 | 1981-05-01 | 2850.00 | NULL | 30 || 7782 | CLARK | MANAGER | 7839 | 1981-06-09 | 2450.00 | NULL | 10 || 7788 | SCOTT | ANALYST | 7566 | 1987-04-19 | 3000.00 | NULL | 20 || 7839 | KING | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL | 10 || 7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 | 0.00 | 30 || 7876 | ADAMS | CLERK | 7788 | 1987-05-23 | 1100.00 | NULL | 20 || 7900 | JAMES | CLERK | 7698 | 1981-12-03 | 950.00 | NULL | 30 || 7902 | FORD | ANALYST | 7566 | 1981-12-03 | 3000.00 | NULL | 20 || 7934 | MILLER | CLERK | 7782 | 1982-01-23 | 1300.00 | NULL | 10 |+-------+--------+-----------+------+------------+---------+---------+--------+create view myview as select empno,ename,sal from emp_bak;mysql&gt; select * from myview;+-------+--------+---------+| empno | ename | sal |+-------+--------+---------+| 7369 | SMITH | 800.00 || 7499 | ALLEN | 1600.00 || 7521 | WARD | 1250.00 || 7566 | JONES | 2975.00 || 7654 | MARTIN | 1250.00 || 7698 | BLAKE | 2850.00 || 7782 | CLARK | 2450.00 || 7788 | SCOTT | 3000.00 || 7839 | KING | 5000.00 || 7844 | TURNER | 1500.00 || 7876 | ADAMS | 1100.00 || 7900 | JAMES | 950.00 || 7902 | FORD | 3000.00 || 7934 | MILLER | 1300.00 |+-------+--------+---------+通过视图修改原表数据：update myview set ename &#x3D; &#39;hehe&#39;,sal &#x3D; 1 where empno &#x3D; 7369;mysql&gt; select * from myview;+-------+--------+---------+| empno | ename | sal |+-------+--------+---------+| 7369 | hehe | 1.00 || 7499 | ALLEN | 1600.00 || 7521 | WARD | 1250.00 || 7566 | JONES | 2975.00 || 7654 | MARTIN | 1250.00 || 7698 | BLAKE | 2850.00 || 7782 | CLARK | 2450.00 || 7788 | SCOTT | 3000.00 || 7839 | KING | 5000.00 || 7844 | TURNER | 1500.00 || 7876 | ADAMS | 1100.00 || 7900 | JAMES | 950.00 || 7902 | FORD | 3000.00 || 7934 | MILLER | 1300.00 |+-------+--------+---------+此时查询原表emp_bak发现数据变了。mysql&gt; select * from emp_bak;+-------+--------+-----------+------+------------+---------+---------+--------+| EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | DEPTNO |+-------+--------+-----------+------+------------+---------+---------+--------+| 7369 | hehe | CLERK | 7902 | 1980-12-17 | 1.00 | NULL | 20 || 7499 | ALLEN | SALESMAN | 7698 | 1981-02-20 | 1600.00 | 300.00 | 30 || 7521 | WARD | SALESMAN | 7698 | 1981-02-22 | 1250.00 | 500.00 | 30 || 7566 | JONES | MANAGER | 7839 | 1981-04-02 | 2975.00 | NULL | 20 || 7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 | 30 || 7698 | BLAKE | MANAGER | 7839 | 1981-05-01 | 2850.00 | NULL | 30 || 7782 | CLARK | MANAGER | 7839 | 1981-06-09 | 2450.00 | NULL | 10 || 7788 | SCOTT | ANALYST | 7566 | 1987-04-19 | 3000.00 | NULL | 20 || 7839 | KING | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL | 10 || 7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 | 0.00 | 30 || 7876 | ADAMS | CLERK | 7788 | 1987-05-23 | 1100.00 | NULL | 20 || 7900 | JAMES | CLERK | 7698 | 1981-12-03 | 950.00 | NULL | 30 || 7902 | FORD | ANALYST | 7566 | 1981-12-03 | 3000.00 | NULL | 20 || 7934 | MILLER | CLERK | 7782 | 1982-01-23 | 1300.00 | NULL | 10 |+-------+--------+-----------+------+------------+---------+---------+--------+通过视图删除原表数据：delete from myview where empno &#x3D; 7369;这里和上面一样，不在做演示。 视图的作用？ 视图可以隐藏表的实现细节。保密级别较高的系统，数据库只对外提供相关的视图，Java程序员只对视图对象进行CRUD。 DBA命令将数据库当中的数据导出（导出整个库） 在Windows的dos命令窗口执行mysqldump firstsql &gt; D:\\firstsql.sql -uroot -p123456; 导出指定数据库中的指定表 mysqldump firstsql emp &gt; D:\\firstsql.sql -uroot -p123456; 导入数据123create datebase 名字;use 名字;source D:\\firstsql.sql; 数据库设计三范式什么是三范式 设计表的依据。按照这个三范式设计的表不会出现数据元素。 三范式有哪些？ 第一范式：任何一张表都应该有主键，并且每一个字段原子性不可再分。 第二范式：建立在第一范式的基础上，所有非主键字段完全依赖主键，不能产生部分依赖。多对多：三张表，关系表两个外键 第三范式：建立在第二范式的基础之上，所有非主键字段直接依赖主键，不能产生传递依赖。一对多：两张表，多的表加外键 提示：在实际的开发中，以满足客户需求为主，有的时候会拿冗余换执行速度。 一对一怎么设计？ 一对一设计有两种方案：主键共享、外键唯一。","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"}]},{"title":"基数排序","date":"2021-03-31T14:23:41.000Z","path":"2021/03/31/基数排序/","text":"概念1待补充 代码如下主方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import java.util.Scanner;public class Demo &#123; public static void main(String[] args) &#123; int number = 0;//数组B的下标 int k = 1;//看第k位，从（倒数）第一位开始看 int Max = 0;//数组当中最大的数有几位 int count = 0; Scanner sc = new Scanner(System.in); System.out.print(&quot;请输入要排序的数的数量：&quot;); count = sc.nextInt(); int[] arrayA = new int[count]; int[] arrayB = new int[arrayA.length]; System.out.print(&quot;请输入&quot;+count+&quot;个数：&quot;); for(int i = 0;i &lt; count;i++)&#123; arrayA[i] = sc.nextInt(); &#125; //int[] arrayC = new int[arrayA.length]; //求最高位数 for(int i = 0; i &lt;arrayA.length;i++)&#123; int temp = getMax(arrayA[i]); if(temp &gt;= Max)&#123; Max = temp; &#125; &#125; //System.out.println(Max);//最高位数 //打印输出原始数组 System.out.print(&quot;原始素组为:&quot;); for (int i = 0; i &lt; arrayA.length; i++) &#123; System.out.print(arrayA[i]+&quot; &quot;); &#125; System.out.println(); //基数排序 while(k != Max+1)&#123; int p = 0;//判断循环是否结束 for(int i = 0;i &lt;=9 ;i++)&#123;//0~9是第几位的范围 for(int j = 0;j &lt;arrayA.length;j++)&#123; if(getNum(arrayA[j],k) == i)&#123; arrayB[number] = arrayA[j]; number++;//数组B的下标要单独定义，每次赋值后都需要移动到下一个下标 if(number == arrayA.length)&#123; break;//如果数组B已经满了，则提前结束循环 &#125; &#125; &#125; if(number == arrayA.length)&#123;//数组B存满后 number = 0;//重置数组B的下标 //System.out.println(&quot;k:&quot;+k); k++;//看的位数进行移动 /* //将原本的A数组给数组C for (i = 0; i &lt; arrayA.length; i++) &#123; arrayC[i] = arrayA[i]; &#125; */ //将新的数组B重新赋值给arrayA for (i = 0; i &lt; arrayA.length; i++) &#123; arrayA[i] = arrayB[i]; &#125; //打印输出 System.out.print(&quot;第&quot;+(k-1)+&quot;轮输出：&quot;);//因为前面提前k++了，所以应该是k-1轮。 for (i = 0; i &lt; arrayA.length; i++) &#123; System.out.print(arrayA[i]+&quot; &quot;); &#125; System.out.println(); break;//数组B满了后这个循环也要提前结束 &#125; &#125; //错误，不能这么判断，否则若在还没排完前一样的时候会提前结束 //判断数组B、C是否一样，如果一样，则提前结束循环 / *for(int i = 0;i &lt;arrayA.length;i++)&#123; if(arrayA[i] == arrayC[i])&#123; p++;//1+1+1+1=arrayA.length &#125; &#125; if(p == arrayA.length)&#123; break; &#125; */ &#125; &#125; 方法1：给定一个数num，返回该数的倒数第k个数，例如 num = 231, k = 2,则返回 3123456789101112public static int getNum(int num, int k) &#123; int count = 0; while(k != 0) &#123; count = num % 10; num = num / 10; /* if(num == 0)&#123; break; &#125;*/ k--; &#125; return count;&#125; 方法2：得到一个数有几位123456789 public static int getMax(int array)&#123; int count = 0;//计数器 while (array != 0)&#123; array = array/10; count++; &#125; return count; &#125;&#125; 总结121、基数排序的原理比较简单，但是代码实现起来比较复杂。2、","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"Java学习记录","date":"2021-03-24T06:45:00.000Z","path":"2021/03/24/Java学习记录/","text":"算法设计与分析实验一第一题题目12345678910给定一个正整数，编写程序计算有多少对质数的和等于输入的这个正整数，并输出结果。输入值小于1000。如，输入为10, 程序应该输出结果为2。（共有两对质数的和为10，分别为(5, 5) , (3, 7)）。输入输入一个整数n( 3≤n&lt;1000)。输出输出对数。样例输入10样例输出2 举例说明123410 【3,7】、【5,5】 212 【1,11】、【5,7】 215 【2,13】 120 【1,19】、【3,17】、【7,13】 3 分析12341、写一个方法来判断一个数是不是素数2、从头开始遍历，判断每一个数是否满足条件 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package study01;import java.util.Scanner;public class demo01 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int num = sc.nextInt(); //键盘获取输入的num值 int count = 0; //定义一个count，用来记录最后有几个质数对 int a = 1;//定义两个数，它们的和为num int b = num - a; //循环从1开始到中间那个数，排除了 例如num=10，有【3,7】，【7,3】这样的重复 while( a!= (num/2 + 1) ) &#123; if (sushu ( a ) &amp;&amp; sushu ( b )) &#123; count ++; //如果a,b都是素数，则计数器加一 System.out.println(&quot;[&quot;+a+&quot;,&quot;+b+&quot;] &quot;); &#125; a++; //循环一次后a++,b--，进行下次循环,满足条件后跳出循环 b--; //System.out.println(a+&quot; &quot;+b); &#125; System.out.println(count); //输出结果 &#125; //素数：除了1和它本身外不能被其他数整除的数叫做素数。 //判断的方法是从2到num-1，遍历看能不能被整除，如果能被其中的一个整除，则不是素数，如果都不可以整除，那么就不是素数。 //用来判断一个数是否为素数，如果是素数则返回true，如果不是素数则返回false public static boolean sushu(int num) &#123; if (num == 2 ||num == 1) &#123; //如果num刚好为2，则判定直接为素数 return true; &#125; else &#123; for (int i = 2; i &lt; num; i++) &#123; if (num % i == 0) &#123; return false; &#125;else&#123; //这里特别注意一定要讲循环走完一圈才可以出去，否则判断一次后循环就会结束。 if(i==num-1)&#123; return true; //判定i==num-1时才是循环了一圈，所以结束循环 &#125;else continue; //否则跳过此次循环进行下一次循环 &#125; &#125; return false; &#125; &#125;&#125; 总结以及心得1231、循环判断数的时候，为了避免【7，3】、【3,7】这种相同的情况，因此只需要判断到一半的位置即可。2、判断一个数是否为素数的时候，只遍历除了1和这个数本身之外的其他数，能否被自己整除即可。如果可以被整除，那么就不是素数。如果不可以被整除，那么就是素数。注意2是一个特殊情况，需要单独考虑。 第二题题目1234567891011121314151617181920小明想给老师当助教从而得一些补助。老师会给小明一些作业让他去批改，并按批改的作业份数和批改正确率来确定小明的补助费。老师是这么规定的，批改一份作业小明会得到m元，如果该份作业批改完全正确那么会从中扣除k元复查费；如果批改中出现了错误会从中扣除x元当惩罚费用，此时这份作业不再扣除复查费。但是老师觉得小明勤工助学不容易，不想扣过多的费用，于是规定如果有一份作业批改错误扣了x元，那么可以抵消一份批改正确作业的复查费。举例，如果有两份作业，一份批改正确一份批改错误，那么错误的那份小明可以得到m-x元，正确的那份小明可以得到m元，不用扣复查费。最后，你能算出小明一共能得多少补助么?输入第一行四个整数n、m、x、k，n表示小明批改作业的总份数，m、x、k的含义如题面描述，1≤n≤100000，1≤m, x, k≤100，x, k≤m;第二行n个整数，每个整数只有两种可能，0表示该份作业批改错误，1表示该份作业批改正确。输出输出一个整数，表示小明最后一共得到的补助费。样例输入总份数n 批改正确得到的钱 m 惩罚费用x 复查费k4 5 2 11 1 1 0（三正确 一错误） 1 1 1 1 0 0 10-2+20-4样例输出16 24 举例说明121 1 1 1 0 0 24 分析12341、通过Scanner函数来进行数字的输入2、知道题目结果如何计算3、考虑错误题目大于正确题目的特殊情况 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344package study02;import java.util.Scanner;public class demo01 &#123; public static void main(String[] args) &#123; int n, m, x, k; int r = 0;//改正确的题目 int f = 0;//改错误的题目 //总份数n 批改正确得到的钱 m 惩罚费用x 复查费k System.out.print(&quot;请依次输入 总份数n 批改正确得到的钱 m 惩罚费用x 复查费k：&quot;); Scanner sc = new Scanner(System.in);//键盘输入n,m,x,k n = sc.nextInt(); m = sc.nextInt(); x = sc.nextInt(); k = sc.nextInt(); System.out.print(&quot;请输入作业更改情况（正确为1，错误为0,最多输入&quot;+n+&quot;个数）：&quot;); int array[] = new int[n];//定义一个数组，用来记录题目的错误，并统计正确与错误赋值给r,f for(int i = 0; i &lt; n; i++)&#123; array[i] = sc.nextInt(); //System.out.print(array[i]+&quot;\\t&quot;);//输出数组 if(array[i]==1)&#123; r++; &#125;else if(array[i]==0)&#123; f++; &#125;else&#123; System.out.println(&quot;输入错误！&quot;); break; &#125; &#125; //System.out.println(&quot;r=&quot;+r); //System.out.println(&quot;f=&quot;+f); int sum = 0;//总价格 if(r&gt;=f)&#123; //正确题数大于错误题数 sum = n*m - f*x - (r-f)*k; &#125;else&#123; //错误题数大于正确题数，此时（r-f)为负，不能用上面的计算方式，此时不需要考虑复查情况。 sum=n*m - f*x; &#125; System.out.println(&quot;小明得到的钱为&quot; + sum);//输出结果 &#125;&#125; 总结以及心得12341、此题并不难，只需要知道题目的计算方式即可2、通过这题要学会Scanner函数的使用方法，该函数可以通过多次获取做到多次输入给多个数据赋值 注意：如果定义的只有n个数据，那么输入超过n个数的时候，只会获取前n个数据并进行赋值。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]}]