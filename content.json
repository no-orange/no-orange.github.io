[{"title":"MySQL知识总结","date":"2021-04-03T07:32:22.000Z","path":"2021/04/03/MySQL知识总结/","text":"什么是数据库？SQL、DB、DBMS分别是什么？123SQL：结构化查询语句，是一门标准通用的语言。 DB：DataBase，数据库，实际上在硬盘上以文件的形式存在。DBMS：DataBase Management System，数据库管理系统。 标准的SQL适用于所有的数据库产品。SQL属于高级语言。 SQL执行的过程12345SQL语句在执行的时候，先编译（编译由DBMS完成）后执行。DBMS负责执行sql语句，通过执行sql语句来操作DB当中的数据。DBMS -&gt; (执行) -&gt; SQL -&gt; (操作) -&gt;DB 表(table)什么是表？1表：table是数据库的基本组成单元，所有的数据都以表格的形式组织，目的是可续性强。 表的组成123表由行和列组成：行：称为数据/记录(data)列：称为字段(column) SQL语句分类 DQL(数据查询语言)：查询语句，凡是select语句都是SQL。DML(数据操作语言)：insert、delete、update，对表中的数据进行增删改DDL(数据定义语言)：create、drop、alter，对表结构的增删改TCL(事务(Transaction)控制语言)：commit提交事务，rollback回滚事务。DCL(数据控制语言)：grant授权，revoke撤销权限等。 MySQL的登录及简答查询登录MySQl dos命令：mysql -uroot -p密码 查看有哪些数据 show databases;注意：这不是SQL语句，而是MySQL命令 。 创建属于我们自己的数据库 create database 名字;我们这里创建firstsql,即 create database firstsql; 使用创建的数据库 use 数据库名字；注意：这也是MySQL命令。 查看当前使用的数据库中有哪些表 show tables;注意：这也是MySQL命令。 初始化数据 输入source，然后将数据表拖进来。注意：数据初始化完成之后，有三张表：dept、emp、salgrade。 1234567+--------------------+| Tables_in_firstsql |+--------------------+| dept || emp || salgrade |+--------------------+ 1234注意事项：1、SQL语言的文件被称为“SQL脚本”。2、当一个文件的扩展名是.sql，并且该文件中编写了大量的SQL语句，我们称这样的文件为SQL脚本。3、source可以执行SQL脚本，当SQL脚本中的数据太大的时候，无法直接打开，我们就可以使用source命令完成初始化。 删除数据库 drop database firstsql; 查看表结构 desc dept;desc emp;desc salgrade; 123456789101112131415161718192021222324252627282930313233343536373839404142434445mysql&gt; desc dept;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| DEPTNO | int | NO | PRI | NULL | || DNAME | varchar(14) | YES | | NULL | || LOC | varchar(13) | YES | | NULL | |+--------+-------------+------+-----+---------+-------+DEPTNO:部门编号DNAME:部门名称LOC:部门位置mysql&gt; desc emp;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| EMPNO | int | NO | PRI | NULL | || ENAME | varchar(10) | YES | | NULL | || JOB | varchar(9) | YES | | NULL | || MGR | int | YES | | NULL | || HIREDATE | date | YES | | NULL | || SAL | double(7,2) | YES | | NULL | || COMM | double(7,2) | YES | | NULL | || DEPTNO | int | YES | | NULL | |+----------+-------------+------+-----+---------+-------+EMPNO: 员工编号ENAME:员工姓名JOB:工作岗位 MGR:上级领导编号HIREDATE:入职日期SAL:月薪 COMM:补助/津贴 DEPTNO:部门编号 mysql&gt; desc salgrade;+-------+------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+------+------+-----+---------+-------+| GRADE | int | YES | | NULL | || LOSAL | int | YES | | NULL | || HISAL | int | YES | | NULL | |+-------+------+------+-----+---------+-------+GRADE:等级LOSAL:最低薪资HISAL:最高薪资 查看表中所有的数据 select * form 表名;注意在实际开发(写入Java程序时)当中不建议使用 *，因为效率比较低。 12345678910mysql&gt; select * from dept;+--------+------------+----------+| DEPTNO | DNAME | LOC |+--------+------------+----------+| 10 | ACCOUNTING | NEW YORK || 20 | RESEARCH | DALLAS || 30 | SALES | CHICAGO || 40 | OPERATIONS | BOSTON |+--------+------------+----------+这里我们只举一个dept表的例子，可以查看dept表当中的全部数据。 常用的MySQL命令查看当前使用的是哪一个数据库 select database(); 123456mysql&gt; select database();+------------+| database() |+------------+| firstsql |+------------+ 查看MySQL的版本 select version(); 123456mysql&gt; select version();+-----------+| version() |+-----------+| 8.0.23 |+-----------+ 结束一条语句 \\c 12345mysql&gt; select -&gt; * -&gt; \\cmysql&gt;输入\\c后直接结束这一条语句 退出MySQL exit 12mysql&gt; exitBye 查看建表的语句 show create table emp; 简单的查询语句(DQL)语法格式1234select 字段名1，字段名2，...from 表名; 123注意事项：1、任何一条SQL语句都以“ ; ”结尾。2、SQL语句不区分大小写。 字段可以参与数学运算题目:请输出员工的年薪 select ename, sal * 12 from emp; 123456789101112131415161718+--------+----------+| ename | sal*12 |+--------+----------+| SMITH | 9600.00 || ALLEN | 19200.00 || WARD | 15000.00 || JONES | 35700.00 || MARTIN | 15000.00 || BLAKE | 34200.00 || CLARK | 29400.00 || SCOTT | 36000.00 || KING | 60000.00 || TURNER | 18000.00 || ADAMS | 13200.00 || JAMES | 11400.00 || FORD | 36000.00 || MILLER | 15600.00 |+--------+----------+ 给查询结果的列(sal*12)重命名 select ename, sal * 12 as yearsal from, emp;将sal*12重命名为yearsalas关键字也可以省略不写select ename, sal * 12 yearsal from, emp; 1234567891011121314151617181920212223242526272829303132333435363738394041写as:mysql&gt; select ename,sal*12 as yearsal from emp;+--------+----------+| ename | yearsal |+--------+----------+| SMITH | 9600.00 || ALLEN | 19200.00 || WARD | 15000.00 || JONES | 35700.00 || MARTIN | 15000.00 || BLAKE | 34200.00 || CLARK | 29400.00 || SCOTT | 36000.00 || KING | 60000.00 || TURNER | 18000.00 || ADAMS | 13200.00 || JAMES | 11400.00 || FORD | 36000.00 || MILLER | 15600.00 |+--------+----------+不写as:mysql&gt; select ename,sal*12 yearsal from emp;+--------+----------+| ename | yearsal |+--------+----------+| SMITH | 9600.00 || ALLEN | 19200.00 || WARD | 15000.00 || JONES | 35700.00 || MARTIN | 15000.00 || BLAKE | 34200.00 || CLARK | 29400.00 || SCOTT | 36000.00 || KING | 60000.00 || TURNER | 18000.00 || ADAMS | 13200.00 || JAMES | 11400.00 || FORD | 36000.00 || MILLER | 15600.00 |+--------+----------+ 当别名当中有中文的时候，要注意： 正确写法：select ename, sal * 12 as ‘年薪’ from emp;错误写法：select ename, sal * 12 as 年薪 from emp; 123456789101112131415161718+--------+----------+| ename | 年薪 |+--------+----------+| SMITH | 9600.00 || ALLEN | 19200.00 || WARD | 15000.00 || JONES | 35700.00 || MARTIN | 15000.00 || BLAKE | 34200.00 || CLARK | 29400.00 || SCOTT | 36000.00 || KING | 60000.00 || TURNER | 18000.00 || ADAMS | 13200.00 || JAMES | 11400.00 || FORD | 36000.00 || MILLER | 15600.00 |+--------+----------+ 条件查询语法格式12345678 select 字段1，字段2，... from 表名 where 条件;执行顺序：from --&gt; where --&gt; select 题目：查询工资等于5000的员工姓名 select ename, sal from emp where sal = 5000; 12345+-------+---------+| ename | sal |+-------+---------+| KING | 5000.00 |+-------+---------+ 题目：查询SMITH的工资 select ename, sal from emp where ename = ‘SMITH’;注意：字符串要用’ ‘括起来 12345+-------+--------+| ename | sal |+-------+--------+| SMITH | 800.00 |+-------+--------+ 题目：查询工资不为3000的员工 select ename, sal from emp where sal &lt;&gt; 3000;select ename, sal from emp where sal != 3000;注意：不等于有两种表达形式：&lt;&gt; 和 != 12345678910111213141516171819202122232425262728293031323334353637全部员工的工资：+--------+---------+| ename | sal |+--------+---------+| SMITH | 800.00 || ALLEN | 1600.00 || WARD | 1250.00 || JONES | 2975.00 || MARTIN | 1250.00 || BLAKE | 2850.00 || CLARK | 2450.00 || SCOTT | 3000.00 || KING | 5000.00 || TURNER | 1500.00 || ADAMS | 1100.00 || JAMES | 950.00 || FORD | 3000.00 || MILLER | 1300.00 |+--------+---------+工资不等于3000的员工：+--------+---------+| ename | sal |+--------+---------+| SMITH | 800.00 || ALLEN | 1600.00 || WARD | 1250.00 || JONES | 2975.00 || MARTIN | 1250.00 || BLAKE | 2850.00 || CLARK | 2450.00 || KING | 5000.00 || TURNER | 1500.00 || ADAMS | 1100.00 || JAMES | 950.00 || MILLER | 1300.00 |+--------+---------+ between…and…题目：求工资在1500到3000之间的员工 select ename,sal from emp where sal between 1500 and 3000;注意：between…and…是从左到右执行的，因此不能写between 3000 and 1500,此时无数据。 123456789101112+--------+---------+| ename | sal |+--------+---------+| ALLEN | 1600.00 || JONES | 2975.00 || BLAKE | 2850.00 || CLARK | 2450.00 || SCOTT | 3000.00 || TURNER | 1500.00 || FORD | 3000.00 |+--------+---------+可以看出，当between...and...中是数字的时候，范围是左闭右闭的。 题目：求出姓名在A和C之间的员工 select ename from emp where ename between ‘A’ and ‘C’; 1234567891011121314151617181920212223242526272829姓名在A和C之间的员工:+-------+| ename |+-------+| ALLEN || BLAKE || ADAMS |+-------+所有员工：+--------+| ename |+--------+| ADAMS || ALLEN || BLAKE || CLARK || FORD || JAMES || JONES || KING || MARTIN || MILLER || SCOTT || SMITH || TURNER || WARD |+--------+不难看出，between...and...用于字符串的排序的时候，是左臂闭右开的。 is NULL题目：找出哪些人有津贴，哪些人没有津贴。 select ename,comm from emp where comm is NULL;select ename,comm from emp where comm is not NULL;错误写法：select ename,comm from emp where comm = NULL;select ename,comm from emp where comm != NULL;注意事项：在数据库中NULL不是一个值，而是代表什么也没有，为空。空不是一个值，所以不能用等号衡量 12345678910111213141516171819202122232425262728293031323334353637383940414243无津贴的：+--------+------+| ename | comm |+--------+------+| SMITH | NULL || JONES | NULL || BLAKE | NULL || CLARK | NULL || SCOTT | NULL || KING | NULL || ADAMS | NULL || JAMES | NULL || FORD | NULL || MILLER | NULL |+--------+------+有津贴的：+--------+---------+| ename | comm |+--------+---------+| ALLEN | 300.00 || WARD | 500.00 || MARTIN | 1400.00 || TURNER | 0.00 |+--------+---------+全部的：+--------+---------+| ename | comm |+--------+---------+| SMITH | NULL || ALLEN | 300.00 || WARD | 500.00 || JONES | NULL || MARTIN | 1400.00 || BLAKE | NULL || CLARK | NULL || SCOTT | NULL || KING | NULL || TURNER | 0.00 || ADAMS | NULL || JAMES | NULL || FORD | NULL || MILLER | NULL |+--------+---------+ and 与 or题目：找出工作岗位是MANAGER和SALESMAN的员工 select ename,job from emp where job = ‘MANAGER’ or job = ‘SALESMAN’; 1234567891011+--------+----------+| ename | job |+--------+----------+| ALLEN | SALESMAN || WARD | SALESMAN || JONES | MANAGER || MARTIN | SALESMAN || BLAKE | MANAGER || CLARK | MANAGER || TURNER | SALESMAN |+--------+----------+ 题目：找出薪资大于1000并且部门编号是20或者30的员工 select ename,sal,deptno from emp where sal &gt; 1000 and (deptno = 20 or deptno = 30);注意事项：and 的优先级要比 or 高，所以本题当中的()不可以省略，如果省略则错误。 12345678910111213+--------+---------+--------+| ename | sal | deptno |+--------+---------+--------+| ALLEN | 1600.00 | 30 || WARD | 1250.00 | 30 || JONES | 2975.00 | 20 || MARTIN | 1250.00 | 30 || BLAKE | 2850.00 | 30 || SCOTT | 3000.00 | 20 || TURNER | 1500.00 | 30 || ADAMS | 1100.00 | 20 || FORD | 3000.00 | 20 |+--------+---------+--------+ in 与 not in题目：找出工作岗位是找出工作岗位是MANAGER和SALESMAN的员工 select ename,job from emp where job = ‘MANAGER’ or job = ‘SALESMAN’;这是用 or 来写select ename,job from emp where job in(‘MANAGER’,’SALESMAN’);这里用 in 来写不难看出，in 和 or 的功能是一样的，只是写法上面有所不同。 1234567891011121314151617181920212223242526mysql&gt; mysql&gt; select ename,job from emp where job = &#x27;MANAGER&#x27; or job = &#x27;SALESMAN&#x27;;+--------+----------+| ename | job |+--------+----------+| ALLEN | SALESMAN || WARD | SALESMAN || JONES | MANAGER || MARTIN | SALESMAN || BLAKE | MANAGER || CLARK | MANAGER || TURNER | SALESMAN |+--------+----------+mysql&gt; select ename,job from emp where job in(&#x27;MANAGER&#x27;,&#x27;SALESMAN&#x27;);+--------+----------+| ename | job |+--------+----------+| ALLEN | SALESMAN || WARD | SALESMAN || JONES | MANAGER || MARTIN | SALESMAN || BLAKE | MANAGER || CLARK | MANAGER || TURNER | SALESMAN |+--------+----------+ 题目：找出工作岗位不是MANAGER和SALESMAN的员工 select ename,job from emp where job not in(‘MANAGER’,’SALESMAN’); 1234567891011+--------+-----------+| ename | job |+--------+-----------+| SMITH | CLERK || SCOTT | ANALYST || KING | PRESIDENT || ADAMS | CLERK || JAMES | CLERK || FORD | ANALYST || MILLER | CLERK |+--------+-----------+ 模糊查询like题目：找出名字中含有O的员工 select ename from emp where ename like ‘%O%’; 1234567+-------+| ename |+-------+| JONES || SCOTT || FORD |+-------+ 题目：找出名字第二字母是A的员工 select ename from emp where ename like ‘_A%’; 1234567+--------+| ename |+--------+| WARD || MARTIN || JAMES |+--------+ 题目：找出名字中有下划线_的 select ename from emp where ename like ‘%_%’; 1本数据库当中无带有下划线的名字，本题不是只是一个例子，所以这里不展示结果。 总结掌握两个特殊的符号：% 和 _% 代表任意多个字符，_ 代表任意一个字符当我们刚好需要寻找 % 和 _ 的时候，可以用转义字符 \\% \\_来表示。 数据排序格式1234567891011121314151617181920升序(默认升序，不写asc也是升序)：select 字段1，字段2，...from 表名where 条件order by 字段1，字段2，...asc;降序：select 字段1，字段2，...from 表名where 条件order by 字段1，字段2，...desc; 题目：按照工资升序找出员工名和薪资 select ename,sal from emp order by sal;select ename,sal from emp order by sal asc;默认排序就是升序，因此 asc 不写也可以。 123456789101112131415161718+--------+---------+| ename | sal |+--------+---------+| SMITH | 800.00 || JAMES | 950.00 || ADAMS | 1100.00 || WARD | 1250.00 || MARTIN | 1250.00 || MILLER | 1300.00 || TURNER | 1500.00 || ALLEN | 1600.00 || CLARK | 2450.00 || BLAKE | 2850.00 || JONES | 2975.00 || SCOTT | 3000.00 || FORD | 3000.00 || KING | 5000.00 |+--------+---------+ 题目：按照工资降序找出员工名和薪资 select ename,sal from emp order by sal desc; 123456789101112131415161718+--------+---------+| ename | sal |+--------+---------+| KING | 5000.00 || SCOTT | 3000.00 || FORD | 3000.00 || JONES | 2975.00 || BLAKE | 2850.00 || CLARK | 2450.00 || ALLEN | 1600.00 || TURNER | 1500.00 || MILLER | 1300.00 || WARD | 1250.00 || MARTIN | 1250.00 || ADAMS | 1100.00 || JAMES | 950.00 || SMITH | 800.00 |+--------+---------+ 题目：按照工资的降序排列，工资相同是按名字的升序排序 select ename,sal from emp order by sal desc,ename asc; 123456789101112131415161718+--------+---------+| ename | sal |+--------+---------+| KING | 5000.00 || FORD | 3000.00 || SCOTT | 3000.00 || JONES | 2975.00 || BLAKE | 2850.00 || CLARK | 2450.00 || ALLEN | 1600.00 || TURNER | 1500.00 || MILLER | 1300.00 || MARTIN | 1250.00 || WARD | 1250.00 || ADAMS | 1100.00 || JAMES | 950.00 || SMITH | 800.00 |+--------+---------+ 注意事项：有多个字段同时排序的时候，按前后顺序执行，前面出现一样的情况时，才会执行后面的。越靠前的字段越能起到主导作用，只有当前面的字段无法完成排序的时候，才会用后面的字段。 补充：排序也可以这么写 >select ename,sal from emp order by 2; 此时的含义是ename是第一个，sal是第二个，此时按第二个sal进行排序。 这种方法的健壮性很差，一般不推荐使用。 题目：找出工作岗位是SALESMAN的员工，并且按照薪资降序排列。 select ename,job,sal from emp where job = ‘SALESMAN’ order by sal desc; 12345678+--------+----------+---------+| ename | job | sal |+--------+----------+---------+| ALLEN | SALESMAN | 1600.00 || TURNER | SALESMAN | 1500.00 || WARD | SALESMAN | 1250.00 || MARTIN | SALESMAN | 1250.00 |+--------+----------+---------+ 分组函数 分组函数一共有五个：count：计数sum：求和avg：平均值max：最大值min：最小值 多行处理函数与单行处理函数 分组函数又叫多行处理函数，特点是：输入多行，但最终输出的结果为一行。所有的分组函数都是对“某一组”数据进行操作的。单行处理函数：输入一行，输出一行。 题目：找出员工工资总和 >select sum(sal) from emp; 12345+----------+| sum(sal) |+----------+| 29025.00 |+----------+ 题目：找出最高工资 select max(sal) from emp; 12345+----------+| max(sal) |+----------+| 5000.00 |+----------+ 题目：找出总人数 select count(*) from emp;select count(ename) from emp; 12345678910111213select count(*) from emp; +----------+| count(*) |+----------+| 14 |+----------+select count(ename) from emp;+--------------+| count(ename) |+--------------+| 14 |+--------------+ 题目：同时求出总人数，工资总数、平均数、最大值、最小值 select count(*),sum(sal),avg(sal),max(sal),min(sal) from emp; 12345+----------+----------+-------------+----------+----------+| count(*) | sum(sal) | avg(sal) | max(sal) | min(sal) |+----------+----------+-------------+----------+----------+| 14 | 29025.00 | 2073.214286 | 5000.00 | 800.00 |+----------+----------+-------------+----------+----------+ ifnull()空处理函数 所有数据库只要表达式运算有NULL，那么最后的运算结果都为NULL。我们为了解决这个问题，提出了ifnull方法。 1234 格式 ifnull（可能为NULL的数据，被当做什么来处理）例如：ifnull（comm，0）意思就是如果comm中有NULL的话，我们把它当做0来处理 题目：计算每个员工的年薪(加上津贴) select ename,(sal+ifnull(comm,0))*12 as yearsal from emp;这个时候如果comm当做有NULL的话，就当做0来运算。 123456789101112131415161718192021222324252627282930313233343536373839所有员工的津贴如下：+--------+---------+| ename | comm |+--------+---------+| SMITH | NULL || ALLEN | 300.00 || WARD | 500.00 || JONES | NULL || MARTIN | 1400.00 || BLAKE | NULL || CLARK | NULL || SCOTT | NULL || KING | NULL || TURNER | 0.00 || ADAMS | NULL || JAMES | NULL || FORD | NULL || MILLER | NULL |+--------+---------+每个员工的年薪(加上津贴)+--------+----------+| ename | yearsal |+--------+----------+| SMITH | 9600.00 || ALLEN | 22800.00 || WARD | 21000.00 || JONES | 35700.00 || MARTIN | 31800.00 || BLAKE | 34200.00 || CLARK | 29400.00 || SCOTT | 36000.00 || KING | 60000.00 || TURNER | 18000.00 || ADAMS | 13200.00 || JAMES | 11400.00 || FORD | 36000.00 || MILLER | 15600.00 |+--------+----------+ 分组函数会自动忽略到NULL 题目：计算所有员工津贴的总和 select sum(comm) from emp;这里分组函数自动将comm中的NULL忽略掉了。 12345+-----------+| sum(comm) |+-----------+| 2200.00 |+-----------+ 分组函数的执行顺序(这一块需要结合后面的group by理解) 分组函数必须在分完组后才能执行。如果SQL语句中没有group by 语句的话，整个表的数据自成为一组。而group by 语句必须在 where 后面执行，所以分组函数不可以使用在where 子句当中。 题目：找出工资高于平均工资的员工 错误写法：select ename,sal from emp where sal &gt; avg(sal);此时分组函数出现在了where中，因此改语句错误，原因是无效的使用了分组函数。正确写法：select ename,sal from emp where sal &gt; (select avg(sal) from emp); 嵌套一个SQL语句。 12345678910+-------+---------+| ename | sal |+-------+---------+| JONES | 2975.00 || BLAKE | 2850.00 || CLARK | 2450.00 || SCOTT | 3000.00 || KING | 5000.00 || FORD | 3000.00 |+-------+---------+ count(*) 与 count(具体的某个字段) 的区别 count(*)不是统计某个字段中的数据的个数，而是统计总记录条数。（和某个字段无关）count(某个具体的字段)：表示统计该字段中不为NULL的数据总数量。 group by 与 having group by：按照某个字段或者某些字段进行分组。having：是对分组之后的数据进行再次过滤分组函数一般会和group by 联合使用，这也是分组函数为什么叫这个名字的原因。 题目：找出每个工作岗位的最高薪资 select max(sal),job from emp group by job;将emp当中的数据根据job分组后在求出每组当中的最大薪资。 123456789+----------+-----------+| max(sal) | job |+----------+-----------+| 1300.00 | CLERK || 1600.00 | SALESMAN || 2975.00 | MANAGER || 3000.00 | ANALYST || 5000.00 | PRESIDENT |+----------+-----------+ 多个字段联合起来一起分组题目：找出每个部门不用岗位的最高薪资 select deptno,job,max(sal) from emp group by deptno,job order by deptno asc,job asc;这里我们还将结果根据deptno 和 job 进行了升序排序。 1234567891011121314+--------+-----------+----------+| deptno | job | max(sal) |+--------+-----------+----------+| 10 | CLERK | 1300.00 || 10 | MANAGER | 2450.00 || 10 | PRESIDENT | 5000.00 || 20 | ANALYST | 3000.00 || 20 | CLERK | 1100.00 || 20 | MANAGER | 2975.00 || 30 | CLERK | 950.00 || 30 | MANAGER | 2850.00 || 30 | SALESMAN | 1600.00 |+--------+-----------+----------+可以看出，group by 还可以同时多个进行分组的。 having题目：找出每个部门的最高薪资，要求显示最大薪资大于2900的数据。 select deptno,max(sal) from emp group by deptno having max(sal) &gt;2900;select deptno,max(sal) from emo where sal &gt; 2900 group by deptno;这两条语句都可以求出，但是我们用having的效率要比where的效率低，一般我们都推荐尽量使用where。 123456+--------+----------+| deptno | max(sal) |+--------+----------+| 20 | 3000.00 || 10 | 5000.00 |+--------+----------+ 题目：找出每个部门的平均薪资，要求显示平均薪资大于2000的。 select deptno,avg(sal) from emp group by deptno having avg(sal) &gt; 2000;注意：此时的平均薪资是通过分组函数进行求得的，我们无法直接获得这个值，所以此时不能用where来写，因为分组函数不能出现在where中。 123456+--------+-------------+| deptno | avg(sal) |+--------+-------------+| 20 | 2175.000000 || 10 | 2916.666667 |+--------+-------------+ 完整的SQL语句的顺序12345678910111213 执行顺序select 5 ...from 1 ...where 2 ..,group by 3 ...having 4 ...order by 6 ...","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"}]},{"title":"基数排序","date":"2021-03-31T14:23:41.000Z","path":"2021/03/31/基数排序/","text":"概念1待补充 代码如下主方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import java.util.Scanner;public class Demo &#123; public static void main(String[] args) &#123; int number = 0;//数组B的下标 int k = 1;//看第k位，从（倒数）第一位开始看 int Max = 0;//数组当中最大的数有几位 int count = 0; Scanner sc = new Scanner(System.in); System.out.print(&quot;请输入要排序的数的数量：&quot;); count = sc.nextInt(); int[] arrayA = new int[count]; int[] arrayB = new int[arrayA.length]; System.out.print(&quot;请输入&quot;+count+&quot;个数：&quot;); for(int i = 0;i &lt; count;i++)&#123; arrayA[i] = sc.nextInt(); &#125; //int[] arrayC = new int[arrayA.length]; //求最高位数 for(int i = 0; i &lt;arrayA.length;i++)&#123; int temp = getMax(arrayA[i]); if(temp &gt;= Max)&#123; Max = temp; &#125; &#125; //System.out.println(Max);//最高位数 //打印输出原始数组 System.out.print(&quot;原始素组为:&quot;); for (int i = 0; i &lt; arrayA.length; i++) &#123; System.out.print(arrayA[i]+&quot; &quot;); &#125; System.out.println(); //基数排序 while(k != Max+1)&#123; int p = 0;//判断循环是否结束 for(int i = 0;i &lt;=9 ;i++)&#123;//0~9是第几位的范围 for(int j = 0;j &lt;arrayA.length;j++)&#123; if(getNum(arrayA[j],k) == i)&#123; arrayB[number] = arrayA[j]; number++;//数组B的下标要单独定义，每次赋值后都需要移动到下一个下标 if(number == arrayA.length)&#123; break;//如果数组B已经满了，则提前结束循环 &#125; &#125; &#125; if(number == arrayA.length)&#123;//数组B存满后 number = 0;//重置数组B的下标 //System.out.println(&quot;k:&quot;+k); k++;//看的位数进行移动 /* //将原本的A数组给数组C for (i = 0; i &lt; arrayA.length; i++) &#123; arrayC[i] = arrayA[i]; &#125; */ //将新的数组B重新赋值给arrayA for (i = 0; i &lt; arrayA.length; i++) &#123; arrayA[i] = arrayB[i]; &#125; //打印输出 System.out.print(&quot;第&quot;+(k-1)+&quot;轮输出：&quot;);//因为前面提前k++了，所以应该是k-1轮。 for (i = 0; i &lt; arrayA.length; i++) &#123; System.out.print(arrayA[i]+&quot; &quot;); &#125; System.out.println(); break;//数组B满了后这个循环也要提前结束 &#125; &#125; //错误，不能这么判断，否则若在还没排完前一样的时候会提前结束 //判断数组B、C是否一样，如果一样，则提前结束循环 / *for(int i = 0;i &lt;arrayA.length;i++)&#123; if(arrayA[i] == arrayC[i])&#123; p++;//1+1+1+1=arrayA.length &#125; &#125; if(p == arrayA.length)&#123; break; &#125; */ &#125; &#125; 方法1：给定一个数num，返回该数的倒数第k个数，例如 num = 231, k = 2,则返回 3123456789101112public static int getNum(int num, int k) &#123; int count = 0; while(k != 0) &#123; count = num % 10; num = num / 10; /* if(num == 0)&#123; break; &#125;*/ k--; &#125; return count;&#125; 方法2：得到一个数有几位123456789 public static int getMax(int array)&#123; int count = 0;//计数器 while (array != 0)&#123; array = array/10; count++; &#125; return count; &#125;&#125; 总结121、基数排序的原理比较简单，但是代码实现起来比较复杂。2、","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"Hello World","date":"2021-03-24T07:02:20.000Z","path":"2021/03/24/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Java学习记录","date":"2021-03-24T06:45:00.000Z","path":"2021/03/24/Java学习记录/","text":"算法设计与分析实验一第一题题目12345678910给定一个正整数，编写程序计算有多少对质数的和等于输入的这个正整数，并输出结果。输入值小于1000。如，输入为10, 程序应该输出结果为2。（共有两对质数的和为10，分别为(5, 5) , (3, 7)）。输入输入一个整数n( 3≤n&lt;1000)。输出输出对数。样例输入10样例输出2 举例说明123410 【3,7】、【5,5】 212 【1,11】、【5,7】 215 【2,13】 120 【1,19】、【3,17】、【7,13】 3 分析12341、写一个方法来判断一个数是不是素数2、从头开始遍历，判断每一个数是否满足条件 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package study01;import java.util.Scanner;public class demo01 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int num = sc.nextInt(); //键盘获取输入的num值 int count = 0; //定义一个count，用来记录最后有几个质数对 int a = 1;//定义两个数，它们的和为num int b = num - a; //循环从1开始到中间那个数，排除了 例如num=10，有【3,7】，【7,3】这样的重复 while( a!= (num/2 + 1) ) &#123; if (sushu ( a ) &amp;&amp; sushu ( b )) &#123; count ++; //如果a,b都是素数，则计数器加一 System.out.println(&quot;[&quot;+a+&quot;,&quot;+b+&quot;] &quot;); &#125; a++; //循环一次后a++,b--，进行下次循环,满足条件后跳出循环 b--; //System.out.println(a+&quot; &quot;+b); &#125; System.out.println(count); //输出结果 &#125; //素数：除了1和它本身外不能被其他数整除的数叫做素数。 //判断的方法是从2到num-1，遍历看能不能被整除，如果能被其中的一个整除，则不是素数，如果都不可以整除，那么就不是素数。 //用来判断一个数是否为素数，如果是素数则返回true，如果不是素数则返回false public static boolean sushu(int num) &#123; if (num == 2 ||num == 1) &#123; //如果num刚好为2，则判定直接为素数 return true; &#125; else &#123; for (int i = 2; i &lt; num; i++) &#123; if (num % i == 0) &#123; return false; &#125;else&#123; //这里特别注意一定要讲循环走完一圈才可以出去，否则判断一次后循环就会结束。 if(i==num-1)&#123; return true; //判定i==num-1时才是循环了一圈，所以结束循环 &#125;else continue; //否则跳过此次循环进行下一次循环 &#125; &#125; return false; &#125; &#125;&#125; 总结以及心得1231、循环判断数的时候，为了避免【7，3】、【3,7】这种相同的情况，因此只需要判断到一半的位置即可。2、判断一个数是否为素数的时候，只遍历除了1和这个数本身之外的其他数，能否被自己整除即可。如果可以被整除，那么就不是素数。如果不可以被整除，那么就是素数。注意2是一个特殊情况，需要单独考虑。 第二题题目1234567891011121314151617181920小明想给老师当助教从而得一些补助。老师会给小明一些作业让他去批改，并按批改的作业份数和批改正确率来确定小明的补助费。老师是这么规定的，批改一份作业小明会得到m元，如果该份作业批改完全正确那么会从中扣除k元复查费；如果批改中出现了错误会从中扣除x元当惩罚费用，此时这份作业不再扣除复查费。但是老师觉得小明勤工助学不容易，不想扣过多的费用，于是规定如果有一份作业批改错误扣了x元，那么可以抵消一份批改正确作业的复查费。举例，如果有两份作业，一份批改正确一份批改错误，那么错误的那份小明可以得到m-x元，正确的那份小明可以得到m元，不用扣复查费。最后，你能算出小明一共能得多少补助么?输入第一行四个整数n、m、x、k，n表示小明批改作业的总份数，m、x、k的含义如题面描述，1≤n≤100000，1≤m, x, k≤100，x, k≤m;第二行n个整数，每个整数只有两种可能，0表示该份作业批改错误，1表示该份作业批改正确。输出输出一个整数，表示小明最后一共得到的补助费。样例输入总份数n 批改正确得到的钱 m 惩罚费用x 复查费k4 5 2 11 1 1 0（三正确 一错误） 1 1 1 1 0 0 10-2+20-4样例输出16 24 举例说明121 1 1 1 0 0 24 分析12341、通过Scanner函数来进行数字的输入2、知道题目结果如何计算3、考虑错误题目大于正确题目的特殊情况 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344package study02;import java.util.Scanner;public class demo01 &#123; public static void main(String[] args) &#123; int n, m, x, k; int r = 0;//改正确的题目 int f = 0;//改错误的题目 //总份数n 批改正确得到的钱 m 惩罚费用x 复查费k System.out.print(&quot;请依次输入 总份数n 批改正确得到的钱 m 惩罚费用x 复查费k：&quot;); Scanner sc = new Scanner(System.in);//键盘输入n,m,x,k n = sc.nextInt(); m = sc.nextInt(); x = sc.nextInt(); k = sc.nextInt(); System.out.print(&quot;请输入作业更改情况（正确为1，错误为0,最多输入&quot;+n+&quot;个数）：&quot;); int array[] = new int[n];//定义一个数组，用来记录题目的错误，并统计正确与错误赋值给r,f for(int i = 0; i &lt; n; i++)&#123; array[i] = sc.nextInt(); //System.out.print(array[i]+&quot;\\t&quot;);//输出数组 if(array[i]==1)&#123; r++; &#125;else if(array[i]==0)&#123; f++; &#125;else&#123; System.out.println(&quot;输入错误！&quot;); break; &#125; &#125; //System.out.println(&quot;r=&quot;+r); //System.out.println(&quot;f=&quot;+f); int sum = 0;//总价格 if(r&gt;=f)&#123; //正确题数大于错误题数 sum = n*m - f*x - (r-f)*k; &#125;else&#123; //错误题数大于正确题数，此时（r-f)为负，不能用上面的计算方式，此时不需要考虑复查情况。 sum=n*m - f*x; &#125; System.out.println(&quot;小明得到的钱为&quot; + sum);//输出结果 &#125;&#125; 总结以及心得12341、此题并不难，只需要知道题目的计算方式即可2、通过这题要学会Scanner函数的使用方法，该函数可以通过多次获取做到多次输入给多个数据赋值 注意：如果定义的只有n个数据，那么输入超过n个数的时候，只会获取前n个数据并进行赋值。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"基础学习","slug":"基础学习","permalink":"http://example.com/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]}]